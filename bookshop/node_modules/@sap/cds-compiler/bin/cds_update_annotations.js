#!/usr/bin/env node

// Update CDS Annotation References to use v4 expression syntax.
//
// This script replaces bare, unchecked references in annotation assignments
// with the new syntax using `(`.
//
// Example CDS:
//    @anno: ID entity E { key ID : String; };
// will become:
//    @anno: (ID) entity E { key ID : String; };
//
// Usage:
//   ./cds_update_annotations.js my_file.cds
//
// If you want to update all identifiers in a directory, you can use
// this Shell script:
//   find . -type f -iname '*.cds' -exec ./cds_update_annotations.js {} \;
//
// Note that you need to update the path to this script in the commands above.
//

'use strict';

const parseLanguage = require('../lib/language/antlrParser');
const { createMessageFunctions } = require('../lib/base/messages');

const fs = require('fs');
const path = require('path');
const { forEachMemberRecursively } = require('../lib/base/model');

const cliArgs = process.argv.slice(2);
const filepath = cliArgs[0];

if (filepath === '--help' || filepath === '-h')
  exitError();

if (cliArgs.length !== 1)
  exitError(`Expected exactly one argument, ${cliArgs.length} given`);

if (!filepath)
  exitError('Expected non-empty filepath as argument!');

// Do not use allow-list approach.
// There may be CDS files with other extensions than `.cds`.
if (filepath.endsWith('.csn') || filepath.endsWith('.json'))
  exitError('Only CDS files can be passed! Found CSN file!');

const sourceStr = fs.readFileSync(filepath, 'utf-8');
const newSourceStr = modernizeAnnotationExpressions(sourceStr, filepath);
if (newSourceStr !== sourceStr)
  fs.writeFileSync(filepath, newSourceStr);
process.exit(0); // success

// --------------------------------------------------------

function modernizeAnnotationExpressions( source, filename ) {
  const options = { messages: [], attachTokens: true };
  const messageFunctions = createMessageFunctions( options, 'parse', null );

  // parseLanguage does not throw on CompilationError, so
  // we do not need a try...catch block.
  const ast = parseLanguage(source, filename, options, messageFunctions);

  // To avoid spam, only report errors.
  // Users should use the compiler to get all messages.
  const errors = options.messages.filter(msg => (msg.severity === 'Error'));
  if (errors.length > 0) {
    errors.forEach((msg) => {
      console.error(msg.toString());
    });
    console.error(`Found ${errors.length} errors! \n`);
    exitError('The parser emitted errors. Please fix them first and try again.');
  }

  if (!ast.artifacts)
    return source;

  let currentOffset = 0;

  for (const artName in ast.artifacts) {
    const art = ast.artifacts[artName];
    updateAnnosOfArtifact(art);
    forEachMemberRecursively(art, updateAnnosOfArtifact);
  }
  for (const vocName in ast.vocabularies) {
    const voc = ast.vocabularies[vocName];
    updateAnnosOfArtifact(voc);
    forEachMemberRecursively(voc, updateAnnosOfArtifact);
  }
  for (const ext of ast.extensions)
    updateAnnosOfArtifact(ext);

  return source;

  // -----------------------------------------------

  function updateAnnosOfArtifact( art ) {
    for (const prop in art) {
      if (prop.charAt(0) === '@')
        updateAnno(art[prop]);
    }
  }

  function updateAnno( anno ) {
    if (anno.literal === 'array') {
      anno.val.forEach(val => updateAnno( val ));
    }
    else if (anno.literal === 'struct') {
      const struct = Object.values(anno.struct);
      struct.forEach(val => updateAnno( val ));
    }
    else if (!anno.$tokenTexts && anno.path) {
      const first = anno.path[0];
      const last = anno.path[anno.path.length - 1];
      insertParentheses(first, last);
    }
  }

  function findTokenFor( node ) {
    const loc = node.location;
    // We use slow linear search; we could do binary search, but not performance critical.
    const { tokens } = ast.tokenStream;
    for (const token of tokens) {
      if (token.column + 1 === loc.col && token.line === loc.line)
        return token;
    }
    return null;
  }

  function insertParentheses( first, last ) {
    const firstToken = findTokenFor(first);
    const lastToken = findTokenFor(last);

    if (!firstToken?.stop || !lastToken?.stop)
      throw new Error(`INTERNAL ERROR: Identifier at ${firstToken?.start} or ${lastToken?.start} has no end! (${filepath})`);

    const start = firstToken.start + currentOffset;
    const end = lastToken.stop + currentOffset + 1; // end points at the position *before* the character

    const original = source.substring(start, end);
    if (original.includes('@'))
      return; // we ignore annotation references for now

    const newSource = `( ${original} )`;
    source = replaceSliceInSource(source, start, end, newSource);

    currentOffset += (newSource.length - original.length);
  }
}

/**
 * Replaces a given span with @p replaceWith
 *
 * @param {string} source
 * @param {number} startIndex
 * @param {number} endIndex
 * @param {string} replaceWith
 * @return {string}
 */
function replaceSliceInSource( source, startIndex, endIndex, replaceWith ) {
  return source.substring(0, startIndex) +
          replaceWith +
          source.substring(endIndex);
}

/**
 * @param {string} [msg]
 */
function exitError( msg ) {
  if (msg)
    console.error(msg);
  usage();
  process.exit(1);
}

function usage() {
  console.error('');
  console.error(`usage: ${path.basename(process.argv[1])} <filename>`);
}
