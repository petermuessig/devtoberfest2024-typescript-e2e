'use strict';

const {
  getUtils, isAspect, mergeTransformers, applyTransformations,
} = require('../../model/csnUtils');
const transformUtils = require('../transformUtils');
const effectiveFlattening = require('./flattening');
const flattening = require('../db/flattening');
const types = require('./types');
// const { addLocalizationViews } = require('../../transform/localized');
const validate = require('../../checks/validator');
const expansion = require('../db/expansion');
const queries = require('./queries');
const associations = require('./associations');
const handleExists = require('../db/transformExists');
const misc = require('./misc');
const annotations = require('./annotations');
const { rewriteCalculatedElementsInViews, processCalculatedElementsInEntities } = require('../db/rewriteCalculatedElements');
const { cloneFullCsn } = require('../../model/cloneCsn');

/**
 * This is just a PoC for now!
 *
 * Transform the given CSN into a so called effective CSN, by
 * - dissolving structured types
 * - turning managed into unmanaged associations
 * @private
 * @param {CSN.Model} model Input CSN - will not be transformed
 * @param {CSN.Options} options
 * @param {object} messageFunctions
 * @returns {CSN.Model}
 */
function effectiveCsn( model, options, messageFunctions ) {
  const csn = cloneFullCsn(model, options);
  delete csn.vocabularies; // must not be set for effective CSN
  messageFunctions.setModel(csn);

  const { expandStructsInExpression } = transformUtils.getTransformers(csn, options, messageFunctions, '_');
  const redoProjections = queries.projectionToSELECTAndAddColumns(csn);

  let csnUtils = getUtils(csn, 'init-all');

  // Run validations on CSN - each validator function has access to the message functions and the inspect ref via this
  const cleanup = validate.forRelationalDB(csn, {
    ...messageFunctions, csnUtils, ...csnUtils, csn, options, isAspect,
  });

  rewriteCalculatedElementsInViews(csn, options, csnUtils, '_', messageFunctions);

  // Needs to happen before tuple expansion, so the newly generated WHERE-conditions have it applied
  handleExists(csn, options, messageFunctions.error, csnUtils.inspectRef, csnUtils.initDefinition, csnUtils.dropDefinitionCache);

  // Check if structured elements and managed associations are compared in an expression
  // and expand these structured elements. This tuple expansion allows all other
  // subsequent procession steps to see plain paths in expressions.
  // If errors are detected, throwWithAnyError() will return from further processing
  expandStructsInExpression(csn, { drillRef: true });

  messageFunctions.throwWithAnyError();

  // Expand a structured thing in: keys, columns, order by, group by
  expansion.expandStructureReferences(csn, options, '_', messageFunctions, csnUtils);

  const resolveTypesInActionsAfterFlattening = types.resolve(csn, csnUtils, options);

  // Remove properties attached by validator - they do not "grow" as the model grows.
  cleanup();


  effectiveFlattening.flattenRefs(csn, options, csnUtils, messageFunctions);
  flattening.flattenElements(csn, options, messageFunctions, '_', { skipDict: { actions: true } });

  resolveTypesInActionsAfterFlattening();

  // ensure getElement works on flattened struct_assoc columns
  csnUtils = getUtils(csn, 'init-all');

  processCalculatedElementsInEntities(csn);
  associations.managedToUnmanaged(csn, options, csnUtils, messageFunctions);
  associations.transformBacklinks(csn, options, csnUtils, messageFunctions);
  const transformers = mergeTransformers([ options.addCdsPersistenceName ? misc.attachPersistenceName(csn, options, csnUtils) : {}, options.remapOdataAnnotations ? annotations.remapODataAnnotations(csn) : {}, misc.removeDefinitionsAndProperties(csn, options) ], null);
  applyTransformations(csn, transformers, [], { skipIgnore: false, processAnnotations: true });

  if (!options.resolveProjections)
    redoProjections.forEach(fn => fn());

  messageFunctions.throwWithError();

  return csn;
}

module.exports = { effectiveCsn };
