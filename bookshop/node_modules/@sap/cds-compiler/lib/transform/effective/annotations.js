'use strict';

const { CompilerAssertion } = require('../../base/error');

const directMappings = {
  '@Common.IsDayOfCalendarMonth': replace('@Semantics.calendar.dayOfMonth'),
  '@Common.IsDayOfCalendarYear': replace('@Semantics.calendar.dayOfYear'),
  '@Common.IsCalendarWeek': replace('@Semantics.calendar.week'),
  '@Common.IsCalendarMonth': replace('@Semantics.calendar.month'),
  '@Common.IsCalendarQuarter': replace('@Semantics.calendar.quarter'),
  '@Common.IsCalendarHalfyear': replace('@Semantics.calendar.halfyear'),
  '@Common.IsCalendarYear': replace('@Semantics.calendar.year'),
  '@Common.IsCalendarYearWeek': replace('@Semantics.calendar.yearWeek'),
  '@Common.IsCalendarYearMonth': replace('@Semantics.calendar.yearMonth'),
  '@Common.IsCalendarYearQuarter': replace('@Semantics.calendar.yearQuarter'),
  '@Common.IsCalendarYearHalfyear': replace('@Semantics.calendar.yearHalfyear'),
  '@Common.IsCalendarDate': replace('@Semantics.date'),
  '@Common.IsFiscalYearVariant': replace('@Semantics.yearVariant'),
  '@Common.IsFiscalPeriod': replace('@Semantics.period'),
  '@Common.IsFiscalYear': replace('@Semantics.year'),
  '@Common.IsFiscalYearPeriod': replace('@Semantics.yearPeriod'),
  '@Common.IsFiscalQuarter': replace('@Semantics.quarter'),
  '@Common.IsFiscalYearQuarter': replace('@Semantics.yearQuarter'),
  '@Common.IsFiscalWeek': replace('@Semantics.week'),
  '@Common.IsFiscalYearWeek': replace('@Semantics.yearWeek'),
  '@Common.IsDayOfFiscalYear': replace('@Semantics.dayOfYear'),
  '@Measures.ISOCurrency': (csn, artifact, element, oldAnno) => {
    const { targetElement } = getAnnoRefTarget(csn, artifact, element[oldAnno]);
    if (refPointsToThisArtifact(csn, artifact, element, oldAnno)) {
      replace('@Semantics.amount.currencyCode')(csn, artifact, element, oldAnno);
      if (targetElement && targetElement['@Semantics.currencyCode'] === undefined)
        targetElement['@Semantics.currencyCode'] = true;
    }
  },
  '@Measures.Unit': (csn, artifact, element, oldAnno) => {
    const { targetElement } = getAnnoRefTarget(csn, artifact, element[oldAnno]);
    if (refPointsToThisArtifact(csn, artifact, element, oldAnno)) {
      replace('@Semantics.quantity.unitOfMeasure')(csn, artifact, element, oldAnno);
      if (targetElement && targetElement['@Semantics.unitOfMeasure'] === undefined)
        targetElement['@Semantics.unitOfMeasure'] = true;
    }
  },
  '@UI.IsImageURL': replace('@Semantics.imageUrl'),
  '@Common.ValueList.CollectionPath': (csn, artifact, element) => {
    if (!element.target && element['@Consumption.valueHelpDefinition'] === undefined) {
      if (element['@Common.ValueList.Parameters'] && Array.isArray(element['@Common.ValueList.Parameters'])) {
        const InOutParameters = element['@Common.ValueList.Parameters'].filter(param => param.$Type === 'Common.ValueListParameterInOut');

        if (InOutParameters.length === 1) {
          element['@Consumption.valueHelpDefinition'] = [ {
            name: element['@Common.ValueList.CollectionPath'],
          } ];

          delete element['@Common.ValueList.CollectionPath'];
          delete element['@Common.ValueList.Label'];

          element['@Consumption.valueHelpDefinition'][0].element = element['@Common.ValueList.Parameters'][0].ValueListProperty;
          delete element['@Common.ValueList.Parameters'];
        }
      }
    }
  },
  '@Common.TextFor': replace('@Semantics.text', true),
  '@Common.IsLanguageIdentifier': replaceIf('@Semantics.language', true, (csn, artifact, element, anno) => !!element[anno]),
  // We need to set two different annos here, depending on the value -> need a custom replacer
  '@Common.Text': (csn, artifact, element, oldAnno) => {
    const { targetArtifact, targetElement } = getAnnoRefTarget(csn, artifact, element[oldAnno]);
    if (targetArtifact === artifact && !element['@ObjectModel.text.element'] && !targetElement['@Semantics.text']) {
      element['@ObjectModel.text.element'] = element[oldAnno];
      if (targetElement['@Semantics.text'] === undefined)
        targetElement['@Semantics.text'] = true;
      delete element['@Common.Text'];
    }
    else if (targetArtifact && targetElement && !element['@ObjectModel.text.association'] && !targetElement['@Semantics.text']) {
      element['@ObjectModel.text.association'] = element[oldAnno];
      if (targetElement['@Semantics.text'] === undefined)
        targetElement['@Semantics.text'] = true;
      delete element['@Common.Text'];
    }
  },
};

/**
 *
 * @param {CSN.Model} csn
 * @param {CSN.Artifact} artifact
 * @param {CSN.Element} element
 * @param {object} anno
 * @returns {boolean}
 */
function refPointsToThisArtifact( csn, artifact, element, anno ) {
  const { targetArtifact } = getAnnoRefTarget(csn, artifact, element[anno]);
  return targetArtifact && targetArtifact === artifact;
}

/**
 * Walk the possible annotation ref and return the artifact and element it points to
 *
 * @param {CSN.Model} csn
 * @param {CSN.Artifact} startArtifact
 * @param {object} annoValue
 * @returns {object}
 */
function getAnnoRefTarget( csn, startArtifact, annoValue ) {
  if (!annoValue || !annoValue['='])
    return { targetArtifact: undefined, targetElement: undefined };

  const steps = annoValue['='].split('.');
  let base = startArtifact;
  let element;
  for (const step of steps) {
    if (!base.elements)
      return { targetArtifact: undefined, targetElement: undefined };
    element = base.elements[step];
    if (!element)
      return { targetArtifact: undefined, targetElement: undefined };
    if (element.target)
      base = csn.definitions[element.target];
  }

  return { targetArtifact: base, targetElement: element };
}

/**
 * Get the function to replace oldAnno with newAnno on carrier.
 *
 * - If available, use "replacement" as value.
 * - Only do replacement if "condition" returns true
 * - Possibly set additional annotations via "additional"
 * @param {string} newAnno
 * @param {any} replacement
 * @param {Function} [condition]
 * @param {Function} [additional]
 * @returns {Function}
 */
function replace( newAnno, replacement, condition = () => true, additional = () => true ) {
  return function replaceAnnotationPrefix(csn, artifact, carrier, oldAnno) {
    if (carrier[newAnno] === undefined && condition(csn, artifact, carrier, oldAnno, newAnno)) {
      carrier[newAnno] = replacement || carrier[oldAnno];
      additional(carrier, oldAnno, newAnno);
      delete carrier[oldAnno];
    }
  };
}

/**
 * Get the function to replace oldAnno with newAnno on carrier.
 *
 * - If available, use "replacement" as value.
 * - Only do replacement if "condition" returns true
 *
 * @param {string} newAnno
 * @param {any} replacement
 * @param {Function} condition
 * @returns {Function}
 */
function replaceIf( newAnno, replacement, condition ) {
  return replace( newAnno, replacement, condition );
}

/**
 *
 * @param {CSN.Model} csn
 * @returns {object} Transfomer object for applyTransformations
 */
function remapODataAnnotations( csn ) {
  /**
   *
   * @param {CSN.Artifact} artifact
   * @param {CSN.Element} element Element to process
   */
  function remapAnnotationsOnElement( artifact, element ) {
    if (element.elements && !element.$ignore) // We expect to only be called on flattened CSN - error if we encounter .elements!
      throw new CompilerAssertion(`Expected a flat model. Found element with subelements: ${JSON.stringify(element)}`);
    for (const prop in element) {
      if (directMappings[prop])
        directMappings[prop](csn, artifact, element, prop);
    }
  }

  return {
    elements: (parent, prop, elements, path, _parentParent, _dummy, context) => {
      const artifact = csn.definitions[path[1]];
      // Don't process bound actions, as they are still structured
      if (artifact?.kind === 'entity' && !context.$in_actions) {
        for (const elementName in elements)
          remapAnnotationsOnElement(artifact, elements[elementName]);
      }
    },
  };
}

module.exports = {
  remapODataAnnotations,
};
