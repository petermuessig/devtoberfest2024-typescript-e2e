'use strict';

const keywords = require('../base/keywords');
const { cdlNewLineRegEx } = require('../language/textUtils');
const { findElement, createExpressionRenderer, withoutCast } = require('./utils/common');
const { escapeString, hasUnpairedUnicodeSurrogate } = require('./utils/stringEscapes');
const { checkCSNVersion } = require('../json/csnVersion');
const { forEachDefinition, normalizeTypeRef } = require('../model/csnUtils');
const enrichUniversalCsn = require('../transform/universalCsn/universalCsnEnricher');
const { isBetaEnabled } = require('../base/model');
const { ModelError } = require('../base/error');
const { typeParameters, specialFunctions } = require('../compiler/builtins');
const { isAnnotationExpression } = require('../base/builtins');
const { forEach } = require('../utils/objectUtils');
const {
  getNormalizedQuery,
} = require('../model/csnUtils');
const { isBuiltinType } = require('../base/builtins');
const { cloneFullCsn } = require('../model/cloneCsn');
const { getKeysDict } = require('../model/csnRefs');

const identifierRegex = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
const specialFunctionKeywords = Object.create(null);

/**
 * Render the CSN model 'model' to CDS source text.
 * Returned object has the following properties:
 *  - `model`: CSN model rendered as CDL (string).
 *  - `namespace`: Namespace statement + `using from './model.cds'.
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 * @param {object} msg Message Functions
 */
function csnToCdl( csn, options, msg ) {
  const special$self = !csn?.definitions?.$self && '$self';
  if (options.csnFlavor === 'universal' && isBetaEnabled(options, 'enableUniversalCsn')) {
    // Since the expander modifies the CSN, we need to clone it first or
    // toCdl can't guarantee that the input CSN is not modified.
    csn = cloneFullCsn(csn, options);
    enrichUniversalCsn(csn, options);
  }

  checkCSNVersion(csn, options);

  const exprRenderer = createCdlExpressionRenderer();
  const usings = {
    list: [],
    available: availableFirstPathSteps(csn),
    addIfRequired(name) {
      // RegEx is at least twice as fast as .split()[0]
      const first = name.match(/^[^.]+/)[0];
      if (name !== special$self && !this.available.includes(first) && !this.list.includes(first))
        this.list.push(first);
    },
    renderUsings() {
      if (this.list.length === 0)
        return '';
      return `using { ${this.list.join(', ')} };\n\n`;
    },
  };
  const hanaRequiresAbsolutePath = usings.available.includes('hana');

  const cdlResult = Object.create(null);
  cdlResult.model = '';

  const subelementAnnotates = [];

  cdlResult.model += renderDefinitions();
  // sub-element annotations that can't be written directly.
  cdlResult.model += renderExtensions(subelementAnnotates, createEnv());

  if (csn.vocabularies)
    cdlResult.model += renderVocabularies(csn.vocabularies);
  if (csn.extensions)
    cdlResult.model += renderExtensions(csn.extensions, createEnv());

  if (csn.namespace) {
    cdlResult.namespace = `namespace ${renderArtifactName(csn.namespace, createEnv())};\n`;
    cdlResult.namespace += 'using from \'./model.cds\';';
  }

  cdlResult.model = usings.renderUsings() + cdlResult.model;
  if (csn.requires) {
    let usingsStr = csn.requires.map(req => `using from '${req}';`).join('\n');
    usingsStr += '\n\n';
    cdlResult.model = usingsStr + cdlResult.model;
  }

  msg.throwWithError();
  return cdlResult;

  /**
   * Render entries from the `csn.definitions` dictionary.
   * Returns an empty string if nothing is rendered.
   *
   * @return {string}
   */
  function renderDefinitions() {
    let result = '';
    const env = createEnv();
    forEachDefinition(csn, (artifact, artifactName) => {
      const sourceStr = renderDefinition(artifactName, artifact, env);
      if (sourceStr !== '')
        result += `${sourceStr}\n`;
    });
    return result;
  }

  /**
   * Render annotation definitions, i.e. entries from csn.vocabularies.
   * Returns an empty string if there isn't anything to render.
   *
   * @param {object} vocabularies
   * @return {string}
   */
  function renderVocabularies( vocabularies ) {
    let result = '';
    forEach(vocabularies, renderVocabulariesEntry);
    return result;

    function renderVocabulariesEntry( name, anno ) {
      if (!anno.$ignore) {
        // This environment is passed down the call hierarchy, for dealing with
        // indentation and name resolution issues
        const env = createEnv({ path: [ 'vocabularies', name ] });
        const sourceStr = renderTypeOrAnnotation(name, anno, env, 'annotation');
        result += `${sourceStr}\n`;
      }
    }
  }

  /**
   * Render 'extend' and 'annotate' statements from the `extensions` array.
   * Could be annotate-statements for sub-elements annotations or from parseCdl's
   * extensions array or just unapplied extensions.
   *
   * @param {CSN.Extension[]} extensions
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtensions( extensions, env ) {
    if (!env.path)
      env = env.cloneWith({ path: [ 'extensions' ] });
    return extensions.map((ext, index) => renderExtension(ext, env.withSubPath([ index ]))).join('\n');
  }

  /**
   * Render an 'extend' and 'annotate' statement.
   *
   * @param {CSN.Extension} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtension( ext, env ) {
    if (ext.extend)
      return renderExtendStatement(ext.extend, ext, env);
    return renderAnnotateStatement(ext, env);
  }

  /**
   * Render an 'extend' statement.
   * `extName` is the extension's artifact's name, most likely `ext.extend`.
   * This function is recursive, which is why you need to pass it explicitly.
   *
   * @param {string} extName
   * @param {object} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtendStatement( extName, ext, env ) {
    // Element extensions have `kind` set. Don't use for enum extension.
    const isElementExtend = (ext.kind === 'extend' && !ext.enum);
    let result = renderAnnotationAssignmentsAndDocComment(ext, env);
    extName = isElementExtend ? renderArtifactName(extName, env) : renderDefinitionReference(extName, env);

    if (ext.includes && ext.includes.length > 0) {
      // Includes can't be combined with anything in braces {}.
      const affix = isElementExtend ? 'element ' : '';
      const includes = ext.includes.map((inc, i) => renderDefinitionReference(inc, env.withSubPath([ 'includes', i ]))).join(', ');
      result += `${env.indent}extend ${affix}${extName} with ${includes};\n`;
      return result;
    }

    const typeParams = renderTypeParameters(ext, true);
    if (typeParams) {
      result += `${env.indent}extend ${extName} with ${typeParams};\n`;
      return result;
    }

    // If there is nothing to extend, e.g. only annotations, don't render an
    // empty element list.  This would end up in diffs with parseCdl CSN.
    if (!ext.elements && !ext.columns && !ext.actions && !ext.enum) {
      result += `${env.indent}extend ${extName};\n`;
      return result;
    }

    // We have the "old-style" prefix syntax and the "new-style" postfix "with <type>" syntax.
    // The former one can not only extend (sub-)elements but also actions in the same statement whereas
    // the latter cannot.
    // If there are actions, check if there are also elements/columns, and if so, use the prefix notation.
    const usePrefixNotation = ext.actions && (ext.columns || ext.elements);
    if (usePrefixNotation)
      result += `${env.indent}extend ${getExtendPrefixVariant(ext)} ${extName} with {\n`;
    else
      result += `${env.indent}extend ${extName} with ${getExtendPostfixVariant(ext)}{\n`;

    if (ext.columns)
      result += renderViewColumns(ext, env.withIncreasedIndent());

    else if (ext.elements || ext.enum)
      result += renderExtendStatementElements(ext, env);

    // Not part of if/else cascade, because it may be in postfix notation.
    if (ext.actions) {
      const childEnv = env.withIncreasedIndent();
      let actions = '';
      forEach(ext.actions, (actionName, action) => {
        actions += renderActionOrFunction(actionName, action, childEnv.withSubPath([ 'actions', actionName ]));
      });
      if (!usePrefixNotation)
        result += actions;
      else if (actions !== '')
        result += `${env.indent}} actions {\n${actions}`;
    }

    result += `${env.indent}};\n`;
    return result;
  }

  /**
   * What <extend> prefix type to use.  Used to render `extend <type> <ref>` statements.
   *
   * @param {object} ext
   * @return {string}
   */
  function getExtendPrefixVariant( ext ) {
    if (ext.kind === 'extend')
      return 'element'; // element extensions inside an `extend`
    if (ext.columns)
      return 'projection';
    if (ext.elements)
      return 'entity';
    return '';
  }

  /**
   * What <extend> postfix type to use.  Used to render `extend <ref> with <type>` statements.
   *
   * @param {CSN.Extension} ext
   * @return {string}
   */
  function getExtendPostfixVariant( ext ) {
    if (ext.columns)
      return 'columns ';
    if (ext.actions)
      return 'actions ';
    if (ext.enum)
      return 'enum ';
    if (ext.elements) { // enum/elements ambiguity -> look into elements
      const isLikelyElement = Object.keys(ext.elements)
        .find(name => ext.elements[name].value !== undefined);
      if (isLikelyElement)
        return 'elements ';
    }
    // ambiguity; no postfix, i.e. `extend … with { … }`.s
    return '';
  }

  /**
   * Render the elements inside an `extend` statement. They may themselves be `extend` statements.
   *
   * @param {CSN.Extension} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtendStatementElements( ext, env ) {
    let result = '';
    const prop = ext.elements ? 'elements' : 'enum';
    forEach(ext[prop] || {}, (elemName, element) => {
      const childEnv = env.withIncreasedIndent().withSubPath([ 'elements', elemName ]);
      if (element.kind === 'extend')
        result += renderExtendStatement(elemName, element, childEnv);
      else
        // As soon as we are inside an element, nested `extend` are not possible,
        // since we can't extend an existing element of a new one.
        result += renderElement(elemName, element, childEnv.withSubPath([ prop, elemName ]));
    });
    return result;
  }

  /**
   * Render an 'annotate' statement.
   *
   * @param {CSN.Extension} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotateStatement( ext, env ) {
    // Special case: Super annotate has both "returns" and "elements".
    // Render as separate `annotate`s, but keep the order.
    if (ext.elements && ext.returns) {
      const [ , second ] = Object.keys(ext).filter(key => key === 'elements' || key === 'returns');

      // The first of 'elements' or 'returns' gets all other properties as well.
      // The second only gets one property (itself).
      let result = renderAnnotateStatement({ ...ext, [second]: undefined }, env);
      result += renderAnnotateStatement({ annotate: ext.annotate, [second]: ext[second] }, env);

      return result;
    }

    // Top-level annotations of the artifact
    let result = renderAnnotationAssignmentsAndDocComment(ext, env);
    // Note: Not renderDefinitionReference, because we don't care if there
    //       are annotations to unknown things. That's allowed!
    result += `${env.indent}annotate ${renderArtifactName(ext.annotate, env)}`;

    if (ext.params)
      result += renderAnnotateParamsInParentheses(ext, env);

    // Element extensions and annotations (possibly nested)
    if (ext.elements || ext.enum)
      result += ` ${renderAnnotateStatementElements(ext, env)}`;

    else if (ext.returns)
      result += renderAnnotateReturns(ext, env);


    if (ext.actions) { // Bound action annotations
      result += ' actions {\n';
      env.increaseIndent();
      env.path.push('actions', '');
      for (const name in ext.actions) {
        env.path[env.path.length - 1] = name;
        const action = ext.actions[name];
        result += renderAnnotationAssignmentsAndDocComment(action, env) + env.indent + quoteNonIdentifierOrKeyword(name, env);
        // Action parameter annotations
        if (action.params)
          result += renderAnnotateParamsInParentheses(action, env);
        if (action.returns)
          result += renderAnnotateReturns(action, env);

        result = removeTrailingNewline(result);
        result += ';\n';
      }
      env.decreaseIndent();
      result += `${env.indent}}`;
    }

    result = removeTrailingNewline(result);
    result += ';\n';
    return result;
  }

  /**
   * Render the elements-specific part of an 'annotate' statement for an element dictionary
   * 'ext.elements' (assuming that the surrounding parent has just been rendered, without trailing newline).
   * Returns the resulting source string, ending without a trailing newline.
   *
   * @param {object} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotateStatementElements( ext, env ) {
    const elements = ext.enum ? ext.enum : ext.elements;
    let result = '{\n';
    env.increaseIndent();
    env.path.push(ext.enum ? 'enum' : 'elements', '');
    for (const name in elements) {
      env.path[env.path.length - 1] = name;
      const elem = elements[name];
      result += renderAnnotationAssignmentsAndDocComment(elem, env);
      result += env.indent + quoteNonIdentifierOrKeyword(name, env);
      if (elem.elements) {
        env.path.push('elements');
        result += ` ${renderAnnotateStatementElements(elem, env)}`;
        env.path.pop();
      }
      else if (elem.enum) {
        env.path.push('enum');
        result += ` ${renderAnnotateStatementElements(elem, env)}`;
        env.path.pop();
      }

      result += ';\n';
    }
    env.path.length -= 2;
    env.decreaseIndent();
    result += `${env.indent}}`;
    return result;
  }

  /**
   * Renders the `returns` part of an `annotate` statement for (bound) actions.
   * `ext` must be an object with a `returns` property.
   *
   * @param {CSN.Extension} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotateReturns( ext, env ) {
    env = env.withSubPath([ 'returns', 'elements' ]);
    let result = ' returns';

    const returnAnnos = renderAnnotationAssignmentsAndDocComment(ext.returns, env.withIncreasedIndent());
    if (returnAnnos)
      result += `\n${returnAnnos}`;

    if (ext.returns.elements) {
      // Annotations are on separate lines: Have it aligned nicely
      result += returnAnnos ? `${env.indent}` : ' ';
      result += renderAnnotateStatementElements(ext.returns, env);
    }
    return result;
  }

  /**
   * Render a parameter list for `annotate` statements, in parentheses `()`.
   *
   * @param {CSN.Artifact} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotateParamsInParentheses( ext, env ) {
    const childEnv = env.withIncreasedIndent();
    let result = '(\n';
    const paramAnnotations = [];
    forEach(ext.params, (paramName, param) => {
      const annos = renderAnnotationAssignmentsAndDocComment(param, childEnv);
      const name = quoteNonIdentifierOrKeyword(paramName, childEnv);
      // Not supported, yet (#13052)
      // const sub = (param.elements || param.enum) ? ` ${renderAnnotateStatementElements(param, childEnv)}` : '';
      paramAnnotations.push( annos + childEnv.indent + name);
    });
    result += `${paramAnnotations.join(',\n')}\n${env.indent})`;
    return result;
  }

  /**
   * Render an artifact. Return the resulting source string.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function renderDefinition( artifactName, art, env ) {
    env = env.cloneWith({ path: [ 'definitions', artifactName ] });

    const kind = art.kind || 'type'; // the default kind is "type".
    switch (kind) {
      case 'entity':
        if (art.query || art.projection)
          return renderView(artifactName, art, env);
        return renderEntity(artifactName, art, env);
      case 'aspect':
        return renderAspect(artifactName, art, env);

      case 'context':
      case 'service':
        return renderContextOrService(artifactName, art, env);

      case 'type':
      case 'annotation': // annotation in 'csn.definitions' for compiler v1 compatibility
        return renderTypeOrAnnotation(artifactName, art, env);

      case 'action':
      case 'function':
        return renderActionOrFunction(artifactName, art, env);

      case 'event':
        return renderEvent(artifactName, art, env);

      default:
        throw new ModelError(`to.cdl: Unknown artifact kind: '${art.kind}' at ${JSON.stringify(env.path)}`);
    }
  }

  /**
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function renderEvent( artifactName, art, env ) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    const normalizedArtifactName = renderArtifactName(artifactName, env);
    result += `${env.indent}event ${normalizedArtifactName}`;
    if (art.includes)
      result += renderIncludes(art.includes, env);
    if (art.query || art.projection) {
      result += ' : ';
      // events (should) only support "projections"
      result += renderQuery(getNormalizedQuery(art).query, true, 'projection',
                            env.withSubPath([ art.projection ? 'projection' : 'query' ]));
      result += ';\n';
    }
    else if (art.type) {
      // Derived type or annotation with non-anonymous type
      result += ` : ${renderTypeReferenceAndProps(art, env)};\n`;
    }
    else if (art.elements) {
      result += ` ${renderElements(art, env)};\n`;
    }
    return result;
  }

  /**
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderContextOrService( artifactName, art, env ) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent}${art.kind} ${renderArtifactName(artifactName, env)}`;
    return `${result} {};\n`;
  }

  /**
   * Render a (non-projection, non-view) entity. Return the resulting source string.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderEntity( artifactName, art, env ) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += env.indent + (art.abstract ? 'abstract ' : '');
    result += `entity ${renderArtifactName(artifactName, env)}`;

    if (art.params)
      result += renderParameters(art, env);
    if (art.includes)
      result += renderIncludes(art.includes, env);

    if (art.elements)
      result += ` ${renderElements(art, env)}`;
    else if (art.actions)
      // if there are no elements, but actions, CDL syntax requires braces.
      result += ' { }';

    result += `${renderActionsAndFunctions(art, env)};\n`;

    return result;
  }

  /**
   * Render an aspect. Return the resulting source string.
   * Behaves very similar to renderEntity, _except_ that aspects are
   * allowed to _not_ have elements, e.g. `aspect A;`.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAspect( artifactName, art, env ) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent}aspect ${renderArtifactName(artifactName, env)}`;
    if (art.includes)
      result += renderIncludes(art.includes, env);

    if (art.elements)
      result += ` ${renderElements(art, env)}`;
    else if (art.actions)
      // if there are no elements, but actions, CDL syntax requires braces.
      result += ' { }';

    result += `${renderActionsAndFunctions(art, env)};\n`;
    return result;
  }

  /**
   * Render a list of elements enclosed in braces.  If the list is empty, returns `{ }`.
   *
   * @param {object} artifact Artifact with `elements` property.
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderElements( artifact, env ) {
    let elements = '';
    const childEnv = env.withIncreasedIndent();
    for (const name in artifact.elements)
      elements += renderElement(name, artifact.elements[name], childEnv.withSubPath([ 'elements', name ]));

    return (elements === '') ? '{ }' : `{\n${elements}${env.indent}}`;
  }

  /**
   * Render an element (of an entity, type or annotation, not a projection or view)
   * or an enum symbol.
   * Returns the resulting source string.
   *
   * @param {string} elementName
   * @param {CSN.Element} element
   * @param {CdlRenderEnvironment} env
   */
  function renderElement( elementName, element, env ) {
    const isCalcElement = (element.value !== undefined);
    let result = renderAnnotationAssignmentsAndDocComment(element, env);
    result += env.indent;
    result += element.virtual ? 'virtual ' : '';
    result += element.key ? 'key ' : '';
    result += element.masked ? 'masked ' : '';
    result += quoteNonIdentifierOrKeyword(elementName, env);
    if (element.val !== undefined) { // enum value
      result += ` = ${exprRenderer.renderExpr(element, env)}`;
    }
    else if (element['#'] !== undefined) { // enum symbol reference
      result += ` = #${element['#']}`;
    }
    else if (!isCalcElement || !isDirectAssocOrComp(element.type) && !element.$filtered && !element.$enclosed) {
      // If the element is a calculated element _and_ a direct association or
      // composition, we'd render `Association to F on (cond) = calcValue;` which
      // would alter the ON-condition.
      // If it is a calculated element _and_ an indirect association (via type chain),
      // we'd get a cast to an association.
      const props = renderTypeReferenceAndProps(element, env);
      if (props !== '')
        result += ` : ${props}`;
    }

    if (isCalcElement) { // calculated element // @ts-ignore
      result += ' = ';
      env.path.push('value');
      const isSubExpr = (element.value.xpr && xprContainsCondition(element.value.xpr));
      result += isSubExpr
        ? exprRenderer.renderSubExpr(element.value, env)
        : exprRenderer.renderExpr(element.value, env);
      if (element.value.stored === true)
        result += ' stored';
      env.path.length -= 1;
    }

    return `${result};\n`;
  }

  /**
   * Render annotations that were extended to a query element of a view or projection (they only
   * appear in the view's 'elements', not in their 'columns' for client CSN, because the element
   * itself may not even be in 'columns', e.g. if it was expanded from a '*').  Return the
   * resulting rendered 'annotate' statement or an empty string if none required.
   *
   * Note: In the past, we checked if the annotation also exists in the respective column,
   *       however, in client CSN, annotations are not part of the column and in parseCdl CSN,
   *       no `elements` exist.
   *
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderQueryElementAndEnumAnnotations( art, env ) {
    const annotate = collectAnnotationsOfElementsAndEnum(art, env);
    if (annotate)
      return renderExtensions([ annotate ], env);
    return '';
  }

  /**
   * Create an "annotate" statement as a CSN extension for all annotations of (sub-)elements.
   * If no annotation was found, we return `null`.
   *
   * @param {CSN.Artifact} artifact
   * @param {CdlRenderEnvironment} env
   * @return {CSN.Extension|null}
   */
  function collectAnnotationsOfElementsAndEnum( artifact, env ) {
    // Array, which may be annotated as well.
    if (artifact.items) {
      env = env.withSubPath([ 'items' ]);
      artifact = artifact.items;
    }

    if (!artifact.elements && !artifact.enum && !artifact.keys)
      return null;

    const annotate = { annotate: env.path[1] };

    // Based on the current path, create a correctly nested structure
    // of elements for which we collect annotations.
    let obj = annotate;
    for (let i = 2; i < env.path.length; ++i) {
      const key = env.path[i];
      if (key === 'elements' || key === 'actions' || key === 'params') {
        obj[key] = Object.create(null);
        const elem = env.path[i + 1];
        obj[key][elem] = {};
        obj = obj[key][elem];
      }
      else if (key === 'returns') {
        obj.returns = {};
        obj = obj.returns;
      }
      else {
        // ignore others, e.g. 'items'
      }
    }
    return collectAnnos(obj, artifact) ? annotate : null;

    /**
     * Recursive function to collect annotations. `annotateObj` will get an `elements`
     * object with annotations only if there are annotations on `art`'s (sub-)elements or
     * enums.  Returned object will use "elements" even for enums, since that is
     * expected in extensions.
     *
     * @return {boolean} True, if there were annotations, false otherwise.
     */
    function collectAnnos( annotateObj, art ) {
      if (!Object.hasOwnProperty.call(art, 'elements') &&
        !Object.hasOwnProperty.call(art, 'enum') &&
        !Object.hasOwnProperty.call(art, 'keys'))
        return false;

      const dict = art.enum || art.keys && getKeysDict(art) || art.elements;
      // Use "elements" for all. This is allowed in extensions.
      const collected = { elements: Object.create(null) };
      let hasAnnotation = false;

      forEach(dict, (elemName, element) => {
        if (!collected.elements[elemName])
          collected.elements[elemName] = { };

        let hasElementAnnotations = false;
        for (const name in element) {
          if (name.startsWith('@')) {
            collected.elements[elemName][name] = element[name];
            hasElementAnnotations = true;
            hasAnnotation = true;
          }
        }

        const hasSubAnnotations = collectAnnos(collected.elements[elemName], element);
        if (!hasElementAnnotations && !hasSubAnnotations)
          delete collected.elements[elemName]; // delete if no annotations exist
        hasAnnotation = hasAnnotation || hasSubAnnotations;
      });

      if (hasAnnotation)
        annotateObj.elements = collected.elements;

      return hasAnnotation;
    }
  }

  /**
   * Render the source of a query, which may be a path reference, possibly with an alias,
   * or a subselect, or a join operation, as seen from artifact 'art'.
   * Returns the source as a string.
   *
   * @param {object} source
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderViewSource( source, env ) {
    // Sub-SELECT
    if (source.SELECT || source.SET) {
      const subEnv = env.withIncreasedIndent();
      let result = `(\n${subEnv.indent}${renderQuery(source, false, 'view', subEnv)}\n${env.indent})`;
      if (source.as)
        result += renderAlias(source.as, env);

      return result;
    }
    // JOIN
    else if (source.join) {
      // One join operation, possibly with ON-condition
      env.path.push('args', 0);
      let result = `(${renderViewSource(source.args[0], env)}`;
      for (let i = 1; i < source.args.length; i++) {
        env.path[env.path.length - 1] = i;
        result += ` ${source.join} `;
        result += renderJoinCardinality(source.cardinality);
        result += `join ${renderViewSource(source.args[i], env)}`;
      }
      env.path.length -= 2;
      if (source.on) {
        env.path.push('on');
        result += ` on ${exprRenderer.renderExpr(source.on, env.withSubPath([ 'on' ]))}`;
        env.path.length -= 1;
      }
      result += ')';
      return result;
    }
    // Ordinary path, possibly with an alias

    return renderAbsolutePathWithAlias(source, env);
  }

  function renderJoinCardinality( card ) {
    let result = '';
    if (card) {
      if (card.srcmin && card.srcmin === 1)
        result += 'exact ';
      result += card.src && card.src === 1 ? 'one ' : 'many ';
      result += 'to ';
      if (card.min && card.min === 1)
        result += 'exact ';
      if (card.max)
        result += (card.max === 1) ? 'one ' : 'many ';
    }
    return result;
  }

  /**
   * Render a path that starts with an absolute name (as used e.g. for the source of a query),
   * with plain or quoted names, depending on options. Expects an object 'path' that has a 'ref'.
   * Returns the name as a string.
   *
   * @param {object} path
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAbsolutePath( path, env ) {
    // Sanity checks
    if (!path.ref)
      throw new ModelError(`Expecting ref in path: ${JSON.stringify(path)}`);

    // Determine the absolute name of the first artifact on the path (before any associations or element traversals)
    const firstArtifactName = path.ref[0].id || path.ref[0];

    // Render the first path step (absolute name, with different quoting/naming ..)
    let result = renderDefinitionReference(firstArtifactName, env);

    // Even the first step might have parameters and/or a filter
    env.path.push('ref', 0);
    if (path.ref[0].args)
      result += `(${renderArguments(path.ref[0], ':', env)})`;
    if (path.ref[0].where)
      result += renderFilterAndCardinality(path.ref[0], env);
    env.path.length -= 2;

    // Add any path steps (possibly with parameters and filters) that may follow after that
    if (path.ref.length > 1)
      result += `:${exprRenderer.renderExpr({ ref: path.ref.slice(1) }, env)}`;

    return result;
  }

  /**
   * Render a path that starts with an absolute name (as used for the source of a query),
   * possibly with an alias, with plain or quoted names, depending on options. Expects an object 'path' that has a
   * 'ref' and (in case of an alias) an 'as'. If necessary, an artificial alias
   * is created to the original implicit name.
   * Returns the name and alias as a string.
   *
   * @param {object} path
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAbsolutePathWithAlias( path, env ) {
    let result = renderAbsolutePath(path, env);
    if (path.as) {
      // Source had an alias - render it
      result += renderAlias(path.as, env);
    }
    return result;
  }

  /**
   * Render the given columns.
   *
   * @param {CSN.Artifact} art
   * @param {object} elements
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderViewColumns( art, env, elements = Object.create(null) ) {
    env.path.push( 'columns', -1 );
    const result = art.columns.map((col, i) => {
      env.path[env.path.length - 1] = i;
      return renderViewColumn(col, env, findElement(elements, col));
    }).join(',\n');
    env.path.length -= 2;
    return `${result}\n`;
  }

  /**
   * Render a single view or projection column 'col', as it occurs in a select list or
   * projection list within 'art', possibly with annotations.
   * Return the resulting source string (no trailing LF).
   *
   * @param {object} col
   * @param {CdlRenderEnvironment} env
   * @param {CSN.Element} element Element corresponding to the column. Generated by the compiler.
   */
  function renderViewColumn( col, env, element ) {
    // Annotations and column
    let result = '';
    if (!col.doc) {
      // TODO: In contrast to annotations, we do not render the doc comment as part
      //       of an `annotate` statement.  That may change in the future.
      result += renderDocComment(element, env);
    }
    result += renderAnnotationAssignmentsAndDocComment(col, env);
    result += env.indent;

    // only if column is virtual, keyword virtual was present in the source text
    result += col.virtual ? 'virtual ' : '';
    result += col.key ? 'key ' : '';

    // Use special rendering for .expand/.inline - renderExpr cannot easily handle some cases
    if (col.expand || col.inline)
      result += renderInlineExpand(col, env);
    else if (col.xpr && xprContainsCondition(col.xpr))
      result += exprRenderer.renderSubExpr(withoutCast(col), env);
    else
      result += exprRenderer.renderExpr(withoutCast(col), env);

    // Alias for inline/expand is already handled by renderInlineExpand
    // A new association (cast with `type` and `target`) uses `as` as its primary name, not alias.
    const isNewAssociation = col.cast?.type && col.cast.target;
    if (!isNewAssociation && col.as && !col.inline && !col.expand)
      result += renderAlias(col.as, env);

    // Explicit type provided for the view element?
    if (col.cast) {
      env.path.push('cast');
      // Special case: Explicit association type is actually a redirect
      if (col.cast.target && !col.cast.type)
        result += ` : ${renderRedirectedTo(col.cast, env)}`;
      else
        result += ` : ${renderTypeReferenceAndProps(col.cast, env, { typeRefOnly: true, noAnnoCollect: true })}`;
      env.path.length -= 1;
    }
    return result;
  }

  /**
   * For the current column, render a (nested) inline/expand. If the current column
   * does not have an .expand/.inline, '' is returned
   *
   * @param {object} obj Thing with .expand or .inline
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderInlineExpand( obj, env ) {
    // No expression to render for { * } as alias
    let result = (obj.as && obj.expand && !obj.ref) ? '' : exprRenderer.renderExpr(withoutCast(obj), env);

    // s as alias { * }
    if (obj.as && (obj.ref || obj.xpr || obj.val !== undefined || obj.func !== undefined))
      result += renderAlias(obj.as, env);

    // We found a leaf - no further drilling
    if (!obj.inline && !obj.expand) {
      env.path.push('cast');
      if (obj.cast && obj.cast.type)
        result += ` : ${renderTypeReferenceAndProps(obj.cast, env, { noAnnoCollect: true })}`;
      else if (obj.cast && obj.cast.target) // test tbd
        result += ` : ${renderRedirectedTo(obj.cast, env)}`;
      env.path.length -= 1;
      return result;
    }

    if (obj.inline)
      result += '.{\n';
    else
      result += result !== '' ? ' {\n' : '{\n';

    // Drill down and render children of the expand/inline
    const childEnv = env.withIncreasedIndent();
    const expandInline = obj.expand || obj.inline;
    result += expandInline //
      .map(elm => renderAnnotationAssignmentsAndDocComment(elm, childEnv) + childEnv.indent + renderInlineExpand(elm, childEnv))
      .join(',\n');
    result += `\n${env.indent}}`;

    // Don't forget about the .excluding
    if (obj.excluding)
      result += ` excluding { ${obj.excluding.join(',')} }`;

    // { * } as expand
    if (!obj.ref && obj.as)
      result += renderAlias(obj.as, env);

    return result;
  }

  /**
   * Render .doc properties as comments in CDL
   *
   * @param {object} obj Object to render for
   * @param {CdlRenderEnvironment} env
   * @returns {String}
   */
  function renderDocComment( obj, env ) {
    if (!obj || obj && obj.doc === undefined)
      return '';
    else if (obj && obj.doc === null) // empty doc comment needs to be rendered
      return `\n${env.indent}/** */\n`;

    let { doc } = obj;
    if (/[*]\//.test(doc)) // only escape sequence allowed in CDL for doc comments
      doc = doc.replace(/[*]\//g, '*\\/');

    // Smaller comment for single-line comments.  If the comment starts or ends with whitespace
    // we must use a block comment, or it will be lost when compiling the source again.
    if (!obj.doc.includes('\n') && !/(^\s)|(\s$)/.test(obj.doc))
      return `${env.indent}/** ${doc} */\n`;

    const comment = doc.split('\n').map(line => `${env.indent} * ${line}`).join('\n');
    return `${env.indent}/**\n${comment}\n${env.indent} */\n`;
  }

  /**
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function renderView( artifactName, art, env ) {
    const syntax = (art.projection) ? 'projection' : 'entity';
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent}entity ${renderArtifactName(artifactName, env)}`;
    if (art.params)
      result += renderParameters(art, env);
    result += ' as ';
    result += renderQuery(getNormalizedQuery(art).query, true, syntax, env.withSubPath([ art.projection ? 'projection' : 'query' ]), art.elements);
    if (art.actions) // Views/Projections also allow actions. Just the VIEW keyword variant did not.
      result += renderActionsAndFunctions(art, env);
    result += ';\n';
    result += renderQueryElementAndEnumAnnotations(art, env);
    if (art.includes)
      result += renderExtension({ extend: artifactName, includes: art.includes }, env);
    return result;
  }

  /**
   * Render a query 'query', i.e. a select statement with where-condition etc.
   * If 'isLeadingQuery' is true, mixins, actions and functions of 'art' are
   * also rendered into the query. Use 'syntax' style ('projection', 'view',
   * or 'entity')
   *
   * @param {CSN.Query} query
   * @param {boolean} isLeadingQuery
   * @param {string} syntax The query syntax, either "projection", "entity" or "view"
   * @param {CdlRenderEnvironment} env
   * @param {object} [elements]
   */
  function renderQuery( query, isLeadingQuery, syntax, env, elements = query.elements || Object.create(null) ) {
    if (query.SET) {
      // Set operator, such as UNION, INTERSECT, or EXCEPT...
      return renderQuerySet();
    }
    else if (!query.SELECT) {
      // ...otherwise must have a SELECT
      throw new ModelError(`Unexpected query operation ${JSON.stringify(query)}`);
    }

    let result = '';
    const select = query.SELECT;

    // If not a projection, must be view/entity.
    result += (syntax === 'projection') ? 'projection on ' : 'select from ';

    env.path.push('from');
    result += renderViewSource(select.from, env);
    env.path.length -= 1;

    if (select.mixin) {
      let elems = '';
      env.path.push('mixin', '');
      env.increaseIndent();
      forEach(select.mixin, (name, mixin) => {
        env.path[env.path.length - 1] = name;
        elems += renderElement(name, mixin, env);
      });
      env.decreaseIndent();
      env.path.length -= 2;
      if (elems) {
        result += ' mixin {\n';
        result += elems;
        result += `${env.indent}} into`;
      }
    }
    result += select.distinct ? ' distinct' : '';
    if (select.columns) {
      result += ' {\n';
      env.increaseIndent();
      result += renderViewColumns(select, env, elements);
      env.decreaseIndent();
      result += `${env.indent}}`;
    }

    const childEnv = env.withIncreasedIndent();
    if (select.excluding) {
      const excludes = select.excluding.map(id => `${childEnv.indent}${quoteNonIdentifierOrKeyword(id, env)}`).join(',\n');
      result += ` excluding {\n${excludes}\n`;
      result += `${env.indent}}`;
    }

    if (isLeadingQuery && query.actions)
      result += renderActionsAndFunctions(query, env);

    if (select.where)
      result += `${continueIndent(result, env)}where ${exprRenderer.renderExpr(select.where, env.withSubPath([ 'where' ]))}`;

    if (select.groupBy)
      result += `${continueIndent(result, env)}group by ${select.groupBy.map((expr, i) => exprRenderer.renderExpr(expr, env.withSubPath([ 'groupBy', i ]))).join(', ')}`;

    if (select.having)
      result += `${continueIndent(result, env)}having ${exprRenderer.renderExpr(select.having, env.withSubPath([ 'having' ]))}`;

    if (select.orderBy)
      result += `${continueIndent(result, env)}order by ${select.orderBy.map((entry, i) => renderOrderByEntry(entry, env.withSubPath([ 'orderBy', i ]))).join(', ')}`;

    if (select.limit)
      result += `${continueIndent(result, env)}${renderLimit(select.limit, env.withSubPath([ 'limit' ]))}`;

    return result;

    /**
     * Utility function to make sure that we continue with the same indentation in WHERE, GROUP BY, ... after a closing curly brace and beyond
     *
     * @param {string} str
     * @param {CdlRenderEnvironment} indentEnv
     * @return {string}
     */
    function continueIndent( str, indentEnv ) {
      if (str.endsWith('}') || str.endsWith('})')) {
        // The preceding clause ended with '}', just append after that
        return ' ';
      }
      // Otherwise, start new line and indent normally
      return `\n${indentEnv.withIncreasedIndent().indent}`;
    }

    /**
     * Render UNION, INTERSECT, and EXCEPT, i.e. sets.
     *
     * @return {string}
     */
    function renderQuerySet() {
      const subQueries = query.SET.args.map((arg, i) => {
        // First arg may be leading query
        const subEnv = env.withSubPath([ 'SET', 'args', i ]);
        const subQuery = renderQuery(arg, isLeadingQuery && (i === 0), 'view', subEnv, elements);
        return `(${subQuery})`;
      });

      let setResult = subQueries.join(`\n${env.indent}${query.SET.op}${query.SET.all ? ' all' : ''} `);
      // Set operation may also have an ORDER BY and LIMIT/OFFSET (in contrast to the ones belonging to
      // each SELECT)
      if (query.SET.orderBy)
        setResult += `${continueIndent(setResult, env)}order by ${query.SET.orderBy.map((entry, i) => renderOrderByEntry(entry, env.withSubPath([ 'SET', 'orderBy', i ]))).join(', ')}`;

      if (query.SET.limit)
        setResult += `${continueIndent(setResult, env)}${renderLimit(query.SET.limit, env.withSubPath([ 'SET', 'limit' ]))}`;
      return setResult;
    }
  }

  /**
   * Render one entry of a query's ORDER BY clause (which always has a 'value' expression, and may
   * have a 'sort' property for ASC/DESC and a 'nulls' for FIRST/LAST
   *
   * @param {object} entry
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderOrderByEntry( entry, env ) {
    let result = renderAnnotationAssignmentsAndDocComment(entry, env) + exprRenderer.renderExpr(entry, env);
    if (entry.sort)
      result += ` ${entry.sort}`;

    if (entry.nulls)
      result += ` nulls ${entry.nulls}`;

    return result;
  }

  /**
   * Render a query's LIMIT clause, which may also have OFFSET.
   *
   * @param {CSN.QueryLimit} limit
   * @param {CdlRenderEnvironment} limitEnv
   * @return {string}
   */
  function renderLimit( limit, limitEnv ) {
    let limitStr = '';
    if (limit.rows !== undefined)
      limitStr += `limit ${exprRenderer.renderExpr(limit.rows, limitEnv.withSubPath([ 'rows' ]))}`;

    if (limit.offset !== undefined) {
      const offsetIndent = (limitStr === '') ? '' : `\n${limitEnv.withIncreasedIndent().indent}`;
      limitStr += `${offsetIndent}offset ${exprRenderer.renderExpr(limit.offset, limitEnv.withSubPath([ 'offset' ]))}`;
    }
    return limitStr;
  }

  /**
   * Render an entity's actions and functions (if any)
   * (expect an entity with trailing '}' or an 'extend' statement ending with 'with'
   * to have just been rendered).
   * Return the resulting source string.
   *
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderActionsAndFunctions( art, env ) {
    let result = '';
    if (art.actions) {
      const childEnv = env.withIncreasedIndent();
      for (const name in art.actions)
        result += renderActionOrFunction(name, art.actions[name], childEnv.withSubPath([ 'actions', name ]));
      result = (result === '')
        ? ' actions { }'
        : ` actions {\n${result}${env.indent}}`;
    }
    return result;
  }

  /**
   * Render an action or function 'act' with name 'actName'. Return the resulting source string.
   *
   * @param {string} actionName
   * @param {CSN.Action} act
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderActionOrFunction( actionName, act, env ) {
    let result = renderAnnotationAssignmentsAndDocComment(act, env) + env.indent + act.kind;
    result += ` ${renderArtifactName(actionName, env)}`;
    result += renderParameters(act, env);
    if (act.returns) {
      let actEnv = env.withSubPath([ 'returns' ]);
      const annos = renderAnnotationAssignmentsAndDocComment(act.returns, actEnv.withIncreasedIndent());
      if (annos) // if `returns` has annotations, increase indent for nicer aligned output
        actEnv = actEnv.withIncreasedIndent();
      const type = renderTypeReferenceAndProps(act.returns, actEnv);
      result += ` returns${annos ? '\n' : ' '}${annos}${annos ? actEnv.indent : ''}${type}`;
    }

    result += ';\n';
    return result;
  }

  /**
   * Render art.params, i.e. list of parameter in parentheses.  If there is only one
   * parameter, a single line is used, otherwise an indented list is used.
   * If there are no params, an empty list `()` is returned.
   *
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderParameters( art, env ) {
    const childEnv = env.withIncreasedIndent();
    const parameters = Object.keys(art.params || {}).map(name => renderParameter(name, art.params[name], childEnv));
    if (parameters.length === 0)
      return '()';
    return `(\n${parameters.join(',\n')}\n${env.indent})`;
  }

  /**
   * Render an action or function parameter 'par' with name 'parName'. Return the resulting source string (no trailing LF).
   *
   * @param {string} parName
   * @param {object} par
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderParameter( parName, par, env ) {
    env = env.withSubPath( [ 'params', parName ]);
    let result = `${renderAnnotationAssignmentsAndDocComment(par, env)}${env.indent}`;
    result += `${quoteNonIdentifierOrKeyword(parName, env)} : ${renderTypeReferenceAndProps(par, env)}`;
    return result;
  }

  /**
   * Render a type (derived or structured) or an annotation decl with name 'artifactName'.
   * Return the resulting source string.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @param {String} [artType] Used for rendering `csn.vocabularies`, as the annotations there do not have a kind.
   * @return {string}
   */
  function renderTypeOrAnnotation( artifactName, art, env, artType ) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent + (artType || art.$syntax || art.kind )} ${renderArtifactName(artifactName, env)}`;

    const type = renderTypeReferenceAndProps(art, env);
    const isDirectStruct = type?.startsWith('{');
    if (art.includes?.length && isDirectStruct)
      // We can only render includes, if the type is directly structured. Otherwise,  we would
      // render e.g. `type T : Include : T2;`, which is invalid.  We use `extend` in such cases.
      result += renderIncludes(art.includes, env);

    if (type) {
      // For nicer output, no colon if unnamed structure is used.
      result += (!art.type && art.elements) ? ` ${type}` : ` : ${type}`;
    }
    else {
      msg.warning('syntax-missing-type', env.path, { name: artifactName },
                  'Missing type for definition $(NAME); can\'t be represented in CDL');
    }

    result += ';\n';

    if (art.includes?.length && !isDirectStruct) {
      // If we're not a directly structured type, render the `includes` as `extend`
      // statements directly below the type definition.
      result += renderExtendStatement(artifactName, { includes: art.includes }, env);
    }

    return result;
  }

  /**
   * Render a reference to a type used by 'artifact' (named or inline) and (element) properties
   * such as `not null` and `default <xpr>`.
   * Allow suppressing rendering of structs such as enums - used in columns for example.
   *
   * @param {CSN.Artifact} artifact
   * @param {CdlRenderEnvironment} env
   * @param {object} [config={}]
   * @param {boolean} [config.typeRefOnly] Whether to only render type defs, no arrayed/structured/enum.
   * @param {boolean} [config.noAnnoCollect] Do not collect annotations of sub-elements.
   * @return {string}
   */
  function renderTypeReferenceAndProps( artifact, env, config = {} ) {
    let result = '';
    const { typeRefOnly, noAnnoCollect } = config;

    if (typeRefOnly && !artifact.type)
      throw new ModelError(`Expected artifact to have a type; in: ${JSON.stringify(env.path)}`);

    if (artifact.localized) // works even for type definitions
      result += 'localized ';

    if (!artifact.type && artifact.items) {
      checkArrayedArtifact(artifact, env);
      result += 'many '; // alternative: 'array of'; but not used
      artifact = artifact.items;
      env = env.withSubPath([ 'items' ]);
    }

    const type = normalizeTypeRef(artifact.type);

    if (!type && artifact.elements) {
      result += renderElements(artifact, env);
      result += renderNullability(artifact);
      // structured default not possible at the moment
      return result;
    }

    // Association type
    if (isDirectAssocOrComp(type)) {
      const isComp = type === 'cds.Composition';
      // Type, cardinality and target; CAPire uses CamelCase
      result += isComp ? 'Composition' : 'Association';
      result += renderCardinality(artifact);

      // `targetAspect` may be set by the core compiler and refers to the original named or unnamed aspect.
      // In parseCdl, `target` may still be an object containing elements.  This would be replaced
      // by targetAspect in client CSN, but we can't rely on that.
      // If a name exists (either in target or targetAspect), prefer it over rendering elements.
      const elements = artifact.target?.elements || artifact.targetAspect?.elements;
      if (typeof artifact.target === 'string' || typeof artifact.targetAspect === 'string') {
        result += renderAbsolutePath({ ref: [ artifact.target || artifact.targetAspect ] }, env);
      }
      else if (elements) {
        // anonymous aspect, either parseCdl or client CSN.
        result += renderElements({ elements }, env.withSubPath([ artifact.target?.elements ? 'target' : 'targetAspect' ]));
      }
      else {
        throw new ModelError('Association/Composition is missing its target! Throwing exception to trigger recompilation.');
      }

      // ON-condition (if any)
      if (artifact.on)
        result += ` on ${exprRenderer.renderExpr(artifact.on, env.withSubPath([ 'on' ]))}`;

      // Foreign keys (if any, unless we also have an ON_condition (which means we have been transformed from managed to unmanaged)
      if (artifact.keys && !artifact.on)
        result += ` ${ renderForeignKeys(artifact, env) }`;

      if (artifact.notNull !== undefined && !artifact.on) // unmanaged associations can't be followed by "not null"
        result += renderNullability(artifact);

      if (artifact.default && !artifact.on)
        result += renderDefaultExpr(artifact, env);
      return result;
    }

    // At this point, we will render a named type.

    // If we have a type and elements, we may have sub-structure annotates that would
    // get lost if we only render the type name.
    // We only extract annotations of enums, if "typeRefOnly" is true.  Otherwise, since
    // the full enum is rendered below, we would have unnecessary annotations.
    if (!noAnnoCollect && (!artifact.enum || typeRefOnly)) {
      const annotate = collectAnnotationsOfElementsAndEnum(artifact, env);
      if (annotate)
        subelementAnnotates.push(annotate);
    }

    // Reference to another artifact
    if (typeof type === 'string') {
      // If we get here, it must be a named type
      result += renderNamedTypeWithParameters(artifact, env);
    }
    else if (type?.ref) {
      result += renderAbsolutePath(artifact.type, env);
    }

    if (artifact.enum && !typeRefOnly)
      result += renderEnum(artifact.enum, env);
    if (artifact.notNull !== undefined)
      result += renderNullability(artifact);

    // If there is a default value, and it's a calculated element, do not
    // render the default (because it's not supported for calc elements).
    if (artifact.default !== undefined && !artifact.value)
      result += renderDefaultExpr(artifact, env);

    return result;
  }

  /**
   * Render REDIRECTED TO with its keys/on condition for the given artifact.
   *
   * @param {object} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderRedirectedTo( art, env ) {
    let result = `redirected to ${renderDefinitionReference(art.target, env)}`;
    if (art.on)
      result += ` on ${exprRenderer.renderExpr(art.on, env.withSubPath([ 'on' ]))}`;
    else if (art.keys)
      result += ` ${ renderForeignKeys(art, env) }`;
    return result;
  }

  /**
   * Render the named type with optional parameters, e.g. `MyString(length: 10)`.
   *
   * @param {CSN.Artifact} artWithType
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderNamedTypeWithParameters( artWithType, env ) {
    const type = normalizeTypeRef(artWithType.type);
    let result = '';

    if (isBuiltinType(type)) {
      // If there is a user-defined type that starts with the same short name
      // (cds.Integer -> Integer), we render the full name, including the leading "cds."
      const shortHand = type.slice(4);
      if (shortHand.startsWith('hana.') && hanaRequiresAbsolutePath)
        result += type;
      else if (usings.available.includes(shortHand))
        result += type;
      else
        result += shortHand;
    }
    else {
      result += renderDefinitionReference(type, env);
    }

    result += renderTypeParameters(artWithType);
    return result;
  }


  /**
   * Render the 'enum { ... } part of a type declaration
   *
   * @param {CSN.EnumList} enumPart
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderEnum( enumPart, env ) {
    let result = ' enum {\n';
    const childEnv = env.withIncreasedIndent();
    for (const name in enumPart)
      result += renderElement(name, enumPart[name], childEnv.withSubPath([ 'enum', name ]));
    result += `${env.indent}}`;
    return result;
  }

  /**
   * Render an annotation value, which is either
   *  - a normal expressions
   *  - a somewhat simplified expression, with slightly different representation
   *
   * @param {any} annoValue
   * @param {CdlRenderEnvironment} env
   */
  function renderAnnotationValue( annoValue, env ) {
    if (isAnnotationExpression(annoValue)) {
      // Once inside an expression, we stay there.
      const xpr = exprRenderer.renderExpr(annoValue, env);
      return `( ${xpr} )`;
    }
    else if (Array.isArray(annoValue)) {
      return renderAnnotationArrayValue( annoValue, env );
    }
    else if (typeof annoValue === 'object' && annoValue !== null) {
      // Enum symbol
      if (annoValue['#'] !== undefined) {
        return `#${annoValue['#']}`;
      }
      // Shorthand for absolute path (as string)
      else if (annoValue['='] !== undefined) {
        if (annoValue['='].startsWith('@'))
          return quoteAnnotationPathIfRequired(annoValue['='], env);
        return quotePathIfRequired(annoValue['='], env);
      }
      // Shorthand for ellipsis: `... up to <val>`
      else if (annoValue['...'] !== undefined) {
        if (annoValue['...'] === true)
          return '...';
        return `... up to ${renderAnnotationValue(annoValue['...'], env)}`;
      }

      // Struct value (can currently only occur within an array)
      // Render as one-liner if there is at most one key.  Render as multi-line
      // struct if there are more and use nicer indentation.
      const keys = Object.keys(annoValue);
      const childEnv = keys.length <= 1 ? env : env.withIncreasedIndent();
      const values = keys.map(key => `${quoteAnnotationPathIfRequired(key, env)}: ${renderAnnotationValue(annoValue[key], childEnv.withSubPath([ key ]))}`);
      if (values.length <= 1)
        return `{ ${values.join(', ')} }`;
      const valueList = values.join(`,\n${childEnv.indent}`);
      return `{\n${childEnv.indent}${valueList}\n${env.indent}}`;
    }
    // Null
    else if (annoValue === null) {
      return 'null';
    }
    // Primitive: string, number, boolean

    // Quote strings, leave all others as they are
    return (typeof annoValue === 'string') ? renderString(annoValue, env) : String(annoValue);
  }

  /**
   * Renders an array annotation value.  Uses a heuristic to put each element on its own line
   * if a single-line becomes longer than 100 characters or if any sub-expression already
   * contains a line break.  The latter checks makes nested arrays with structures more
   * readable.
   *
   * @param {any[]} annoValue
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotationArrayValue( annoValue, env ) {
    const childEnv = env.withIncreasedIndent();
    // Render array parts as values.
    let length = 0;
    let hasLineBreak = false;
    const items = annoValue.map((item, i) => {
      const result = renderAnnotationValue(item, childEnv.withSubPath([ i ]));
      length += result.length + 2; // just a heuristic; add 2 for `, `.
      if (!hasLineBreak && result.includes('\n'))
        hasLineBreak = true;
      return result;
    });

    if (!hasLineBreak && (length + env.indent.length) < 100) {
      // Spaces required if last array value is a delimited identifier.
      return `[ ${items.join(', ')} ]`;
    }
    const renderedItems = items.join(`,\n${childEnv.indent}`);
    return `[\n${childEnv.indent}${renderedItems}\n${env.indent}]`;
  }

  /**
   * Render a single path step 's' at path position 'idx', which can have filters or parameters or be a function
   *
   * @param {string|object} s
   * @param {number} idx
   * @param {object} env
   * @returns {string}
   */
  function renderPathStep( s, idx, env ) {
    // Simple id or absolute name
    if (typeof s === 'string') {
      // In first path position, do not quote $projection and magic $-variables like CURRENT_DATE, $now etc.
      // FIXME: We should rather explicitly recognize quoting somehow
      if (idx === 0 && s.startsWith('$'))
        return s;
      return quoteNonIdentifierOrKeyword(s, env);
    }
    // ID with filters or parameters
    else if (typeof s === 'object') {
      // Sanity check
      if (!s.func && !s.id)
        throw new ModelError(`Unknown path step object: ${JSON.stringify(s)}`);

      // Not really a path step but an object-like function call
      if (s.func)
        return `${s.func}(${renderArguments(s, '=>', env)})`;

      // Path step, possibly with view parameters and/or filters
      let result = `${quoteNonIdentifierOrKeyword(s.id, env)}`;
      if (s.args) {
        // View parameters
        result += `(${renderArguments(s, ':', env)})`;
      }

      result += renderFilterAndCardinality(s, env);

      return result;
    }

    throw new ModelError(`Unknown path step: ${JSON.stringify(s)}`);
  }

  /**
   * Render function arguments or view parameters (positional if array, named if object/dict),
   * using 'sep' as separator for named parameters
   *
   * @param {object} node with `args` to render
   * @param {string} sep
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderArguments( node, sep, env ) {
    if (!node.args)
      return '';
    else if (Array.isArray(node.args))
      return renderPositionalArguments(node, env);
    else if (typeof node.args === 'object')
      return renderNamedArguments(node, sep, env);
    throw new ModelError(`Unknown args: ${JSON.stringify(node.args)}; expected array/object`);
  }

  /**
   * Render named function arguments or view parameters,
   * using 'sep' as separator.
   *
   * @param {object} node with `args` to render
   * @param {string} separator
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderNamedArguments( node, separator, env ) {
    return Object.keys(node.args).map(function renderNamedArgument(key) {
      return `${quoteNonIdentifierOrKeyword(key, env)} ${separator} ${renderArgument(node.args[key], env.withSubPath([ 'args', key ]))}`;
    }).join(', ');
  }

  /**
   * Render a comma separated list of positional function arguments.
   *
   * @param {object} node with `args` to render
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderPositionalArguments( node, env ) {
    if (!node.args)
      return '';
    const func = node.func?.toUpperCase();
    if (func) {
      return node.args.map(function renderFunctionArg(arg, i) {
        return renderArgument(arg, env.withSubPath([ 'args', i ]), getKeywordsForSpecialFunctionArgument(func, i));
      }).join(', ');
    }
    return node.args.map((arg, i) => renderArgument(arg, env.withSubPath([ 'args', i ]))).join(', ');
  }

  /**
   * Render a function argument, e.g. for generic functions or CAST().
   * Ensures that parentheses are used if necessary, e.g. for `someFct( (1=1), (1=1) )`.
   *
   * @param {any} arg
   * @param {CdlRenderEnvironment} env
   * @param {string[]} additionalKeywords
   * @return {string}
   */
  function renderArgument( arg, env, additionalKeywords = [] ) {
    // If the argument is a xpr with e.g. `=`, it may require parentheses.
    // For nested xpr, `exprRenderer.renderExpr()` will already add parentheses.
    env = env.cloneWith({ additionalKeywords });
    if (isSimpleFunctionExpression(arg && arg.xpr, additionalKeywords))
      return exprRenderer.renderExpr(arg, env);
    return exprRenderer.renderSubExpr(arg, env);
  }

  /**
   * Render an artifact's cardinality.
   *
   * @param artifact
   * @returns {string}
   */
  function renderCardinality( artifact ) {
    if (isSimpleCardinality(artifact.cardinality))
      return renderSimpleCardinality(artifact);
    return renderBracketCardinality(artifact);
  }

  /**
   * Render a cardinality (only those parts that were actually provided)
   *
   * @param {CSN.Artifact} art
   * @return {string}
   */
  function renderBracketCardinality( art ) {
    const isComp = normalizeTypeRef(art.type) === 'cds.Composition';
    const suffix = (isComp ? ' of ' : ' to ');
    const card = art.cardinality;

    if (!card)
      return suffix;

    let result = '[';
    if (card.src !== undefined)
      result += `${card.src}, `;
    if (card.min !== undefined)
      result += `${card.min}..`;
    if (card.max !== undefined)
      result += card.max;
    // srcmin can't be represented in CDL
    return `${result}]${suffix}`;
  }

  /**
   * A "simple" cardinality is one that only has a "max" cardinality property
   * which is either '*' or 1.
   *
   * @param {CSN.Cardinality} cardinality
   * @return {boolean}
   */
  function isSimpleCardinality( cardinality ) {
    return !cardinality || (
      cardinality.min === undefined &&
      cardinality.src === undefined &&
      cardinality.srcmin === undefined &&
      (cardinality.max === '*' || cardinality.max === 1)
    );
  }

  /**
   * Renders the simple cardinality of an association/composition, i.e. "many"/"one",
   * including the "of"/"to" part.
   *
   * @param {CSN.Element} elem
   * @return {string}
   */
  function renderSimpleCardinality( elem ) {
    let result = (normalizeTypeRef(elem.type) === 'cds.Association' ? ' to ' : ' of ');
    if (!elem.cardinality)
      return result;
    if (elem.cardinality.max === '*')
      result += 'many ';
    else if (elem.cardinality.max === 1)
      result += 'one ';
    return result;
  }


  function renderFilterAndCardinality( s, env ) {
    let result = '';
    const cardinality = s.cardinality ? (`${s.cardinality.max}: `) : '';
    let filter = '';

    // TODO: Unify with other filter rendering for SELECT
    if (s.groupBy)
      filter += ` group by ${s.groupBy.map((expr, i) => exprRenderer.renderExpr(expr, env.withSubPath([ 'groupBy', i ]))).join(', ')}`;
    if (s.having)
      filter += ` having ${exprRenderer.renderExpr(s.having, env.withSubPath([ 'having' ]))}`;
    if (s.orderBy)
      filter += ` order by ${s.orderBy.map((entry, i) => renderOrderByEntry(entry, env.withSubPath([ 'orderBy', i ]))).join(', ')}`;
    if (s.limit)
      filter += ` ${renderLimit(s.limit, env.withSubPath([ 'limit' ]))}`;

    if (s.where) {
      let where = exprRenderer.renderExpr(s.where, env.withSubPath([ 'where' ]));
      // Special rules in CDS parser: If filter starts with one of these SQL keywords, WHERE is mandatory.
      if (filter || /^(?:group|having|order|limit)\s/i.test(where))
        where = ` where ${where}`;
      filter = `${where} ${filter}`;
    }

    filter = filter.trim();

    if (cardinality || filter) {
      if (filter.endsWith(']')) // for cases such as [… ![id] ]
        result += `[ ${cardinality}${filter} ]`;
      else
        result += `[${cardinality}${filter}]`;
    }
    return result;
  }

  function renderDefaultExpr( art, env ) {
    if (!art.default)
      return '';
    let result = ' default ';
    if ( art.default.xpr && xprContainsCondition( art.default.xpr))
      result += exprRenderer.renderSubExpr(withoutCast( art.default), env.withSubPath([ 'default' ]));
    else
      result += exprRenderer.renderExpr(withoutCast( art.default), env.withSubPath([ 'default' ]));
    return result;
  }

  // Render the nullability of an element or parameter (can be unset, true, or false)
  function renderNullability( obj /* , env */) {
    if (obj.notNull === undefined) {
      // Attribute not set at all
      return '';
    }
    return obj.notNull ? ' not null' : ' null';
  }

  /**
   * Render foreign keys.
   *
   * @param {object} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderForeignKeys( art, env ) {
    const renderedKeys = [];
    let hasAnnotations = false;
    env = env.withSubPath([ 'keys', -1 ]);
    env.increaseIndent();

    for (let i = 0; i < art.keys.length; ++i) {
      env.path[env.path.length - 1] = i;
      const fKey = art.keys[i];

      const annos = renderAnnotationAssignmentsAndDocComment(fKey, env).trim();
      if (annos) {
        hasAnnotations = true;
        renderedKeys.push(annos);
      }

      const alias = fKey.as ? renderAlias(fKey.as, env) : '';
      const key = exprRenderer.renderExpr(fKey, env);
      renderedKeys.push(`${key}${alias},`);
    }

    if (hasAnnotations) {
      const sep = `\n${env.indent}`;
      env.decreaseIndent();
      return `{${sep}${renderedKeys.join(sep)}\n${env.indent}}`;
    }

    let result = renderedKeys.join(' ');
    if (result[result.length - 1] === ',') // remove trailing comma
      result = result.slice(0, -1);
    return `{ ${ result } }`;
  }

  /**
   * Render an explicit alias, e.g. for columns.
   *
   * @param {string} alias
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAlias( alias, env ) {
    return ` as ${quoteNonIdentifierOrKeyword(alias, env)}`;
  }

  /**
   * Render (primitive) type parameters of artifact 'artWithType', i.e.
   * length, precision and scale (even if incomplete), plus any other unknown ones.
   *
   * @param {CSN.Artifact} artWithType
   * @param {boolean} noShortVersion If true, parameters will not be shortened, e.g. `(10)`
   *                                 for length instead of `(length: 10)`.
   * @returns {string}
   */
  function renderTypeParameters( artWithType, noShortVersion = false ) {
    const params = typeParameters.list.filter(param => artWithType[param] !== undefined);
    if (params.length === 0)
      return '';

    if (!noShortVersion) {
    // Special cases for 1 or 2 arguments.
      if (params.length === 1 && artWithType.length !== undefined)
        return `(${artWithType.length})`;
      if (params.length === 2 && artWithType.precision !== undefined && artWithType.scale !== undefined)
        return `(${artWithType.precision}, ${artWithType.scale})`;
    }

    // Render named params
    const renderedParams = [];
    for (const param of params)
      renderedParams.push(`${param}: ${artWithType[param]}`);

    return `(${renderedParams.join(', ')})`;
  }

  /**
   * Render all annotation assignments of annotatable object 'obj'.
   *
   * @param {object} obj Object that has annotations
   * @param {CdlRenderEnvironment} env
   * @param {{parentheses: boolean}} [config] Config for renderAnnotationAssignment()
   * @return {string}
   */
  function renderAnnotationAssignmentsAndDocComment( obj, env, config ) {
    let result = renderDocComment(obj, env);
    for (const name in obj) {
      if (name.startsWith('@'))
        result += renderAnnotationAssignment(obj[name], name, env.withSubPath([ name ]), config);
    }
    return result;
  }

  /**
   * Render a single annotation assignment 'anno' with fully qualified name 'name' (no trailing LF).
   * We might see variants like 'A.B.C#foo' or even 'A.B#foo.C'. The latter needs to be quoted as
   * dots in the variant are not recognized by the compiler.
   *
   * @param {any} anno Annotation value
   * @param {string} name Annotation name, e.g. `@A.B.C#foo.C`
   * @param {CdlRenderEnvironment} env
   * @param {object} [config] parentheses: Whether the annotation assignment must be surrounded by parentheses.
   * @return {string} Rendered annotation, possibly quoted: `@![A.B.C#foo.C]: value`
   */
  function renderAnnotationAssignment( anno, name, env, config = { parentheses: false } ) {
    name = name.substring(1);
    // Take the annotation assignment apart into <nameBeforeVariant>#<variantAndRest>
    const parts = name.split('#');
    let nameBeforeVariant = parts[0];
    const variant = parts.length > 1 ? parts.slice(1).join('#') : undefined;
    const { parentheses } = config;

    let result = `${env.indent}@`;
    if (parentheses)
      result += '(';

    // if the variant is empty, render '#' as part of the name, e.g `variant !== undefined`.
    if (variant === '')
      nameBeforeVariant += '#';

    result += quoteAnnotationPathIfRequired(nameBeforeVariant, env);

    if (variant !== undefined && variant !== '') {
      // Unfortunately, the compiler does not allow `.@` after the first variant identifier,
      // nor multiple `#`, so we're back at simple paths that are possibly quoted.
      result += `#${quotePathIfRequired(variant, env)}`;
    }
    result += ` : ${renderAnnotationValue(anno, env)}`;

    if (parentheses)
      result += ')';
    return `${result}\n`;
  }

  /**
   * Render the name of an artifact, quote path steps if necessary.
   *
   * @param {string} artifactName Artifact name to render
   * @param {CdlRenderEnvironment} env
   * @return {string} Artifact name ready for rendering
   */
  function renderArtifactName( artifactName, env ) {
    return quotePathIfRequired(artifactName, env);
  }

  /**
   * Render the name of a definition.  Ensures the first segment of the name
   * is available in the rendered CDL.  Otherwise, a USING is added.
   *
   * @param {string} name
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderDefinitionReference( name, env ) {
    usings.addIfRequired(name);
    return quotePathIfRequired(name, env);
  }

  /**
   * @param {string[]} includes
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderIncludes( includes, env ) {
    return ` : ${includes.map((name, i) => renderDefinitionReference(name, env.withSubPath([ 'includes', i ]))).join(', ')}`;
  }

  function createCdlExpressionRenderer() {
    return createExpressionRenderer({
      finalize: x => x,
      typeCast(x) {
        const typeRef = renderTypeReferenceAndProps(x.cast, this.env.withSubPath([ 'cast' ]), { typeRefOnly: true, noAnnoCollect: true });
        const arg = { ...x, cast: null }; // "arg" without cast to avoid recursion.
        return `cast(${renderArgument(arg, this.env)} as ${typeRef})`;
      },
      val(x) {
        // Literal value, possibly with explicit 'literal' property
        switch (x.literal || typeof x.val) {
          case 'number':
          case 'boolean':
          case 'null':
            return x.val;
          case 'x':
          case 'date':
          case 'time':
          case 'timestamp':
            return `${x.literal}'${x.val}'`;
          case 'string':
            return renderString(x.val, this.env);
          case 'object':
            if (x.val === null)
              return 'null';
            // otherwise fall through to
          default:
            throw new ModelError(`Unknown literal or type: ${JSON.stringify(x)}`);
        }
      },
      aliasOnly: x => x.as,
      enum: x => `#${x['#']}`,
      ref(x) {
        return `${x.param ? ':' : ''}${x.ref.map((step, index) => renderPathStep(step, index, this.env.withSubPath([ 'ref', index ]))).join('.')}`;
      },
      windowFunction(x) {
        const funcDef = this.func(x);
        return `${funcDef} ${this.renderExpr(x.xpr, this.env.withSubPath([ 'xpr' ]))}`; // xpr[0] is 'over'
      },
      func(x) {
        if (keywords.cdl_functions.includes(x.func.toUpperCase()) && !x.args)
          return x.func;
        const name = quoteFunctionIfRequired(x.func, this.env);
        if (!x.args) // e.g. for methods without arguments, `args` is not set at all.
          return `${name}`;
        return `${name}(${renderArguments( x, '=>', this.env )})`;
      },
      xpr(x) {
        const xprEnv = this.env.withSubPath([ 'xpr' ]);
        if (this.isNestedXpr && !x.cast)
          return `(${this.renderExpr(x.xpr, xprEnv)})`;
        return this.renderExpr(x.xpr, xprEnv);
      },
      // Sub-queries in expressions need to be in parentheses, otherwise
      // left-associativity of UNIONS may result in different results.
      // For example: `select from E where id in (select from E union select from E);`:
      // Without parentheses, it would be different query.
      SET(x) {
        return `(${renderQuery(x, false, 'view', this.env.withIncreasedIndent())})`;
      },
      SELECT(x) {
        return `(${renderQuery(x, false, 'view', this.env.withIncreasedIndent())})`;
      },
    });
  }

  // checks -------------------------------------------------------------------
  // The CDL backend has very few checks, but we need to tell the user if
  // something can't be rendered.

  /**
   * If an artifact is an array via `.items`, some properties on `art` can't be rendered,
   * for example "not null", because there is no CDL representation for it.  Only "not null"
   * on `.items` can be rendered.
   *
   * Furthermore, to.cdl() can only render one nesting level of `items`.  `items` inside
   *  `items, etc. can't be represented in CDL, hence can't be rendered.
   *
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function checkArrayedArtifact( art, env ) {
    if (!art.items)
      return;
    if (art.notNull !== undefined) {
      msg.warning('def-unexpected-nullability', env.path, { prop: 'not null', otherprop: 'items' },
                  'Property $(PROP) not rendered, because it can only be rendered inside $(OTHERPROP) for arrayed artifacts');
    }

    if (art.items.items && !art.items.type)
      msg.message('type-invalid-items', [ ...env.path, 'items' ], { '#': 'nested', prop: 'items' } );

    const type = art.items.type && normalizeTypeRef(art.items.type);
    if (type === 'cds.Association' || type === 'cds.Composition') {
      // check for `art.items.target` not sufficient; could be indirect type reference
      const isComp = type === 'cds.Composition';
      msg.message('type-invalid-items', [ ...env.path, 'items' ], { '#': isComp ? 'comp' : 'assoc', prop: 'items' });
    }
  }

  /**
   * Quote simple path steps with `![]` if necessary. For simple ids such as
   * `elem` use `quoteNonIdentifierOrKeyword` instead.
   *
   * In contrast to quoteNonIdentifierOrKeyword, does not handle additional keywords,
   * because it was not required, yet.
   *
   * Due to token rewrite, all keywords after a dot (`.`) are rewritten to
   * identifiers, i.e. we only need to check for the identifier RegEx.
   *
   * @param {string} path
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function quotePathIfRequired( path, env ) {
    return path.split('.').map((step, index) => {
      if (index === 0)
        return quoteNonIdentifierOrKeyword(step, env);
      else if (!identifierRegex.test(step))
        return delimitedId(step, env);
      return step;
    }).join('.');
  }

  /**
   * Quote the id with `![]` if necessary. For paths such as `E.key` use
   * `quotePathIfRequired` instead.
   * See quoteNonIdentifier() if you want to ignore keywords.
   *
   * Set env.additionalKeywords to an array of UPPERCASE keywords
   * that also need quoting, e.g. in special functions.
   *
   * @param {string} id
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function quoteNonIdentifierOrKeyword( id, env ) {
    // Quote if required for CDL
    if (requiresQuotingForCdl(id, env?.additionalKeywords || []))
      return delimitedId(id, env);
    return id;
  }

  /**
   * Quote the id with `![]` if necessary. For paths such as `E.key` use
   * `quotePathIfRequired` instead.
   * See quoteNonIdentifierOrKeyword() if you want to quote identifiers
   * that are keywords as well.
   *
   * Does not quote the given id if it is a keyword.
   *
   * @param {string} id
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function quoteNonIdentifier( id, env ) {
    if (!identifierRegex.test(id))
      return delimitedId(id, env);
    return id;
  }

  /**
   * Quote the given function name if required.
   *
   * @param {string} funcName
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function quoteFunctionIfRequired( funcName, env ) {
    if (cdlNewLineRegEx.test(funcName)) {
      msg.error('name-invalid-identifier', env.path, {},
                'An identifier can\'t contain newline characters in CDL');
    }
    return apiSmartFunctionId(funcName);
  }

  /**
   * Quote an annotation path, e.g. `@My.@Anno.Description` if necessary.
   * `anno` can start with `@` but is not required to be.
   * Example of an annotation path that needs to be quoted:
   * `@![ spaces in path ].@!["double quotes"]`.
   *
   * @param {string} anno
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function quoteAnnotationPathIfRequired( anno, env ) {
    return anno.split('.').map((segment) => {
      if (segment.startsWith('@'))
        return `@${quoteNonIdentifier(segment.slice(1), env)}`;
      return quoteNonIdentifier(segment, env);
    }).join('.');
  }

  /**
   * The same as the exported function apiDelimitedId, but checks that we can actually represent the
   * string: newline characters are not allowed.
   *
   * @param {string} id
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function delimitedId( id, env ) {
    if (cdlNewLineRegEx.test(id)) {
      msg.error('name-invalid-identifier', env.path, {},
                'An identifier can\'t contain newline characters in CDL');
    }
    return apiDelimitedId(id);
  }
}

class CdlRenderEnvironment {
  indent = '';
  path = null;
  elementName = null;
  additionalKeywords = [];

  constructor(values) {
    Object.assign(this, values);
  }

  increaseIndent() {
    this.indent = `  ${this.indent}`;
  }
  decreaseIndent() {
    this.indent = this.indent.substring(0, this.indent.length - 2);
  }
  withIncreasedIndent() {
    return new CdlRenderEnvironment({ ...this, indent: `  ${this.indent}` });
  }
  withSubPath(path) {
    return new CdlRenderEnvironment({ ...this, path: [ ...this.path, ...path ] });
  }
  cloneWith(values) {
    return Object.assign(new CdlRenderEnvironment(this), values);
  }
}


/**
 * Returns a newly created default environment (which keeps track of indentation, required USING
 * declarations and name prefixes.
 *
 * @param {object} [values]
 * @return {CdlRenderEnvironment}
 */
function createEnv( values = {} ) {
  return new CdlRenderEnvironment( values );
}

/**
 * Remove a trailing `\n`/newline/LF from `str` and return the modified string.
 * Useful if you want to append a `;` to the string, but not on a separate line.
 *
 * @param {string} str
 * @return {string}
 */
function removeTrailingNewline( str ) {
  if (str[str.length - 1] === '\n')
    str = str.substring(0, str.length - 1);
  return str;
}

/**
 * Returns true if 'id' requires quotes for CDL, i.e. if 'id'
 * does not match the first part of the `Identifier` rule of `language.g4`
 * or if 'id' is a reserved keyword.
 *
 * Set additionalKeywords to an array of UPPERCASE keywords
 * that also need quoting, e.g. in special functions.
 *
 * @param {string} id
 * @param {string[]} [additionalKeywords]
 * @return {boolean}
 */
function requiresQuotingForCdl( id, additionalKeywords ) {
  return !identifierRegex.test(id) ||
    keywords.cdl.includes(id.toUpperCase()) ||
    keywords.cdl_functions.includes(id.toUpperCase()) ||
    additionalKeywords.includes(id.toUpperCase());
}

/**
 * Returns true if the given type is an association or composition,
 * without type indirection.
 *
 * @param {string|string[]} type
 * @return {boolean}
 */

function isDirectAssocOrComp( type ) {
  type = normalizeTypeRef(type);
  return (type === 'cds.Association' || type === 'cds.Composition');
}

const conditionOperators = [
  // Antlr rule 'condition', 'conditionAnd'
  'AND', 'OR',

  // Antlr rule 'conditionTerm'
  '=', '<>', '>', '>=', '<', '<=', '!=',
  // These are not forbidden, since they must be preceded by one of the comparators above.
  // 'any', 'some', 'all',

  'IS', 'IN', 'NOT', 'NULL', 'EXISTS',
  // Antlr rule 'predicate'
  'BETWEEN', 'LIKE', 'ESCAPE',
];

/**
 * Returns true if the given xpr-array can be rendered without parentheses
 * in a `fct(<xpr>)` expression such as `cast(<xpr> as Type)`.  We only need to
 * look at the first nesting level.  Otherwise, `renderExpr()` will already add parentheses.
 *
 * The list of `conditionOperators` was created by looking at the `expression` Antlr rule.
 * Because of token-rewrites, there are functions that allow operators/tokens that would
 * require parentheses in other functions.  For example *regex functions allow `IN` but
 * if `IN` is used in other functions, it requires parentheses.  To allow for that case,
 * you can set `additionalAllowedKeywords` to list of tokens that are allowed.
 *
 * Note that this is more of a heuristic for "nicer" CDL output.  For example the
 * following snippet is parsable without parentheses:
 *   `cast( case when int > 1 then int else 0 end as Integer ),`
 * However, because it is a flat xpr-array, we see `>` and assume that it is not
 * a simple expression.
 *
 * @param {any[]} xpr
 * @param {string[]} additionalAllowedKeywords
 * @return {boolean}
 */
function isSimpleFunctionExpression( xpr, additionalAllowedKeywords = [] ) {
  return !xpr || xpr.every(val => typeof val !== 'string' ||
      (additionalAllowedKeywords.includes(val.toUpperCase()) ||
        !conditionOperators.includes(val.toUpperCase())));
}

/**
 * If `xpr` contains tokens that are used in conditions, it may be required to put the
 * rendered expression in parentheses.  This function checks if any direct entry in
 * `xpr` is a condition token such as `AND`.
 *
 * May report false positives for e.g. `CASE WHEN 1>1 THEN …`.
 *
 * @param {any[]} xpr
 * @return {boolean}
 */
function xprContainsCondition( xpr ) {
  return xpr && xpr.some(val => typeof val === 'string' &&
    conditionOperators.includes(val.toUpperCase()));
}

/**
 * Special functions may have special parser rules, such as SAP HANA RegEx functions.
 * They allow certain keywords in their arguments.
 *
 * This function is used to determine if arguments need to be put in parentheses or not.
 * See {@link isSimpleFunctionExpression}.
 *
 * @param {string} funcName
 * @param {number} argumentIndex
 * @returns {string[]}
 */
function getKeywordsForSpecialFunctionArgument( funcName, argumentIndex ) {
  const f = specialFunctions[funcName] && specialFunctions[funcName][argumentIndex];
  if (!f)
    return [];
  const additionalKeywords = [];
  if (f.intro)
    additionalKeywords.push(...f.intro);
  if (f.expr)
    additionalKeywords.push(...f.expr);
  if (f.separator)
    additionalKeywords.push(...f.separator);
  return additionalKeywords;
}

/**
 * Get a list of all special keywords for the given function.
 *
 * @param {string} funcName
 * @return {undefined|string[]}
 */
function getAllKeywordsForSpecialFunction( funcName ) {
  if (specialFunctionKeywords[funcName])
    return specialFunctionKeywords[funcName];
  else if (!specialFunctions[funcName])
    return undefined;

  const additionalKeywords = [];
  for (const arg of specialFunctions[funcName]) {
    if (arg.intro)
      additionalKeywords.push(...arg.intro);
    if (arg.expr)
      additionalKeywords.push(...arg.expr);
    if (arg.separator)
      additionalKeywords.push(...arg.separator);
  }
  specialFunctionKeywords[funcName] = additionalKeywords;
  return additionalKeywords;
}

/**
 * Render the given string.  Uses back-tick strings.
 * env is used for indentation of three-back-tick strings.
 *
 * @param {string} str
 * @param {CdlRenderEnvironment} env
 * @returns {string}
 */
function renderString( str, env ) {
  if (isSimpleString(str))
    return `'${str.replace(/'/g, '\'\'')}'`;

  // We try to work similar to how JavaScript implements JSON.stringify.
  // JSON.stringify() also checks for unpaired unicode surrogates (see §25.5.2.2,
  // <https://tc39.es/ecma262/#sec-quotejsonstring>).
  str = escapeString(str, {
    $: '\\$',
    '`': '\\`',
    '\\': '\\\\',
    // Replace commonly known escape sequences for control characters
    // See lib/language/multiLineStringParser.js
    '\f': '\\f',
    '\v': '\\v',
    '\t': '\\t',
    '\b': '\\b',
    // If CR, LS, or PS appear, they have been encoded explicitly.  If we don't escape
    // them, a recompilation may yield different results because of newline normalization.
    '\r': '\\r',
    '\u{2028}': '\\u{2028}',
    '\u{2029}': '\\u{2029}',
    // Don't encode LF
    '\n': '\n',
    // JSON.stringify() is not required to escape all control characters, but if used, files may
    // be interpreted as binary.  Therefore, we replace them.
    // We exclude LF from this list (\n). Characters with "nice" escapes have been replaced above.
    control: hexEscape,
    unpairedSurrogate: hexEscape,
  });

  // Note: String is normalized, only \n is the line separator.
  const lines = str.split('\n');
  // We don't know whether a text block was used or not.  But if there
  // are more than three lines, text blocks with indentation "look nicer".
  // This value was chosen by personal taste.
  if (lines.length > 3) {
    str = lines.join(`\n${env.indent}`);
    return `\`\`\`\n${env.indent}${str}\n${env.indent}\`\`\``;
  }

  return `\`${str}\``;
}

/** @param {number} codePoint */
function hexEscape( codePoint ) {
  const hex = codePoint.toString(16);
  return `\\u{${hex}}`;
}

/**
 * Returns true if the given string can be represented by using single quotes.
 * @param {string} str
 */
function isSimpleString( str ) {
  // A single-line string allows everything except certain line separators/breaks.
  // See ANTLR grammar for specifics.
  // Furthermore, if control characters are used, we escape them,
  // as these are explicitly mentioned in the JSON spec (§9):
  // <https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf>
  // On top, because (invalid) surrogate pairs need to be handled, we check for them as well.
  // v3: Not a simple string if ' (\u0027) is in string.
  // eslint-disable-next-line no-control-regex
  return str === '' || (/^[^\u{0000}-\u{001F}\u2028\u2029]+$/u.test(str) &&
    !hasUnpairedUnicodeSurrogate(str));
}

/**
 * Get a list of top-level artifact names, which are not in contexts/usings/, i.e. those
 * before the first dot ('.').  For example for `S.E.F`, `S` is used.
 *
 * @param {CSN.Model} csn
 * @return {string[]}
 */
function availableFirstPathSteps( csn ) {
  if (!csn.definitions)
    return [];
  const unique = new Set(Object.keys(csn.definitions).map(name => name.split('.')[0]));
  return Array.from(unique);
}

/**
 * Quotes the identifier using CDL-style ![]-quotes.
 *
 * NOTE: It is not guaranteed that the resulting string can _always_ be parsed!
 *       If `id` contains newline characters, the resulting delimited identifier
 *       will not be parsable by the compiler!
 *
 * @param id
 * @returns {string}
 */
function apiDelimitedId( id ) {
  return `![${id.replace(/]/g, ']]')}]`;
}

/**
 * Returns a delimited identifier if the given identifier needs quoting.
 * Because "special functions" such as SAP HANA RegEx functions have local keywords that
 * are not default CDL keywords, specify a function name to take care of that.
 *
 * NOTE: It is not guaranteed that the resulting string can _always_ be parsed!
 *       If `id` contains newline characters, the resulting delimited identifier
 *       will not be parsable by the compiler!
 *
 * @param {string} id
 * @param {null|string} insideFunction
 * @return {string}
 */
function apiSmartId( id, insideFunction = null ) {
  insideFunction = insideFunction?.toUpperCase();
  const extra = insideFunction && specialFunctions[insideFunction] ? getAllKeywordsForSpecialFunction(insideFunction) : [];
  if (requiresQuotingForCdl(id, extra))
    return apiDelimitedId(id);
  return id;
}

/**
 * Quote the given function name if required.
 *
 * NOTE: It is not guaranteed that the resulting string can _always_ be parsed!
 *       If `funcName` contains newline characters, the resulting delimited identifier
 *       will not be parsable by the compiler!
 *
 * @param {string} funcName
 * @return {string}
 */
function apiSmartFunctionId( funcName ) {
  const funcId = funcName.toUpperCase();
  const requiresQuoting = !identifierRegex.test(funcName) ||
    (keywords.cdl.includes(funcId) && !specialFunctions[funcId]);
  if (requiresQuoting)
    return apiDelimitedId(funcName);
  return funcName;
}


module.exports = {
  csnToCdl,
  smartId: apiSmartId,
  smartFunctionId: apiSmartFunctionId,
  delimitedId: apiDelimitedId,
};
