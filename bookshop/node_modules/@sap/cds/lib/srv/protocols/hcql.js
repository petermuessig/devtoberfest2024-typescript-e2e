const express = require('express')
const cds = require('../../index')
const DEBUG = cds.debug('hcql')
const { inspect } = require('util')

class HCQLAdapter extends require('./http') {

  get router() {
    const srv = this.service
    return super.router

    /**
     * Return CSN schema in response to /<srv>/$csn requests
     */
    .get('/\\$csn', (_, res) => res.json(this.schema))

    .use(express.json(this.body_parser_options)) //> for application/json -> cqn
    .use(express.text(this.body_parser_options)) //> for text/plain -> cql -> cqn

    /**
     * Convenience route for REST-style request formats like that:
     * GET /browse/Books { ID, title, author.name as author } where stock < 100
     * GET /browse/Books/201 { ID, title, author.name as author }
     */
    .get('/:entity/:id?(%20:tail)?', (req, _, next) => {
      let { entity, id, tail } = req.params, q = SELECT.from(entity, id)
      if (is_string(req.body)) tail = req.body
      else if (is_array(req.body)) q.columns(req.body)
      else Object.assign(q.SELECT, req.body)
      if (tail) q = { SELECT: { ...CQL(`SELECT from _ ${tail}`).SELECT, ...q.SELECT } }
      req.body = q; next() // delegating to main handler
    })

    /**
     * The actual protocol adapter, handling all requests.
     */
    .use((req, res, next) => {
      let q = this.query4(req)
      DEBUG?.(inspect(q,{depth:11,colors:true}))
      return srv.run(q).then(r => res.json(r)).catch(next)
    })
  }

  get schema() {
    return cds.minify (cds.model, { service: this.service.name })
  }

  query4 (req) {
    if (typeof req.body === 'string') return req.body = cds.parse.cql(req.body)
    return req.body //> a plain CQN object
  }
}

const is_string = x => typeof x === 'string'
const is_array = Array.isArray

module.exports = HCQLAdapter
