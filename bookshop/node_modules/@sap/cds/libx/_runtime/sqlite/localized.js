const { ensureUnlocalized } = require('../common/utils/draft')
const { redirect } = require('../db/utils/localized')
const cds = require('../cds')
const LOG = cds.log('sqlite|db|sql')

if (cds.env.i18n && Array.isArray(cds.env.i18n.for_sqlite) && !cds.env.i18n.for_sqlite.length) {
  LOG._warn && LOG.warn('No language configuration found in cds.env.i18n.for_sqlite')
}

const _translations = cds.env.i18n.for_sqlite.reduce((all, l) => ((all[l] = true), all), {})

// REVISIT: this is actually configurable
// there is no localized.en.<name>
const getLocalize = (locale, model) => name => {
  if (name.endsWith('_drafts')) return name

  // if we get here via onReadDraft, target is already localized
  // because of subrequest using SELECT.from as new target
  const target = model.definitions[ensureUnlocalized(name)]
  if (target?.['@cds.localized'] === false) return name

  const view = model.definitions[`localized${locale in _translations ? '.' + locale : ''}.${name}`]
  return view?.name || name
}

const sqliteLocalized = function (req) {
  const { query } = req

  // do simple checks upfront and exit early
  if (!query || typeof query === 'string') return
  if (!query.SELECT) return
  if (!this.model) return
  if (!req.locale) return

  // suppress localization by instruction
  if (query.SELECT.localized === false) return

  // suppress localization for pure counts
  const columns = query.SELECT.columns
  if (columns && columns.length === 1 && columns[0].func === 'count') return

  // suppress localization in "select for update" n/a for sqlite

  redirect(query, getLocalize(req.locale, this.model))
}

sqliteLocalized._initial = true

module.exports = sqliteLocalized
