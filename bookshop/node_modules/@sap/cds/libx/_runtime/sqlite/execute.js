const { SQLITE_TYPE_CONVERSION_MAP } = require('./conversion')
const CustomBuilder = require('./customBuilder')
const { sqlFactory } = require('../db/sql-builder/')
const { getPostProcessMapper, postProcess } = require('../db/data-conversion/post-processing')
const { createJoinCQNFromExpanded, hasExpand, rawToExpanded, expandV2 } = require('../db/expand')
const { Readable } = require('stream')

const cds = require('../cds')
const LOG = cds.log('sqlite|db|sql')
// && {_debug:true, debug(sql){ cds._debug && console.log(sql+';\n') }} //> please keep that for debugging stakeholder tests
const coloredTxCommands = require('../db/utils/coloredTxCommands')
const { convertStream } = require('../db/utils/stream')
const { inspect } = require('util')

const SANITIZE_VALUES = process.env.NODE_ENV === 'production' && cds.env.log.sanitize_values !== false

/*
 * capture stack trace on the way to exec to know origin
 * -> very expensive
 * -> only if DEBUG (which should not be used in production)
 */
const DEBUG = cds.debug('sqlite')
const _exec = DEBUG
  ? (dbc, op, ...args) => {
      const callback = args[args.length - 1]
      const captured = {}
      Error.captureStackTrace(captured, _exec)
      args[args.length - 1] = function (err) {
        if (err) {
          err.message += ' in: \n' + args[0]
          err.query = args[0]
          if (args.length > 2) err.values = SANITIZE_VALUES ? ['***'] : args[1]
          err.stack =
            err.message +
            captured.stack
              .slice(5)
              .replace(/at( _exec)? /, 'at SQLite.' + op + ' ')
              .replace(/\s+at new Promise .*\n.*/, '')
        }
        callback.apply(this, arguments)
      }
      return dbc[op](...args)
    }
  : (dbc, op, ...args) => {
      const callback = args[args.length - 1]
      args[args.length - 1] = function (err) {
        if (err) {
          err.message += ' in: \n' + args[0]
          err.query = args[0]
          if (args.length > 2) err.values = SANITIZE_VALUES ? ['***'] : args[1]
        }
        callback.apply(this, arguments)
      }
      return dbc[op](...args)
    }

function _executeSimpleSQL(dbc, sql, values) {
  LOG._debug &&
    LOG.debug(coloredTxCommands[sql] || sql, Array.isArray(values) ? (SANITIZE_VALUES ? ['***'] : values) : '')

  return new Promise((resolve, reject) => {
    _exec(dbc, 'run', sql, values, function (err) {
      if (err) return reject(err)
      resolve(this.changes)
    })
  })
}

function executeSelectSQL(dbc, sql, values, isOne, postMapper) {
  LOG._debug && LOG.debug(sql, SANITIZE_VALUES ? ['***'] : values)

  return new Promise((resolve, reject) => {
    _exec(dbc, isOne ? 'get' : 'all', sql, values, (err, result) => {
      if (err) return reject(err)
      resolve(result)
    })
  }).then(result => postProcess(result, postMapper))
}

function _processExpand(model, dbc, cqn, user, locale, txTimestamp) {
  const queries = []
  const expandQueries = createJoinCQNFromExpanded(cqn, model, locale)

  for (const cqn of expandQueries.queries) {
    cqn._conversionMapper = getPostProcessMapper(SQLITE_TYPE_CONVERSION_MAP, model, cqn)

    // REVISIT
    // Why is the post processing in expand different?
    const { sql, values } = sqlFactory(cqn, { user, now: txTimestamp, customBuilder: CustomBuilder }, model)
    queries.push(executeSelectSQL(dbc, sql, values, false))
  }

  return rawToExpanded(expandQueries, queries, cqn.SELECT.one, cqn._target)
}

function executeSelectCQN(model, dbc, query, user, locale, txTimestamp) {
  if (hasExpand(query)) {
    // expand: '**' or '*3' is handled by new impl
    if (
      query.SELECT.columns.some(c => c.expand && typeof c.expand[0] === 'string' && /^\*{1}[\d|*]+/.test(c.expand[0]))
    ) {
      return expandV2(model, dbc, query, user, locale, txTimestamp, executeSelectCQN)
    }

    return _processExpand(model, dbc, query, user, locale, txTimestamp)
  }

  const { sql, values = [] } = sqlFactory(
    query,
    {
      user,
      customBuilder: CustomBuilder,
      now: txTimestamp || { sql: "strftime('%Y-%m-%dT%H:%M:%fZ','now')" }, // '2012-12-03T07:16:23.574Z'
      locale
    },
    model
  )

  return executeSelectSQL(
    dbc,
    sql,
    values,
    query.SELECT.one,
    getPostProcessMapper(SQLITE_TYPE_CONVERSION_MAP, model, query)
  )
}

function executeDeleteCQN(model, dbc, cqn, user, locale, txTimestamp) {
  const { sql, values = [] } = sqlFactory(
    cqn,
    {
      user,
      customBuilder: CustomBuilder,
      now: txTimestamp || { sql: "strftime('%Y-%m-%dT%H:%M:%fZ','now')" } // '2012-12-03T07:16:23.574Z'
    },
    model
  )

  return _executeSimpleSQL(dbc, sql, values)
}

const _executeBulkInsertSQL = (dbc, sql, values) =>
  new Promise((resolve, reject) => {
    if (!Array.isArray(values)) {
      return reject(new Error(`Cannot execute SQL statement. Invalid values provided: ${inspect(values)}`))
    }

    LOG._debug && LOG.debug(sql, SANITIZE_VALUES ? ['***'] : values)
    const stmt = _exec(dbc, 'prepare', sql, err => {
      if (err) return reject(err)

      // REVISIT: better?
      if (dbc._closed) return reject(new Error('Transaction is already closed'))

      if (!Array.isArray(values[0])) values = [values]

      // guarantee order through counters in closure
      let i = 0
      let n = values.length
      let isFinalized = false
      const results = Array(n)
      values.forEach(each => {
        const k = i
        i++
        stmt.run(each, function (err) {
          if (err) {
            if (!isFinalized) {
              isFinalized = true
              stmt.finalize()
              return reject(err)
            }
          }

          // InsertResult needs an object per row with its values
          results[k] = { lastID: this.lastID, affectedRows: 1, values: each }
          n--
          if (n === 0) {
            if (!isFinalized) {
              isFinalized = true
              stmt.finalize()
              resolve(results)
            }
          }
        })
      })
    })
  })

function executePlainSQL(dbc, sql, values, isOne, postMapper) {
  // support named binding parameters
  if (values && typeof values === 'object' && !Array.isArray(values)) {
    values = new Proxy(values, {
      getOwnPropertyDescriptor: (o, p) => Object.getOwnPropertyDescriptor(o, p.slice(1)),
      get: (o, p) => o[p.slice(1)],
      ownKeys: o => Reflect.ownKeys(o).map(k => `:${k}`)
    })
  }

  if (/^\s*(select|pragma)/i.test(sql)) {
    return executeSelectSQL(dbc, sql, values, isOne, postMapper)
  }

  if (/^\s*insert/i.test(sql) || /^\s*upsert/i.test(sql)) {
    return executeInsertSQL(dbc, sql, values)
  }

  return _executeSimpleSQL(dbc, sql, values && Array.isArray(values[0]) ? values[0] : values)
}

function executeInsertSQL(dbc, sql, values, query) {
  // Only bulk inserts will have arrays in arrays
  if (Array.isArray(values[0])) {
    if (values.length > 1) {
      return _executeBulkInsertSQL(dbc, sql, values)
    } else {
      values = values[0]
    }
  }

  LOG._debug && LOG.debug(sql, SANITIZE_VALUES ? ['***'] : values)

  return new Promise((resolve, reject) => {
    _exec(dbc, 'run', sql, values, function (err) {
      if (err) return reject(err)

      // InsertResult needs an object per row with its values
      if (query && values.length > 0) {
        // > single row via cqn
        resolve([{ lastID: this.lastID, affectedRows: 1, values }])
      } else {
        // > plain sql or INSERT into SELECT
        resolve([{ lastID: this.lastID, affectedRows: this.changes }])
      }
    })
  })
}

// REVISIT: optimize - now sub-arrays are called sequentially
async function _convertStreamValues(values) {
  let any
  for (let i = 0; i < values.length; i++) {
    const v = values[i]
    if (v instanceof Readable) {
      any = values[i] = new Promise(resolve => {
        const chunks = []
        v.on('data', chunk => chunks.push(chunk))
        v.on('end', () => resolve(Buffer.concat(chunks)))
        v.on('error', () => {
          v.removeAllListeners('error')
          v.push(null)
        })
      })
    } else if (Array.isArray(v)) {
      values[i] = await _convertStreamValues(v)
    }
  }
  return any ? Promise.all(values) : values
}

async function executeInsertCQN(model, dbc, query, user, locale, txTimestamp) {
  const { sql, values = [] } = sqlFactory(
    query,
    {
      user,
      customBuilder: CustomBuilder,
      now: txTimestamp || { sql: "strftime('%Y-%m-%dT%H:%M:%fZ','now')" } // '2012-12-03T07:16:23.574Z'
    },
    model
  )
  const vals = await _convertStreamValues(values)
  return executeInsertSQL(dbc, sql, vals, query)
}

async function executeUpdateCQN(model, dbc, cqn, user, locale, txTimestamp) {
  const { sql, values = [] } = sqlFactory(
    cqn,
    {
      user,
      customBuilder: CustomBuilder,
      now: txTimestamp || { sql: "strftime('%Y-%m-%dT%H:%M:%fZ','now')" } // '2012-12-03T07:16:23.574Z'
    },
    model
  )
  const vals = await _convertStreamValues(values)
  return executePlainSQL(dbc, sql, vals)
}

// e. g. DROP, CREATE TABLE
function executeGenericCQN(model, dbc, cqn, user, locale, txTimestamp) {
  const { sql, values } = sqlFactory(
    cqn,
    {
      user,
      customBuilder: CustomBuilder,
      now: txTimestamp || { sql: "strftime('%Y-%m-%dT%H:%M:%fZ','now')" } // '2012-12-03T07:16:23.574Z'
    },
    model
  )

  return executePlainSQL(dbc, sql, values)
}

// REVISIT: consider deleting this function after removing stream_compat
async function executeSelectStreamCQN({ model, dbc, query, user, locale, txTimestamp }) {
  let result = await executeSelectCQN(model, dbc, query, user, locale, txTimestamp)

  if (result == null || result.length === 0) {
    return
  }

  if (!cds.env.features.stream_compat) {
    convertStream(query.SELECT.columns, query.target, result, query.SELECT.one)
    return result
  }

  // REVISIT: following code to be deleted after cds.env.features.stream_compat is removed
  if (Array.isArray(result)) result = result[0]
  let [key, val] = Object.entries(result)[0]
  if (val === null) {
    return null
  }
  if (typeof val === 'number') {
    val = val.toString()
  }

  const stream_ = new Readable()
  stream_.push(val)
  stream_.push(null)

  result.value = stream_
  delete result[key]

  return result
}

module.exports = {
  delete: executeDeleteCQN,
  insert: executeInsertCQN,
  update: executeUpdateCQN,
  select: executeSelectCQN,
  stream: executeSelectStreamCQN,
  convert: convertStream,
  cqn: executeGenericCQN,
  sql: executePlainSQL
}
