const cds = require('../cds')

const DatabaseService = require('../db/Service')

let _sqlite

/*
 * sqlite-specific handlers
 */
const localized = require('./localized')
const convertAssocToOneManaged = require('./convertAssocToOneManaged')
const convertDraftAdminPathExpression = require('./convertDraftAdminPathExpression')

/*
 * sqlite-specific execution
 */
const execute = require('./execute')

const _new = url => {
  if (url && url !== ':memory:') url = cds.utils.path.resolve(cds.root, url)
  if (!_sqlite) _sqlite = require('sqlite3')
  return new Promise((resolve, reject) => {
    const dbc = new _sqlite.Database(url, err => {
      err ? reject(err) : resolve(dbc)
    })
  })
}

/*
 * the service
 */
module.exports = class SQLiteDatabase extends DatabaseService {
  constructor(...args) {
    super(...args)

    // REVISIT: official db api
    this._execute = execute

    // REVISIT: official db api
    this._insert = this._queries.insert(execute.insert)
    this._read = this._queries.read(execute.select, execute.stream, execute.convert)
    this._update = this._queries.update(execute.update, execute.select)
    this._delete = this._queries.delete(execute.delete, execute.update)
    this._run = this._queries.run(this._insert, this._read, this._update, this._delete, execute.cqn, execute.sql)

    this.dbcs = new Map()
  }

  init() {
    this._registerBeforeHandlers()
    this._registerOnHandlers()
    this._registerAfterHandlers()

    /*
     * tx
     */
    this.on(['BEGIN', 'COMMIT', 'ROLLBACK'], function (req) {
      // REVISIT: better?
      this.dbc._closed = req.event !== 'BEGIN'

      return this._run(this.model, this.dbc, req.event)
    })

    /*
     * generic
     */
    // all others, i.e. CREATE, DROP table, ...
    this.on('*', function (req) {
      return this._run(this.model, this.dbc, req.query || req.event, req, req.data)
    })
  }

  _registerBeforeHandlers() {
    this.before(['CREATE', 'UPDATE', 'UPSERT'], '*', this._input) // > has to run before rewrite
    this.before(['CREATE', 'READ', 'UPDATE', 'DELETE', 'UPSERT'], '*', this._rewrite)

    if (!cds.db?.cqn2sql) this.before('READ', '*', convertDraftAdminPathExpression)
    this.before('READ', '*', convertAssocToOneManaged)
    this.before('READ', '*', localized) // > has to run after rewrite
    this.before('READ', '*', this._virtual)
  }

  _registerOnHandlers() {
    this.on('CREATE', '*', this._CREATE)
    this.on('READ', '*', this._READ)
    this.on('UPDATE', '*', this._UPDATE)
    this.on('DELETE', '*', this._DELETE)
  }

  _registerAfterHandlers() {
    // REVISIT: after phase runs in parallel -> side effects possible!
    const { effective, features } = cds.env

    if (effective.odata.structs && !features.ucsn_struct_conversion) {
      // REVISIT: only register for entities that contain structured or navigation to it
      this.after(['READ'], '*', this._structured)
    }
  }

  url4(tenant) {
    const credentials = this.options.credentials || this.options || {}
    let dbUrl = credentials.database || credentials.url || credentials.host || ':memory:'

    if (tenant && dbUrl !== ':memory:') {
      dbUrl = dbUrl.replace(/\.(db|sqlite)$/, `-${tenant}.$1`)
    }
    return dbUrl
  }

  /*
   * connection
   */
  async acquire(arg) {
    // in non-multi-tenant scenarios, the default db should be returned regardless of arg
    const isMultitenant = 'multiTenant' in this.options ? this.options.multiTenant : cds.env.requires.multitenancy
    // REVISIT: there should already be compat for the multitenancy flag, why is it not working here?
    // REVISIT: remove fallback arg.user.tenant with cds^6
    const tenant = isMultitenant && arg && (typeof arg === 'string' ? arg : arg.tenant || (arg.user && arg.user.tenant))
    let dbc = this.dbcs.get(tenant)
    if (!dbc) {
      const dbUrl = this.url4(tenant)

      dbc = await _new(dbUrl)

      dbc._queued = []

      if (cds.env.features.assert_integrity === 'db') {
        await new Promise((resolve, reject) => {
          dbc.exec('PRAGMA foreign_keys = ON', err => {
            if (err) reject(err)
            resolve()
          })
        })
      }

      this.dbcs.set(tenant, dbc)
    }

    if (dbc._busy) await new Promise(resolve => dbc._queued.push(resolve))
    else dbc._busy = true

    return dbc
  }

  release(dbc) {
    if (dbc._queued.length) dbc._queued.shift()()
    else dbc._busy = false
  }

  async disconnect(tenant) {
    this.dbcs.delete(tenant)
  }
}
