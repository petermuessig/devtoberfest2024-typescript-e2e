const InsertBuilder = require('../../db/sql-builder').InsertBuilder
const getAnnotatedColumns = require('../../db/sql-builder/annotations')

class CustomUpsertBuilder extends InsertBuilder {
  constructor(obj, options, csn) {
    super(obj, options, csn)
    this._UPSERT = true
  }

  annotatedColumns(entityName, csn) {
    const { updateAnnotatedColumns } = getAnnotatedColumns(entityName, csn)

    if (updateAnnotatedColumns?.size) {
      this.managedCols = Array.from(updateAnnotatedColumns.keys())
    }

    return { insertAnnotatedColumns: updateAnnotatedColumns }
  }

  // REVISIT: We need to copy over the implementation for annotation handling
  build() {
    this._obj = { INSERT: this._obj.UPSERT, _target: this._obj._target }
    super.build()
    const csnKeys =
      (this._obj._target ? this._obj._target.keys : this._csn.definitions[this._obj.INSERT.into].keys) || {}
    const keys = Object.keys(csnKeys).filter(k => !csnKeys[k].isAssociation && k !== 'IsActiveEntity')
    const updates = []
    const columns = this._obj.INSERT.columns || Object.keys(this._obj.INSERT.entries[0])
    if (this.managedCols) {
      columns.push(...this.managedCols)
    }

    columns.forEach(col => {
      const col_ = col.replace(/\./g, '_')
      const sqlColumn = this._quoteElement(col_)
      if (!keys.includes(col_)) updates.push(`${sqlColumn}=excluded.${sqlColumn}`)
    })
    const conflict = updates.length
      ? ` ON CONFLICT (${keys}) DO UPDATE SET ` + updates.join(', ')
      : ` ON CONFLICT (${keys}) DO NOTHING`

    this._outputObj.sql = this._outputObj.sql + conflict
    return this._outputObj
  }
}

module.exports = CustomUpsertBuilder
