const cds = require('../../cds')
const getColumns = require('../utils/columns')

const _identifierForRow = (row, prefix, keys) => {
  return keys.map(k => row[`${prefix}${k}`]).join(',')
}

const _removeParentKeysFromRow = (row, prefix, keys) => {
  for (const k of keys) {
    delete row[`${prefix}${k}`]
  }
}

const _autoExpandNavsAndAttachToResult = async (entity, previousResult, depth, options) => {
  for (const nav in entity._associations) {
    const navigation = entity._associations[nav]
    if (options.onlyCompositions && navigation._isAssociationStrict) continue

    // do not expand backlinks
    if (navigation._isBacklink) continue

    const childAlias = 'child'
    const parentAlias = 'parent'

    const cqnQuery = SELECT.from(`${navigation.target} as ${childAlias}`)
      .join(`${entity.name} as ${parentAlias}`)
      .on(entity._relations[navigation.name].join(childAlias, parentAlias))

    // set alias for expanded columns already
    const childColumns = getColumns(navigation._target, { _4db: true, onlyKeys: options.onlyKeys }).map(c => ({
      ref: [childAlias, c.name]
    }))
    const parentKeys = Object.keys(entity.keys).filter(k => !entity.keys[k].isAssociation)
    // mark parent key with prefix in alias
    const parentKeysWithAlias = parentKeys.map(pk => ({ ref: [parentAlias, pk], as: `$$pk_${pk}` }))
    cqnQuery.columns(...childColumns, ...parentKeysWithAlias)

    // add tuple comparison for where clause
    cqnQuery.where([
      { list: parentKeys.map(pk => ({ ref: [parentAlias, pk] })) },
      'in',
      { list: previousResult.map(row => ({ list: parentKeys.map(pk => ({ val: row[pk] })) })) }
    ])

    // sort by primary keys of parent, required in future
    cqnQuery.orderBy(parentKeys.map(pk => ({ ref: [parentAlias, pk] })))

    const result = await cds.db.run(cqnQuery)

    // TODO: Is there a more efficient/stable way to handle compound keys?
    const map = new Map()
    for (const row of result) {
      const identifier = _identifierForRow(row, '$$pk_', parentKeys)
      _removeParentKeysFromRow(row, '$$pk_', parentKeys)
      if (map.has(identifier)) {
        map.get(identifier).push(row)
      } else {
        map.set(identifier, [row])
      }
    }

    // link previous result with current result
    previousResult.forEach(row => {
      const identifier = _identifierForRow(row, '', parentKeys)
      if (map.has(identifier)) {
        const entry = map.get(identifier)
        row[nav] = navigation.is2one ? entry[0] : entry
      } else {
        row[nav] = navigation.is2one ? null : []
      }
    })

    // expand next level if needed
    if (depth - 1 !== 0 && result.length && navigation._target._associations) {
      await _autoExpandNavsAndAttachToResult(navigation._target, result, depth - 1, options)
    }
  }

  return previousResult
}

const _fkForOnCOnd = (onCond, requiredFks) => {
  for (const ele of onCond) {
    if (ele.xpr) {
      _fkForOnCOnd(ele.xpr, requiredFks)
    }

    if (ele.ref && ele.ref[0] === 'parent') {
      requiredFks.add(ele.ref.slice(1).join('_'))
    }
  }
}

const _foreignKeysOfTopLevelNavs = (entity, options) => {
  const requiredFks = new Set()
  for (const nav in entity._associations) {
    if (options.onlyCompositions && entity._associations[nav]._isAssociationStrict) continue
    const onCond = entity._relations[nav].join('child', 'parent')
    _fkForOnCOnd(onCond, requiredFks)
  }
  return [...requiredFks]
}

const _addForeignKeys = (columns, entity, options) => {
  const fks = _foreignKeysOfTopLevelNavs(entity, options)
  fks.forEach(fk => {
    if (!columns.some(c => c.ref[0] === fk)) {
      columns.push({ ref: [fk] })
    }
  })
}

/**
 * 1. Creates flattened SQL statements for each expand layer
 * 2. Mixes in foreign keys if needed
 * 3. Merges results
 * 4. Cleans result if needed
 *
 * @returns object
 */
const expandV2 = async (model, dbc, query, user, locale, txTimestamp, executeSelectCQN) => {
  const expandColumn = query.SELECT.columns.find(c => c.expand && typeof c.expand[0] === 'string')
  const options = Object.assign({ onlyKeys: false, onlyCompositions: false }, expandColumn._options)
  // remove expand columns from query without modifying
  const topLevelSelect = query.clone().columns(query.SELECT.columns.filter(c => !c.expand))

  const entity = model.definitions[topLevelSelect.SELECT.from.ref[0]]

  // ensure foreign keys are selected if needed
  _addForeignKeys(topLevelSelect.SELECT.columns, entity, options)

  const result = await executeSelectCQN(model, dbc, topLevelSelect, user, locale, txTimestamp)

  if (!result || (Array.isArray(result) && !result.length)) {
    return result
  }

  // _associations contains compositions and associations
  if (entity._associations) {
    const depth = expandColumn.expand[0] === '**' ? -1 : Number(expandColumn.expand[0].replace('*', ''))
    await _autoExpandNavsAndAttachToResult(entity, Array.isArray(result) ? result : [result], depth, options)
  }

  return result
}

module.exports = expandV2
