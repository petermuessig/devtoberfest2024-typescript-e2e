const cds = require('../cds')

/*
 * generic queries
 */
const queries = require('./query')

/*
 * generic handlers
 */
const generic = require('./generic')

class DatabaseService extends cds.Service {
  constructor(...args) {
    super(...args)

    // REVISIT: official db api
    this._queries = queries

    // REVISIT: official db api
    for (const each in generic) {
      this[`_${each}`] = generic[each]
    }

    // REVISIT: how to generic handler registration?
  }

  /** Database services don't support custom-defined operations */
  get operations() {
    return []
  }

  /** Database services don't support custom-defined events */
  get events() {
    return []
  }

  /*
   * tx
   */
  async begin() {
    const tx = this.context ? this : this.tx()
    tx.dbc = await tx.acquire(tx.context)
    try {
      await tx.send('BEGIN')
    } catch (e) {
      tx.release(tx.dbc)
      throw e
    }
    return tx
  }

  async commit() {
    // only release on successful commit as otherwise released on rollback
    await this.send('COMMIT')
    this.release(this.dbc)
  }

  async rollback() {
    if (this.dbc) {
      try {
        await this.send('ROLLBACK')
      } finally {
        this.release(this.dbc)
      }
    }
  }

  /*
   * streaming
   */
  _runStream(streamQuery, result) {
    this.run(streamQuery).then(stream => {
      if (cds.env.features.stream_compat) {
        if (!stream || !stream.value) {
          result.push(null)
        } else {
          stream.value.pipe(result)
        }
      } else {
        const col = streamQuery.SELECT.columns[0].ref[0]
        if (!stream || !stream[col]) {
          result.push(null)
        } else {
          stream[col].pipe(result)
        }
      }
    })
  }
}

DatabaseService.prototype.isDatabaseService = true
module.exports = DatabaseService
