/*
 * input handler on DatabaseService level
 *
 * - remove virtual fields
 * - add managed, if not provided
 * - assert not nullable without default (for better error message)
 * - add default values, if not provided (mainly for rest response body, odata does read after write)
 * - add UUIDs
 * - propagate keys
 */

const cds = require('../../cds')

const normalizeTimeData = require('../utils/normalizeTimeData')

const { enrichDataWithKeysFromWhere } = require('../../common/utils/keys')
const propagateForeignKeys = require('../../common/utils/propagateForeignKeys')
const getTemplate = require('../../common/utils/template')

const { DRAFT_COLUMNS_MAP } = require('../../common/constants/draft')

const _isManaged = (category, event) =>
  (category === '@cds.on.insert' && event === 'CREATE') || (category === '@cds.on.update' && event === 'UPDATE')

const _shouldGenerateUUID = element => element.key && !DRAFT_COLUMNS_MAP[element.name] && element.isUUID

const _processComplexCategory = ({ row, key, val, category, req, element }) => {
  const categoryArgs = category.args
  category = category.category

  // propagate keys
  if (category === 'propagateForeignKeys') {
    if (req.event !== 'UPSERT')
      propagateForeignKeys(key, row, element._foreignKeys, element.isComposition, { deleteAssocs: true })
    return
  }

  // managed
  if (val === undefined && _isManaged(category, req.event)) {
    if (typeof categoryArgs === 'object') {
      const val = categoryArgs['=']
      if (val.match(/^\$/)) {
        row[key] = val === '$uuid' ? cds.utils.uuid() : val
      } else row[key] = row[val]
    } else {
      row[key] = categoryArgs
    }
  }

  // not null with default for rest response body and ensure utc
  if (category === 'default' && val === undefined && req.event === 'CREATE') {
    const { default: dfault } = categoryArgs
    if ('val' in dfault) row[key] = dfault.val
    else if ('ref' in dfault && dfault.ref[0] === '$now') {
      row[key] =
        categoryArgs._type === 'cds.DateTime'
          ? new Date(req.timestamp).toISOString().replace(/\.\d\d\d/, '')
          : req.timestamp
    }
  }
}

const _processCategory = (req, category, { row, key, element }) => {
  const val = row[key]

  // use args only inside this if (sonar type error warning)
  if (typeof category === 'object') {
    _processComplexCategory({ category, row, key, val, req, element })
    return
  }

  // virtual
  if (category === 'virtual') {
    delete row[key]
    return
  }

  if (category === 'comp2one') {
    if (!val) return

    for (const keyName in element._target.keys) {
      const k = element._target.keys[keyName]
      if (k.isAssociation || k.name === 'IsActiveEntity') continue

      if (!k.isUUID && !(k.name in val)) {
        req.error({
          code: 'MUST_NOT_BE_NULL',
          message: 'Value is required',
          target: key + '[' + k.name + ']',
          args: [key + '[' + k.name + ']']
        })
        return
      }
    }
  }

  // not null without default (for better error message)
  if (category === '!default' && val == null && req.event === 'CREATE') {
    req.error({ code: 'MUST_NOT_BE_NULL', message: 'Value is required', target: key, args: [key] })
    return
  }

  // generate UUIDs
  if (category === 'uuid' && !val && req.event === 'CREATE' && !element._foreignKey4) {
    row[key] = cds.utils.uuid()
  }
}

const _processorFn = req => elementInfo => {
  for (const category of elementInfo.plain.categories) {
    _processCategory(req, category, elementInfo)
  }
}

const _isVirtualOrCalculated = element => {
  if (element.virtual) return true
  if (
    element.parent &&
    element.parent.projection &&
    element.parent.projection.columns &&
    element.parent.projection.columns.find(c => c.as === element.name && (c.xpr || c.val || c.func))
  ) {
    return true
  }
}

// params: element, target, parent, templateElements
const _pickCRUD = element => {
  // collect actions to apply
  const categories = []

  if (_isVirtualOrCalculated(element)) {
    categories.push('virtual')
    return { categories } // > no need to continue
  }

  if (element.notNull && element['@assert.notNull'] !== false && !element.default && !element._isAssociationStrict) {
    categories.push('!default')
  }

  if (element.default && !DRAFT_COLUMNS_MAP[element.name] && !element.isAssociation) {
    categories.push({ category: 'default', args: element })
  }

  if (element['@cds.on.insert']) {
    categories.push({ category: '@cds.on.insert', args: element['@cds.on.insert'] })
  }

  if (element['@cds.on.update']) {
    categories.push({ category: '@cds.on.update', args: element['@cds.on.update'] })
  }

  // REVISIT: element._foreignKeys.length seems to be a very broad check
  if (element.isAssociation && element._foreignKeys.length) {
    categories.push({ category: 'propagateForeignKeys' })
  }

  if (_shouldGenerateUUID(element)) {
    categories.push('uuid')
  }

  if (element.isComposition && element.is2one) {
    categories.push('comp2one')
  }

  if (categories.length) return { categories }
}

const _pickDraft = element => {
  // collect actions to apply
  const categories = []

  if (_isVirtualOrCalculated(element)) {
    categories.push('virtual')
    return { categories } // > no need to continue
  }

  if (element.default && !DRAFT_COLUMNS_MAP[element.name] && !element.isAssociation) {
    categories.push({ category: 'default', args: element })
  }

  // REVISIT: element._foreignKeys.length seems to be a very broad check
  if (element.isAssociation && element._foreignKeys.length) {
    categories.push({ category: 'propagateForeignKeys' })
  }

  if (_shouldGenerateUUID(element)) {
    categories.push('uuid')
  }

  if (categories.length) return { categories }
}

function dbGenericInput(req) {
  if (!this.model || typeof req.query === 'string' || !req.target) return

  // call with this for this.model
  normalizeTimeData.call(this, req)

  const draft = req.target.name && (req.target.name.match(/_drafts$/) || req.target.name.match(/\.drafts$/))

  const target =
    req.target._unresolved && req.target.name
      ? this.model.definitions[req.target.name] || this.model.definitions[req.target.name.replace(/_drafts$/, '')]
      : req.target
  if (!target || target._unresolved) return

  // REVISIT: probably need to filter for .columns/.rows combination as well
  if (req.query.INSERT && !req.query.INSERT.entries) return

  let template
  if (draft) {
    template = getTemplate('db-input-draft', this, target, { pick: _pickDraft })
  } else {
    template = getTemplate('db-input-crud', this, target, { pick: _pickCRUD })
  }

  if (template.elements.size === 0) return

  if (!draft) enrichDataWithKeysFromWhere(req.data, req, this)

  template.process(req.data, _processorFn(req))
}

dbGenericInput._initial = true

module.exports = dbGenericInput
