const _flattenDeep = (arr, res) => {
  if (!Array.isArray(arr)) {
    res.push(arr)
    return res
  }

  for (const a of arr) {
    _flattenDeep(a, res)
  }

  return res
}

/*
 * flatten with a dfs approach. this is important!!!
 */
const getFlatArray = arg => _flattenDeep(arg, [])

async function _processChunk(processFn, model, dbc, cqns, user, locale, ts, indexes, results) {
  const promises = []
  for (const i of indexes) promises.push(processFn(model, dbc, cqns[i], user, locale, ts))
  const promisesResults = await Promise.allSettled(promises)
  const firstRejected = promisesResults.find(r => r.status === 'rejected')
  if (firstRejected) throw firstRejected.reason

  // put results of queries into correct place of return results
  for (let i = 0; i < promisesResults.length; i++) results[indexes[i]] = promisesResults[i].value
}

// execute deletes first, but keep results in order of cqns
async function processCQNs(processFn, cqns, model, dbc, user, locale, ts, chunks) {
  const results = new Array(cqns.length)
  const deletes = []
  const updatesForDeletes = []
  const others = []

  for (let i = 0; i < cqns.length; i++) {
    if (cqns[i].DELETE) deletes.push(i)
    else if (cqns[i].__4delete) updatesForDeletes.push(i)
    else others.push(i)
  }

  if (deletes.length > 0) {
    if (chunks) {
      let offset = 0

      for (const amount of chunks) {
        const indexes = deletes.slice(offset, offset + amount)
        await _processChunk(processFn, model, dbc, cqns, user, locale, ts, indexes, results)
        offset += amount
      }
    } else {
      await _processChunk(processFn, model, dbc, cqns, user, locale, ts, deletes, results)
    }
  }

  if (updatesForDeletes.length > 0) {
    await _processChunk(processFn, model, dbc, cqns, user, locale, ts, updatesForDeletes, results)
  }

  if (others.length > 0) {
    await _processChunk(processFn, model, dbc, cqns, user, locale, ts, others, results)
  }

  return results
}

module.exports = {
  getFlatArray,
  processCQNs
}
