const { ensureUnlocalized } = require('../../common/utils/draft')
const ALIAS_PREFIX = 'ALIAS_'
const PARENT_ALIAS = '_parent_'
const FOREIGN_ALIAS = '_foreign_'
const PARENT_ALIAS_REGEX = new RegExp('^' + PARENT_ALIAS + '\\d*$')
const cleanUpName = name => ensureUnlocalized(name).replace(/\./g, '_')

const _redirectXpr = (xpr, aliasMap) => {
  if (!xpr) return

  xpr.forEach(element => {
    if (element.ref) {
      if (element.ref.length > 1) {
        const view = cleanUpName(element.ref[0])
        if (aliasMap.has(view)) {
          element.ref[0] = aliasMap.get(view)
        }
      }

      return
    }

    if (element.xpr) {
      _redirectXpr(element.xpr, aliasMap)
      return
    }

    if (element.func) {
      _redirectXpr(element.args, aliasMap)
      return
    }

    if (element.list) {
      _redirectXpr(element.list, aliasMap)
      return
    }

    _generateAliases(element, aliasMap)
  })
}

const _redirectRef = (ref, aliasMap) => {
  if (ref.as) {
    aliasMap.set(cleanUpName(ref.ref[0]), ref.as)
  } else {
    ref.as = `${ALIAS_PREFIX}${aliasMap.size + 1}`
    aliasMap.set(cleanUpName(ref.ref[0].id || ref.ref[0]), ref.as)
  }
}

const _generateAliases = (partialCqn, aliasMap = new Map()) => {
  if (partialCqn.SELECT) {
    const selectMap = new Map(aliasMap)
    _generateAliases(partialCqn.SELECT, selectMap)

    _redirectXpr(partialCqn.SELECT.where, selectMap)
    _redirectXpr(partialCqn.SELECT.having, selectMap)
    _redirectXpr(partialCqn.SELECT.columns, selectMap)
    _redirectXpr(partialCqn.SELECT.groupBy, selectMap)
    _redirectXpr(partialCqn.SELECT.orderBy, selectMap)
    return
  }

  if (partialCqn.from) {
    if (partialCqn.from.ref) {
      _redirectRef(partialCqn.from, aliasMap)
    } else {
      _generateAliases(partialCqn.from, aliasMap)
    }

    return
  }

  if (Object.prototype.hasOwnProperty.call(partialCqn, 'join')) {
    partialCqn.args.forEach(arg => {
      if (arg.ref) {
        _redirectRef(arg, aliasMap)
      } else {
        _generateAliases(arg, aliasMap)
      }
    })

    _redirectXpr(partialCqn.on, aliasMap)
    return
  }

  if (partialCqn.SET && partialCqn.SET.op === 'union') {
    partialCqn.SET.args.forEach(arg => {
      _generateAliases(arg, new Map(aliasMap))
    })

    return
  }

  if (partialCqn.xpr) {
    _redirectXpr(partialCqn.xpr, new Map(aliasMap))
  }
}

const generateAliases = query => {
  if (!query.SELECT) return
  _generateAliases(query)
}

const _addParentAlias = (where, alias) => {
  where.forEach(e => {
    if (e.xpr) {
      _addParentAlias(e.xpr, alias)
      return
    }
    if (e.ref && e.ref[0].match(PARENT_ALIAS_REGEX)) {
      e.ref[0] = alias
    }
  })
}

const _addAliasToElement = (expr, alias) => {
  if (expr.ref) {
    if (typeof alias === 'function') {
      alias = alias(expr.ref)
    }

    return { ...expr, ref: [alias, ...expr.ref] }
  }

  if (expr.list) {
    return { list: expr.list.map(arg => _addAliasToElement(arg, alias)) }
  }

  if (expr.func) {
    const args = expr.args.map(arg => _addAliasToElement(arg, alias))
    return { ...expr, args }
  }

  if (expr?.SELECT?.where) {
    // special case in lambda functions
    _addParentAlias(expr.SELECT.where, alias)
  }

  if (expr.xpr) {
    return { xpr: expr.xpr.map(xpr => _addAliasToElement(xpr, alias)) }
  }

  return expr
}

const addAliasToExpression = (expression, alias) => {
  if (expression && alias) {
    return expression.map(expr => _addAliasToElement(expr, alias))
  }

  return expression
}

module.exports = {
  generateAliases,
  addAliasToExpression,
  PARENT_ALIAS,
  FOREIGN_ALIAS
}
