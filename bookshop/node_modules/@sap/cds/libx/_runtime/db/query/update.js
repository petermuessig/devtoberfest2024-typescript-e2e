const cds = require('../../cds')
const preservedSymbol = Symbol('preserved')
const { hasDeepUpdate, getDeepUpdateCQNs, selectDeepUpdateData } = require('../../common/composition')
const { getFlatArray, processCQNs } = require('../utils/deep')
const normalizeTimestamp = require('../../common/utils/normalizeTimestamp')
const onlyKeysRemain = require('../../common/utils/onlyKeysRemain')

const isMoreThanManaged = (cqn, entity) => {
  return (
    cqn[preservedSymbol] ||
    Object.keys(cqn.UPDATE.data).some(
      key =>
        !(key in entity.keys) &&
        (entity.elements[key]['@cds.on.update'] === undefined || !cqn.UPDATE.data[key]?.startsWith('$'))
    )
  )
}

const isManaged = (cqn, entity) => {
  return Object.keys(cqn.UPDATE.data).some(
    key => entity.elements[key]['@cds.on.update'] && cqn.UPDATE.data[key] !== undefined
  )
}

const _getFilteredCqns = (cqns, model) => {
  // right to left processing necessary!
  for (let i = cqns.length - 1; i > 0; i--) {
    const cqn = cqns[i]

    const entity = model && cqn.UPDATE && model.definitions[cqn.UPDATE.entity]
    if (!entity) {
      Object.defineProperty(cqn, preservedSymbol, { value: true })
      continue
    }

    // do not filter if there is a property that is not a key or managed by us (its value starts with $)
    let moreThanManaged = isMoreThanManaged(cqn, entity)

    if (moreThanManaged) {
      Object.defineProperty(cqn, preservedSymbol, { value: true })
      const parentEntity = cqn.parent?.UPDATE && model.definitions[cqn.parent.UPDATE.entity]
      if (parentEntity && isManaged(cqn.parent, parentEntity)) {
        Object.defineProperty(cqn.parent, preservedSymbol, { value: true })
      }
      continue
    }
  }

  const rootCqn = cqns[0]
  if (rootCqn) {
    // no need to process first (= root)
    Object.defineProperty(rootCqn, preservedSymbol, { value: true })
  }

  return cqns.filter(cqn => {
    const entity = model && cqn.UPDATE && model.definitions[cqn.UPDATE.entity]
    if (entity && onlyKeysRemain({ query: cqn, target: entity, data: cqn.UPDATE.data })) {
      return false
    }
    return cqn[preservedSymbol]
  })
}

const update = executeUpdateCQN => async (model, dbc, req) => {
  const { query, user, locale, timestamp } = req
  const isoTs = normalizeTimestamp(timestamp)

  if (model && hasDeepUpdate(model, query)) {
    // REVISIT: avoid additional read
    const selectData = await selectDeepUpdateData(cds.db, model, req)
    const cqns = await getDeepUpdateCQNs(model, req, selectData)

    // the delete chunks, i.e., how many deletes can be processed in parallel
    const chunks = []
    for (const each of cqns) chunks.push(each.filter(e => e.DELETE).length)

    // remove child queries that only want to update @cds.on.update properties
    let _cqns = Array.from(cqns)
    _cqns = getFlatArray(_cqns)
    _cqns = _getFilteredCqns(_cqns, model)

    if (_cqns.length === 0) return 0
    const results = await processCQNs(executeUpdateCQN, _cqns, model, dbc, user, locale, isoTs, chunks)

    // return number of affected rows of "root cqn", if an update, 1 otherwise (as not update of root but its children)
    if (_cqns[0].UPDATE) return results[0]
    return 1
  }

  // REVISIT: don't invoke setters if not needed
  return executeUpdateCQN(model, dbc, query, user, locale, isoTs)
}

module.exports = update
