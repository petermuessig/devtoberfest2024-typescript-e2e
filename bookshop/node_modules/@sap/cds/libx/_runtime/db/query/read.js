const cds = require('../../cds')
const normalizeTimestamp = require('../../common/utils/normalizeTimestamp')
const { deepCopy } = require('../../common/utils/copy')
const getError = require('../../common/error')

function _arrayWithCount(a, count) {
  const _map = a.map
  const map = (..._) => _arrayWithCount(_map.call(a, ..._), count)
  return Object.defineProperties(a, {
    $count: { value: count, enumerable: false, configurable: true, writable: true },
    map: { value: map, enumerable: false, configurable: true, writable: true }
  })
}

function _createCountQuery(query) {
  // REVISIT: Use query.clone() instead
  let _query = { SELECT: deepCopy(query.SELECT) }
  delete _query.SELECT.orderBy // not necessary to keep that
  delete _query.SELECT.limit
  // Also change columns in sub queries
  if (_query.SELECT.from.SET) {
    _query.SELECT.from.SET.args.forEach(subCountQuery => {
      subCountQuery.SELECT.columns = [{ val: 1 }]
    })
  }
  if (query.SELECT.__countAggregated) {
    _query = SELECT.from(_query)
  }
  _query.SELECT.columns = [{ func: 'count', args: [{ val: 1 }], as: '$count' }]
  if (query.SELECT._4odata) _query.SELECT._4odata = true
  return _query
}

const countValue = countResults => {
  if (!countResults.length) return 0
  const countResult = countResults[0]
  if (countResult._counted_ != null) return countResult._counted_
  if (countResult.$count != null) return countResult.$count
}

const read = (executeSelectCQN, executeStreamCQN, convertStreams) => (model, dbc, query, req) => {
  const { user, locale, timestamp } = req
  const isoTs = normalizeTimestamp(timestamp)

  if (cds.env.features.stream_compat && query._streaming) {
    if (!query.SELECT || !query.SELECT.columns) {
      throw getError(500, 'Invalid SELECT statement for streaming')
    }

    return executeStreamCQN({ model, dbc, query, user, locale, isoTs })
  }

  // REVISIT: streaming from OData - to be generalized to all streaming properties
  if (query.SELECT?.columns?.find(col => col.as === '$mediaContentType')) {
    return executeStreamCQN({ model, dbc, query, user, locale, isoTs })
  }

  // needed in case of expand
  if (query._target !== req.target) query._target = req.target

  if (query.SELECT.count) {
    if (query.SELECT.limit) {
      // IMPORTANT: do not change order!
      // 1. create the count query synchronously, because it works on a copy
      // 2. run the result query, duplicate names ( SELECT ID, ID ...) throw an error synchronously
      // 3. run the count query
      // reason is that executeSelectCQN modifies the query
      const countQuery = _createCountQuery(query)
      const resultPromise =
        query.SELECT.limit?.rows?.val === 0
          ? Promise.resolve([])
          : executeSelectCQN(model, dbc, query, user, locale, isoTs)
      const countPromise = executeSelectCQN(model, dbc, countQuery, user, locale, isoTs)

      // use allSettled here, so all executions are awaited before we rollback
      return Promise.allSettled([countPromise, resultPromise]).then(results => {
        const rejection = results.find(p => p.status === 'rejected')
        if (rejection) throw rejection.reason

        const [{ value: countResult }, { value: result }] = results
        return _arrayWithCount(result, countValue(countResult))
      })
    }

    return executeSelectCQN(model, dbc, query, user, locale, isoTs).then(result =>
      _arrayWithCount(result, result.length)
    )
  }

  return executeSelectCQN(model, dbc, query, user, locale, isoTs).then(result => {
    if (!cds.env.features.stream_compat) convertStreams(query.SELECT.columns, query.target, result, query.SELECT.one)

    return result
  })
}

module.exports = read
