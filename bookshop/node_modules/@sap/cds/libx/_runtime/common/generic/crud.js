const cds = require('../../cds')
const { SELECT } = cds.ql

const { deepCopy } = require('../utils/copy')
const { getColumns } = require('../utils/columns')
const { enhanceStreamResult } = require('../utils/stream')
const getError = require('../error')

const _targetEntityDoesNotExist = async req => {
  const exists = await cds.tx(req).run(SELECT.from(req.subject, [1]))
  return exists.length === 0
}

exports.impl = cds.service.impl(function () {
  this.on(['CREATE', 'READ', 'UPDATE', 'DELETE', 'UPSERT'], '*', async function (req) {
    if (!req.query) {
      throw getError({
        code: 501,
        message: 'The request has no query and cannot be served generically.'
      })
    }
    if (typeof req.query !== 'string' && req.target && req.target._hasPersistenceSkip) {
      throw getError({
        code: 501,
        message: `Entity "${req.target.name}" is annotated with "@cds.persistence.skip" and cannot be served generically.`
      })
    }

    // REVISIT: error message
    if (!cds.db) req.reject('NO_DATABASE_CONNECTION')

    let result

    // validate that all elements in path exist on db, if necessary
    // - INSERT has no where clause to do this in one roundtrip
    // - SELECT returns [] -> really empty collection or invalid path?
    let pathExistsQuery

    const { ref } = (req.query.INSERT && req.query.INSERT.into) || (req.query.SELECT && req.query.SELECT.from) || {}
    // REVISIT: why is copy necessary?
    if (ref && ref.length > 1) pathExistsQuery = SELECT(1).from({ ref: deepCopy(ref.slice(0, -1)) })

    if (req.event === 'CREATE' && pathExistsQuery) {
      const res = await pathExistsQuery
      if (res.length === 0) req.reject(404)
    }

    if (req.event in { DELETE: 1, UPDATE: 1 } && req.target && req.target._isSingleton) {
      if (req.event === 'DELETE' && !req.target['@odata.singleton.nullable']) req.reject(400, 'SINGLETON_NOT_NULLABLE')
      const selectSingleton = SELECT.one(req.target)
      const keyColumns = getColumns(req.target, { onlyNames: true, keysOnly: true })

      // if no keys available, select all columns so we can delete the singleton with same content
      if (keyColumns.length) selectSingleton.columns(keyColumns)
      const singleton = await cds.tx(req).run(selectSingleton)
      if (!singleton) req.reject(404)

      // REVISIT: Workaround for singleton, to get keys into singleton
      for (const keyName in singleton) {
        if (!keyColumns.includes(keyName)) continue
        req.data[keyName] = singleton[keyName]
      }

      req.query.where(singleton)
    }

    if (req.event === 'READ' && req.query?.SELECT) {
      req.query.SELECT.localized ??= true
    }

    if (!result) {
      result = await cds.tx(req).run(req.query, req.data)
    }

    if (req.event === 'READ') {
      // do not execute additional select to distinguish between 412 and 404
      if (result == null && req._etagValidationType === 'if-match') req.reject(412)

      if ((result == null || result.length === 0) && pathExistsQuery) {
        const res = await pathExistsQuery
        if (res.length === 0) req.reject(404)
      }

      if (cds.env.features.stream_compat) {
        if (result !== undefined && req.query?._streaming && (result === null || result.pipe)) {
          return { value: result }
        }
      }

      return result
    }

    if (req.event === 'DELETE') {
      if (result === 0) req.reject(req._etagValidationType ? 412 : 404)
      return result
    }

    if (req.event === 'UPDATE' && result === 0) {
      if (req._etagValidationType) req.reject(412)
      if (await _targetEntityDoesNotExist(req)) req.reject(404) // REVISIT: add a reasonable error message
    }

    // flag to trigger read after write in legacy odata adapter
    if (req.constructor.name in { ODataRequest: 1 }) req._.readAfterWrite = true
    if (req.protocol?.match(/odata/)) req._.readAfterWrite = true //> REVISIT for noah

    return req.data
  })

  this.after('READ', '*', async function ([result], req) {
    if (!result) return
    if (cds.env.features.stream_compat) {
      if (req.query?._streaming) {
        await enhanceStreamResult(req, req.query, result, this.model)
      }
    }
  })
})
