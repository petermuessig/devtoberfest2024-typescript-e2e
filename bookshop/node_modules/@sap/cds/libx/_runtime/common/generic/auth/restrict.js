const cds = require('../../../cds')

const { reject, getRejectReason, resolveUserAttrs, getAuthRelevantEntity } = require('./utils')
const { DRAFT_EVENTS, MOD_EVENTS } = require('./constants')
const { getNormalizedPlainRestrictions } = require('./restrictions')

const { cqn2cqn4sql } = require('../../utils/cqn2cqn4sql')

const _getResolvedApplicables = (applicables, req) => {
  const resolvedApplicables = []

  // REVISIT: the static portion of "mixed wheres" could already grant access -> optimization potential
  for (const restrict of applicables) {
    let resolved
    if (restrict.where) {
      let xpr
      if (typeof restrict.where === 'string') {
        xpr = cds.parse.expr(restrict.where).xpr
        if (!xpr)
          req.reject(400, `Exists predicate is missing in the association path "${restrict.where}" in @restrict.where`)
      } else {
        xpr = JSON.parse(JSON.stringify(restrict.where))
      }

      resolved = {
        grant: restrict.grant,
        target: restrict.target,
        where: restrict.where,
        // replace $user.x with respective values
        _xpr: resolveUserAttrs(xpr, req)
      }
    }

    resolvedApplicables.push(resolved || restrict)
  }

  return resolvedApplicables
}

const _getStaticAuthRestrictions = resolvedApplicables => {
  return resolvedApplicables.filter(
    resolved => resolved && resolved._xpr.length === 3 && resolved._xpr.every(ele => typeof ele !== 'object' || ele.val)
  )
}

const _evalStatic = (op, vals) => {
  vals[0] = Number.isNaN(Number(vals[0])) ? vals[0] : Number(vals[0])
  vals[1] = Number.isNaN(Number(vals[1])) ? vals[1] : Number(vals[1])

  switch (op) {
    case '=':
      return vals[0] === vals[1]
    case '!=':
    case '<>':
      return vals[0] !== vals[1]
    case '<':
      return vals[0] < vals[1]
    case '<=':
      return vals[0] <= vals[1]
    case '>':
      return vals[0] > vals[1]
    case '>=':
      return vals[0] >= vals[1]
    default:
      throw new Error(`Operator "${op}" is not supported in @restrict.where`)
  }
}

const _handleStaticAuthRestrictions = (resolvedApplicables, req) => {
  const isAllowed = resolvedApplicables.some(restriction => {
    const op = restriction._xpr.find(ele => typeof ele === 'string')
    const vals = restriction._xpr.filter(ele => typeof ele === 'object' && ele.val).map(ele => ele.val)
    return _evalStatic(op, vals)
  })
  // static clause grants access => done
  if (isAllowed) return

  // static clause forbids access => forbidden
  return reject(req)
}

const _getMergedWhere = restricts => {
  const xprs = []
  restricts.forEach(ele => {
    if (xprs.length) {
      xprs.push('or')
    }
    xprs.push({ xpr: [...ele._xpr] })
  })
  return restricts.length > 1 ? [{ xpr: [...xprs] }] : xprs
}

const _addWheresToRef = (ref, model, resolvedApplicables) => {
  const newRef = []
  let lastEntity = model.definitions[ref[0].id || ref[0]]

  ref.forEach((identifier, idx) => {
    if (idx === ref.length - 1) {
      newRef.push(identifier)
      return // determine last one separately
    }

    const entity = idx === 0 ? lastEntity : lastEntity.elements[identifier.id || identifier]._target
    lastEntity = entity
    const applicablesForEntity = resolvedApplicables.filter(
      restrict => restrict.target && restrict.target.name === entity.name
    )

    let newIdentifier = identifier

    if (applicablesForEntity.length) {
      if (typeof newIdentifier === 'string') {
        newIdentifier = { id: identifier, where: [] }
      }

      if (!newIdentifier.where) newIdentifier.where = []

      if (newIdentifier.where && newIdentifier.where.length) {
        newIdentifier.where = [{ xpr: newIdentifier.where }, 'and']
      }

      for (const val of _getMergedWhere(applicablesForEntity)) newIdentifier.where.push(val)
    }

    newRef.push(newIdentifier)
  })

  return newRef
}

const _getRestrictionForTarget = (resolvedApplicables, target) => {
  const reqTarget = target && (target._isDraftEnabled ? target.name.replace(/_drafts$/, '') : target.name)
  const applicablesForTarget = resolvedApplicables.filter(
    restrict => restrict.target && restrict.target.name === reqTarget
  )

  if (applicablesForTarget.length) {
    return _getMergedWhere(applicablesForTarget)
  }
}

const _addRestrictionsToRead = async (req, model, resolvedApplicables) => {
  // in case of $apply take a query from sub SELECT
  let query = req.query
  while (query.SELECT.from.SELECT) {
    query = query.SELECT.from
  }

  query.SELECT.from.ref = _addWheresToRef(query.SELECT.from.ref, model, resolvedApplicables)

  const restrictionForTarget = _getRestrictionForTarget(resolvedApplicables, req.target)
  if (!restrictionForTarget) return

  query.where(restrictionForTarget)
}

const _getUnrestrictedCount = async req => {
  const dbtx = cds.tx(req)
  const target =
    (req.query.UPDATE && req.query.UPDATE.entity) ||
    (req.query.DELETE && req.query.DELETE.from) ||
    (req.query.SELECT && req.query.SELECT.from)
  const selectUnrestricted = SELECT.one(['count(*) as n']).from(target)
  const whereUnrestricted = (req.query.UPDATE && req.query.UPDATE.where) || (req.query.DELETE && req.query.DELETE.where)

  if (whereUnrestricted) selectUnrestricted.where(whereUnrestricted)

  // Because of side effects, the statements have to be fired sequentially.
  const { n } = await dbtx.run(selectUnrestricted)
  return n
}

const _getRestrictedCount = async (req, model, resolvedApplicables) => {
  const dbtx = cds.tx(req)
  const target =
    (req.query.UPDATE && req.query.UPDATE.entity) ||
    (req.query.DELETE && req.query.DELETE.from) ||
    (req.query.SELECT && req.query.SELECT.from)
  const selectRestricted = SELECT.one(['count(*) as n']).from(target)
  const whereRestricted = (req.query.UPDATE && req.query.UPDATE.where) || (req.query.DELETE && req.query.DELETE.where)

  if (whereRestricted) selectRestricted.where(whereRestricted)

  if (typeof selectRestricted.SELECT === 'object') {
    selectRestricted.SELECT.from.ref = _addWheresToRef(selectRestricted.SELECT.from.ref, model, resolvedApplicables)
  }

  const restrictionForTarget = _getRestrictionForTarget(resolvedApplicables, req.target)
  if (restrictionForTarget) selectRestricted.where(restrictionForTarget)

  const { n } = await dbtx.run(cqn2cqn4sql(selectRestricted, model, { suppressSearch: true }))
  return n
}

async function check_roles(req) {
  if (req.user._is_privileged || DRAFT_EVENTS[req.event]) {
    // > skip checks (events in DRAFT_EVENTS are checked in draft handlers via InProcessByUser)
    return
  }

  const authRelevantEntity = getAuthRelevantEntity(req, this.model, ['@requires', '@restrict'])
  const definition =
    authRelevantEntity ||
    (req.target && req.target.actions && req.target.actions[req.event]) ||
    (this.operations && this.operations[req.event])

  if (!definition) {
    // > nothing to restrict
    return
  }

  // READ UPDATE DELETE on draft enabled entities are unrestricted, because only the owner can access them
  const draftUnRestrictedEvents = ['READ', 'UPDATE', 'DELETE', 'CREATE']
  if (definition.isDraft && draftUnRestrictedEvents.includes(req.event)) {
    return
  }

  let restrictions = this.getRestrictions.call(this, definition, req.event, req.user)
  if (restrictions instanceof Promise) restrictions = await restrictions

  if (!restrictions) {
    // > unrestricted
    return
  }

  if (!restrictions.length) {
    // > no applicable restrictions -> 403
    reject(req, getRejectReason(req, '@restrict', definition))
  }
  // normalize
  restrictions = getNormalizedPlainRestrictions(restrictions, definition)
  // at least one if the user's roles grants unrestricted access => done
  if (restrictions.some(restrict => !restrict.where)) return

  const resolvedApplicables = _getResolvedApplicables(restrictions, req)

  // REVISIT: support more complex statics
  const staticAuthRestriction = _getStaticAuthRestrictions(resolvedApplicables)
  if (staticAuthRestriction.length > 0) {
    return _handleStaticAuthRestrictions(staticAuthRestriction, req)
  }

  if (req.event === 'READ') {
    _addRestrictionsToRead(req, this.model, resolvedApplicables)
    return
  }

  // no modification -> nothing more to do
  if (!MOD_EVENTS[req.event]) return

  // REVISIT: selected data could be used for etag check, diff, etc.

  /*
   * Here we check if UPDATE/DELETE requests add additional restrictions
   * Note: Needs to happen sequentially because of side effects
   */
  // REVISIT: Do we really need to do that? Always?
  const unrestrictedCount = await _getUnrestrictedCount(req)
  if (unrestrictedCount === 0) req.reject(404)

  const restrictedCount = await _getRestrictedCount(req, this.model, resolvedApplicables)

  if (restrictedCount < unrestrictedCount) {
    reject(req, getRejectReason(req, '@restrict', definition, restrictedCount, unrestrictedCount))
  }
}

check_roles._initial = true

module.exports = check_roles
