const { cqnFrom } = require('./utils')
const { RESTRICTIONS } = require('./constants')

const _getRestriction = (req, capability, capabilityReadByKey) => {
  if (capabilityReadByKey !== undefined && req.query.SELECT?.one) {
    return capabilityReadByKey
  }
  return capability
}

const _getNavigationRestriction = (target, path, annotation, req) => {
  if (!target) return
  if (!Array.isArray(target['@Capabilities.NavigationRestrictions.RestrictedProperties'])) return

  const [restriction, operation] = annotation.split('.')
  for (const r of target['@Capabilities.NavigationRestrictions.RestrictedProperties']) {
    // prefix check to support both notations: { InsertRestrictions: { Insertable: false } } and { InsertRestrictions.Insertable: false }
    // however, { InsertRestrictions.Insertable: false } is actually not supported bc compiler does not expand shorthands inside an annotation
    if (r.NavigationProperty['='] === path && Object.keys(r).some(k => k.startsWith(restriction))) {
      const capability = r[annotation] ?? r[restriction]?.[operation]
      const capabilityReadByKey =
        r.ReadRestrictions?.['ReadByKeyRestrictions.Readable'] ?? r.ReadRestrictions?.ReadByKeyRestrictions?.Readable
      return _getRestriction(req, capability, capabilityReadByKey)
    }
  }
}

const _localName = entity => entity.name.replace(entity._service.name + '.', '')

const _getNav = from => {
  if (from?.SELECT) return _getNav(from.SELECT.from)
  if (from?.ref) return from.ref.map(el => el.id || el)
  return []
}

function handler(req) {
  // TODO: Determine auth-relevant entity
  const annotation = RESTRICTIONS[req.event]

  if (!req.target || !annotation) return

  const action = annotation.split('.').pop().toUpperCase()
  const from = cqnFrom(req)
  const nav = _getNav(from)

  let navRestriction
  if (nav.length > 1) {
    const navs = nav.slice(1)
    let lastTarget, target, element, navigation, path
    target = this.model.definitions[nav[0]]
    for (let i = 0; i < navs.length && target; i++) {
      element = !element || element.isAssociation ? target.elements[navs[i]] : element.elements[navs[i]]
      if (element.isAssociation) {
        navigation = path ? `${path}.${navs[i]}` : navs[i]
        path = undefined
        lastTarget = target
        target = this.model.definitions[element.target]
      } else {
        path = path ? `${path}.${navs[i]}` : navs[i]
      }
    }
    if (lastTarget && navigation) {
      navRestriction = _getNavigationRestriction(lastTarget, navigation, annotation, req)
    }
    if (navRestriction === false) {
      // REVISIT: rework exception with using target
      const trgt = `${_localName(lastTarget)}.${navs.join('.')}`
      req.reject(405, 'ENTITY_IS_NOT_CRUD_VIA_NAVIGATION', [_localName(req.target), action, trgt])
    }
  }

  if (
    !navRestriction &&
    _getRestriction(
      req,
      req.target['@Capabilities.' + annotation],
      req.target['@Capabilities.' + RESTRICTIONS.READABLE_BY_KEY]
    ) === false
  ) {
    req.reject(405, 'ENTITY_IS_NOT_CRUD', [_localName(req.target), action])
  }
}

handler._initial = true

module.exports = handler
