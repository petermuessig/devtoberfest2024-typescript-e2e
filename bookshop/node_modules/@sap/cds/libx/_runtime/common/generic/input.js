/*
 * Input handler on application service layer
 *
 * - remove readonly fields
 * - remove immutable fields on update
 * - add UUIDs
 * - asserts
 */

const cds = require('../../cds')
const LOG = cds.log('app')

const { enrichDataWithKeysFromWhere } = require('../utils/keys')
const { DRAFT_COLUMNS_MAP } = require('../../common/constants/draft')
const propagateForeignKeys = require('../utils/propagateForeignKeys')
const { checkInputConstraints, assertTargets } = require('../../cds-services/util/assert')
const getTemplate = require('../utils/template')
const { getDataFromCQN, setDataFromCQN } = require('../utils/data')
const getRowUUIDGeneratorFn = require('../utils/rowUUIDGenerator')

const _shouldSuppressErrorPropagation = (event, value) => {
  return (
    event === 'NEW' ||
    event === 'PATCH' ||
    (event === 'UPDATE' && value.val === undefined) ||
    (value.val == null && !value.mandatory)
  )
}

const _getSimpleCategory = category => {
  if (typeof category === 'object') {
    category = category.category
  }

  return category
}

const _preProcessAssertTarget = (assocInfo, assertMap) => {
  const { element: assoc, row } = assocInfo
  const assocTarget = assoc._target

  // it is expected that the associated entities be defined in the same service
  if (assoc.parent._service !== assocTarget._service) {
    LOG._warn && LOG.warn('Cross-service checks for the @assert.target constraint are not supported.')
    return
  }

  const foreignKeys = assoc._foreignKeys
  let mapKey = `${assocTarget.name}(`
  const hasOwn = Object.prototype.hasOwnProperty
  const parentKeys = []

  foreignKeys.forEach(keyMap => {
    const { childElement, parentElement } = keyMap

    // don't assert target if the foreign key isn't in the payload
    if (!hasOwn.call(row, parentElement.name)) return

    const foreignKeyValue = row[parentElement.name]

    // don't assert target if the foreign key value is null
    if (foreignKeyValue === null) return

    mapKey += `${childElement.name}=${foreignKeyValue},`
    parentKeys.push({
      [childElement.name]: foreignKeyValue
    })
  })
  mapKey += `)`

  if (parentKeys.length === 0) return

  foreignKeys.forEach(keyMap => {
    const clonedAssocInfo = Object.assign({}, assocInfo, { pathSegmentsInfo: assocInfo.pathSegmentsInfo.slice(0) })
    const target = {
      key: mapKey,
      entity: assocTarget,
      keys: parentKeys,
      assocInfo: clonedAssocInfo,
      foreignKey: keyMap.parentElement
    }

    if (!assertMap.targets.has(mapKey)) {
      assertMap.targets.set(mapKey, target)
    }

    assertMap.allTargets.push(target)
  })
}

const _processCategory = (req, category, value, elementInfo, assertMap) => {
  const { row, key, element, isRoot } = elementInfo
  category = _getSimpleCategory(category)

  if (category === 'propagateForeignKeys') {
    propagateForeignKeys(key, row, element._foreignKeys, element.isComposition, { enumerable: false })
    return
  }

  // remember mandatory
  if (category === 'mandatory') {
    value.mandatory = true
    return
  }

  const event = req.event

  // remove readonly (can also be complex, so do first)
  if (category === 'readonly') {
    // preserve computed values if triggered by draftActivate and not managed
    const managed = `@cds.on.${event === 'CREATE' ? 'insert' : 'update'}`
    if (cds.env.features.preserve_computed !== false && req._?.event === 'draftActivate' && !element[managed]) return

    // read-only values are already deleted before `NEW` (and they can be set in a `NEW` handler!)
    if (event === 'CREATE' && req.target.isDraft) return

    delete row[key]
    value.val = undefined
    return
  }

  // remove immutable (can also be complex, so do first)
  // for new db drivers (cds.db.cqn2sql is defined), deep immutable values are handled in differ
  // otherwise they're not supported and always filtered out here.
  if (category === 'immutable' && event === 'UPDATE' && (isRoot || !cds.db.cqn2sql)) {
    delete row[key]
    value.val = undefined
    return
  }

  // generate UUIDs
  if (
    category === 'uuid' &&
    !value.val &&
    ((event !== 'UPDATE' && event !== 'PATCH') || !isRoot) &&
    !element.parent.elements[element._foreignKey4]?._isAssociationStrict
  ) {
    value.val = row[key] = cds.utils.uuid()
  }

  // @assert.target
  if ((event === 'UPDATE' || event === 'CREATE') && category === '@assert.target') {
    _preProcessAssertTarget(elementInfo, assertMap)
  }
}

const _getProcessorFn = (req, errors, assertMap) => {
  const event = req.event

  return elementInfo => {
    const { row, key, element, plain, pathSegmentsInfo } = elementInfo
    // ugly pointer passing for sonar
    const value = { mandatory: false, val: row && row[key] }

    for (const category of plain.categories) {
      _processCategory(req, category, value, elementInfo, assertMap)
    }

    if (_shouldSuppressErrorPropagation(event, value)) return

    // REVISIT: Convert checkInputConstraints to template mechanism
    checkInputConstraints({ element, value: value.val, errors, pathSegmentsInfo, event })
  }
}

// params: element, target, parent
const _pick = element => {
  // collect actions to apply
  const categories = []

  // REVISIT: element._foreignKeys.length seems to be a very broad check
  if (element.isAssociation && element._foreignKeys.length) {
    categories.push({ category: 'propagateForeignKeys' })
  }

  // some checks are not needed if cds_validate is active (the default in cds^8)
  if (!cds.env.features.cds_validate) {
    if (element['@assert.range'] || element['@assert.format'] || element.type === 'cds.Decimal') {
      categories.push('assert')
    }

    if (element._isMandatory) {
      categories.push('mandatory')
    }

    if (element._isReadOnly) {
      // > _isReadOnly includes @cds.on.insert and @cds.on.update
      categories.push('readonly')
    }
  }

  // REVISIT: cleanse @Core.Immutable
  //          should be a db feature, as we cannot handle completely on service level (cf. deep update)
  //          -> add to attic env behavior once new dbs handle this
  if (element['@Core.Immutable']) {
    categories.push('immutable')
  }

  if (element.key && !DRAFT_COLUMNS_MAP[element.name] && element.isUUID) {
    categories.push('uuid')
  }

  if (element['@Core.IsMediaType']) {
    categories.push('stream')
  }

  if (
    element._isAssociationStrict &&
    !element.on && // managed assoc
    element.is2one &&
    element['@assert.target'] === true
  ) {
    categories.push('@assert.target')
  }

  if (categories.length) return { categories }
}

// REVISIT: needed only for draftActivate with old adapter -> remove with okra
const _getBoundAction = req => req.target.actions?.[req._?.event || req.context?.event]
const _getBoundActionBindingParameter = action => action['@cds.odata.bindingparameter.name'] || 'in'

async function commonGenericInput(req) {
  if (!req.query) return // FIXME: the code below expects req.query to be defined
  if (!req.target) return

  // validate data
  if (cds.env.features.cds_validate) {
    const assertOptions = { mandatories: req.event === 'CREATE' || req.req?.method === 'PUT' }

    const _is_activate = req._?.event === 'draftActivate' && cds.env.features.preserve_computed !== false
    const _is_create_after_new = req.target.isDraft && req.event === 'CREATE'
    if (_is_activate || _is_create_after_new) assertOptions.cleanse = false

    // REVISIT: initialize path if necessary (currently only done in lean-draft -> correct?)
    const bound = req.target.actions?.[req.event] || req.target.actions?.[req._.event]
    if (bound) assertOptions.path = [bound['@cds.odata.bindingparameter.name'] || 'in']

    const errs = cds.validate(req.data, req.target, assertOptions)
    if (errs) {
      if (errs.length === 1) throw errs[0]
      throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
    }
  }

  const template = getTemplate('app-input', this, req.target, {
    pick: _pick,
    ignore: element => element._isAssociationStrict
  })
  if (template.elements.size === 0) return

  const errors = []
  const assertMap = {
    targets: new Map(),
    allTargets: []
  }

  const pathOptions = {
    rowUUIDGenerator: getRowUUIDGeneratorFn(req.event),
    includeKeyValues: true,
    pathSegmentsInfo: []
  }

  // REVISIT: needed only for correct error target in case of draftActivate with old adapter -> remove with okra
  const boundAction = _getBoundAction(req)

  if (boundAction) {
    const pathSegment = _getBoundActionBindingParameter(boundAction)
    if (pathSegment) pathOptions.pathSegmentsInfo.push(pathSegment)
    const keys = req.params?.[0]
    if (keys && 'IsActiveEntity' in keys) {
      pathOptions.draftKeys = { IsActiveEntity: keys.IsActiveEntity }
    }
  }

  const data = getDataFromCQN(req.query) // REVISIT: req.data should point into req.query
  enrichDataWithKeysFromWhere(data, req, this)

  template.process(data, _getProcessorFn(req, errors, assertMap), pathOptions)

  if (assertMap.targets.size > 0) {
    await assertTargets(assertMap, errors)
  }

  setDataFromCQN(req) // REVISIT: req.data should point into req.query

  if (errors.length) for (const error of errors) req.error(error)
}

const _getProcessorFnForActionsFunctions =
  (errors, opName) =>
  ({ row, key, element }) => {
    const value = row && row[key]

    // REVISIT: Convert checkInputConstraints to template mechanism
    checkInputConstraints({ element, value, errors, key: opName })
  }

const _processActionFunctionRow = (row, param, key, errors, event, service) => {
  const values = Array.isArray(row[key]) ? row[key] : [row[key]]

  // unstructured
  for (const value of values) {
    checkInputConstraints({ element: param, value, errors, key })
  }

  // structured
  const template = getTemplate('app-input-operation', service, param, {
    pick: _pick,
    ignore: element => element._isAssociationStrict
  })

  template.process(values, _getProcessorFnForActionsFunctions(errors, key))
}

const _processActionFunction = (row, eventParams, errors, event, service) => {
  for (const key in eventParams) {
    let param = eventParams[key]

    // .type of action/function behaves different to .type of other csn elements
    const _type = param.type
    if (!_type && param.items) param = param.items
    _processActionFunctionRow(row, param, key, errors, event, service)
  }
}

const _getOperation = (req, service) => {
  // in bound case
  if (req.target) {
    if (req.target.actions && req.target.actions[req.event]) {
      return req.target.actions[req.event]
    }

    return req.target.functions[req.event]
  }

  // in unbound case
  return service.model.definitions[`${service.definition.name}.${req.event}`]
}

function _actionFunctionHandler(req) {
  const operation = _getOperation(req, this)
  if (!operation) return

  const data = req.data || {}

  // validate data
  if (cds.env.features.cds_validate) {
    const assertOptions = { mandatories: true }
    let errs = cds.validate(data, operation, assertOptions)
    if (errs) {
      if (errs.length === 1) throw errs[0]
      throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
    }
  }

  // REVISIT: the below is still needed if !cds.env.features.cds_validate because cds.validate doesn't throw missing mandatory struct.
  //          look for comment "skip struct-likes as we check flat payloads above, and deep payloads via struct.validate()".
  //          structured params are _not_ flattened and, hence, the assumption in the comment is incorrect (or the flattening must be done).
  const errors = []
  const arrayData = Array.isArray(data) ? data : [data]
  for (const row of arrayData) _processActionFunction(row, operation.params, errors, req.event, this)
  if (errors.length) for (const error of errors) req.error(error)
}

commonGenericInput._initial = true
_actionFunctionHandler._initial = true

module.exports = cds.service.impl(function () {
  this.before(['CREATE', 'UPDATE'], '*', commonGenericInput)

  const operationNames = []

  for (const operation of this.operations) {
    operationNames.push(operation.name.substring(this.name.length + 1))
  }

  if (operationNames.length > 0) {
    this.before(operationNames, _actionFunctionHandler)
  }

  for (const entity of this.entities) {
    const boundOps = []

    if (entity.actions) {
      boundOps.push(...Object.keys(entity.actions))
    }

    if (entity.functions) {
      boundOps.push(...Object.keys(entity.functions))
    }

    if (boundOps.length > 0) {
      this.before(boundOps, entity.name, _actionFunctionHandler)
    }
  }
})

// needed for testing
module.exports.commonGenericInput = commonGenericInput
