const { prefixForStruct } = require('./csn')

const _toRef = (alias, column) => {
  if (Array.isArray(column)) column = column.join('_')
  return { ref: alias ? [alias, column] : [column] }
}

const _adaptRefs = (onCond, path, { select, join }) => {
  const _adaptEl = el => {
    const ref = el.ref

    if (ref) {
      if (ref[0] === path.join('_') && ref[1]) {
        return _toRef(select, ref.slice(1))
      }

      // no alias for special $user of canonical localized association
      if (ref[0] === '$user' && path[0] === 'localized') {
        return _toRef(undefined, ref.slice(0))
      }

      return _toRef(join, ref.slice(0))
    }

    if (el.xpr) return { xpr: el.xpr.map(_adaptEl) }
    return el
  }

  return onCond.map(_adaptEl)
}

const replace$selfAndAliasOnCOnd = (xpr, csnElement, aliases, path) => {
  const selfIndex = xpr.findIndex(({ ref }) => ref?.[0] === '$self')
  if (selfIndex != -1) {
    let backLinkIndex
    if (xpr[selfIndex + 1] && xpr[selfIndex + 1] === '=') backLinkIndex = selfIndex + 2
    if (xpr[selfIndex - 1] && xpr[selfIndex - 1] === '=') backLinkIndex = selfIndex - 2
    if (backLinkIndex != null) {
      const ref = xpr[backLinkIndex].ref
      const backlinkName = ref[ref.length - 1]
      const mutOnCond = _newOnConditions(csnElement._backlink, [backlinkName], {
        select: aliases.join,
        join: aliases.select
      })

      xpr.splice(Math.min(backLinkIndex, selfIndex), 3, ...mutOnCond)
    }
  }

  for (let i = 0; i < xpr.length; i++) {
    const element = xpr[i]
    if (element.xpr) {
      replace$selfAndAliasOnCOnd(element.xpr, csnElement, aliases, path)
      continue
    }

    if (element.ref) {
      if (element.ref[0] === path.join('_') && element.ref[1]) {
        element.ref = _toRef(aliases.select, element.ref.slice(1)).ref
        continue
      }

      // no alias for special $user of canonical localized association
      if (element.ref[0] === '$user' && path[0] === 'localized') {
        element.ref = _toRef(undefined, element.ref.slice(0)).ref
        continue
      }

      if (element.ref[0] === aliases.join || element.ref[0] === aliases.select) {
        // nothing todo here, as already right alias
        continue
      }

      element.ref = _toRef(aliases.join, element.ref.slice(0)).ref
    }
  }
}

const _args = (csnElement, path, aliases) => {
  const onCond = csnElement.on
  if (!onCond || onCond.length === 0) return []
  if (onCond.length < 3 && !onCond[0]?.xpr) return onCond
  if (!csnElement._isSelfManaged) return _adaptRefs(onCond, path, aliases)

  const onCondCopy = JSON.parse(JSON.stringify(onCond))
  replace$selfAndAliasOnCOnd(onCondCopy, csnElement, aliases, path)

  return onCondCopy
}

// this is only for 2one managed w/o on-conditions, i.e. no static values are possible
const _foreignToOn = (csnElement, path, { select, join }) => {
  const on = []

  for (const key of csnElement._foreignKeys) {
    if (on.length !== 0) {
      on.push('and')
    }

    const prefixChild = prefixForStruct(key.childElement)
    const ref1 = _toRef(select, prefixChild + key.childElement.name)
    const structPrefix = path.length > 1 ? path.slice(0, -1) : []
    const ref2 = _toRef(join, [...structPrefix, key.parentElement.name])
    on.push(ref1, '=', ref2)
  }

  return on
}

const _newOnConditions = (csnElement, path, aliases) => {
  if (csnElement.keys) {
    return _foreignToOn(csnElement, path, aliases)
  }

  return _args(csnElement, path, aliases)
}

const getOnCond = (csnElement, path = [], aliases = { select: '', join: '' }) => {
  const onCond = _newOnConditions(csnElement, path, aliases)
  return [{ xpr: onCond }]
}

module.exports = { getOnCond }
