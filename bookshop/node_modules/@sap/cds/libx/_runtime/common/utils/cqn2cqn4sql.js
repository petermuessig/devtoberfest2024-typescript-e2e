const cds = require('../../cds')
const { SELECT, INSERT, DELETE, UPDATE } = cds.ql
const Query = require('../../../../lib/ql/Query')
const { resolveView } = require('./resolveView')
const { ensureNoDraftsSuffix, getDraftColumnsCQNForDraft, ensureDraftsSuffix } = require('./draft')
const { flattenStructuredSelect, OPERATIONS_MAP } = require('./structured')
const search2cqn4sql = require('./search2cqn4sql')
const { getEntityNameFromCQN } = require('./entityFromCqn')
const getError = require('../../common/error')
const { rewriteAsterisks } = require('./rewriteAsterisks')
const { getEntityFromPath } = require('../../common/utils/path')
const { addRefToWhereIfNecessary } = require('../../../odata/utils')
const { addAliasToExpression, PARENT_ALIAS, FOREIGN_ALIAS } = require('../../db/utils/generateAliases')
const { getColumns } = require('./columns')

const _elementFromRef = (name, entity) => {
  if (!entity) return

  if (entity.elements) {
    return entity.elements[_getTargetFromRef(name)]
  }
}

const _getTargetFromRef = ref => ref.id || ref

const _getEntityName = (fromClause, entity, i) => {
  const targetName = _getTargetFromRef(fromClause.ref[i])
  return i === 0 ? targetName : entity && entity.elements[targetName] && entity.elements[targetName].target
}

const convertPathExpressionToWhere = (fromClause, model, options) => {
  if (!fromClause.ref) return

  if (fromClause.ref.length === 1) {
    const target = _getTargetFromRef(fromClause.ref[0])
    const alias = fromClause.as
    const { where, cardinality, args } = fromClause.ref[0]
    return { target, alias, where, cardinality, args }
  }

  let previousSelect, previousEntityName, previousTableAlias, structParent, previousArgs, draft
  let prefix = []
  let columns
  for (let i = 0; i < fromClause.ref.length; i++) {
    const entity = structParent || (previousEntityName && model.definitions[ensureNoDraftsSuffix(previousEntityName)])
    const element = _elementFromRef(fromClause.ref[i], entity)

    if (element && element._isStructured) {
      prefix.push(element.name)
      structParent = element
      continue
    } else if (element && element.isAssociation) {
      if (element._isAssociationStrict && !element['@odata.draft.enclosed']) draft = false
      _modifyNavigationInWhere(fromClause.ref[i].where, element._target)
    } else if (element && previousSelect && i === fromClause.ref.length - 1) {
      columns = [{ ref: [...prefix, element.name] }]
      fromClause.ref.splice(-1)
      continue
    }

    const entityName = _getEntityName(fromClause, entity, i)
    const currentEntityName = draft ? entityName && ensureDraftsSuffix(entityName) : entityName
    if (!currentEntityName) continue
    if (!draft && currentEntityName.endsWith('_drafts')) draft = true
    const tableAlias = options.tableAliasPrefix ? `${options.tableAliasPrefix}${i}` : `T${i}`
    const currentSelect = SELECT.from({ ref: [currentEntityName], as: tableAlias })

    if (fromClause.ref[i].where) {
      currentSelect.where(addAliasToExpression(fromClause.ref[i].where, tableAlias))
    }

    // REVISIT: Only args in last segment are handled, intermediate ones are ignored
    const currentArgs = fromClause.ref[i].args

    if (i !== fromClause.ref.length - 1) {
      currentSelect.columns([1])
    }

    if (previousSelect) {
      const navigation = _getTargetFromRef(fromClause.ref[i])
      previousSelect.where(
        model.definitions[ensureNoDraftsSuffix(previousEntityName)]._relations[[...prefix, navigation]].join(
          tableAlias,
          previousTableAlias
        )
      )
      _convertSelect(previousSelect, model, options)
      currentSelect.where('exists', previousSelect)
    }

    structParent = undefined
    prefix = []
    previousTableAlias = tableAlias
    previousSelect = currentSelect
    previousEntityName = currentEntityName
    previousArgs = currentArgs
  }

  return {
    target: previousEntityName,
    alias: previousTableAlias,
    where: previousSelect && previousSelect.SELECT && previousSelect.SELECT.where,
    args: previousArgs,
    columns
  }
}

const _convertPathExpressionForInsert = (intoClause, model) => {
  // .into is plain string or csn entity
  if (typeof intoClause === 'string' || intoClause.name) {
    return intoClause
  }

  return intoClause.ref.reduce((res, curr, i) => {
    if (i === 0) {
      return curr.id || curr
    }

    return model.definitions[res].elements[curr.id || curr].target
  }, '')
}

const _getBottomTopRefOrVal = (func, refVal) => func.args.filter(el => el[refVal])

const _getWindowWhere = (where, bottomTop) => {
  const windWhere = where || []
  const bottomTopVal = _getBottomTopRefOrVal(bottomTop[0], 'val')[0]
  bottomTopVal.val = parseInt(bottomTopVal.val, 10)

  if (windWhere.length > 0) {
    windWhere.push('and')
  }

  windWhere.push({ ref: ['rowNumber'] }, '<=', bottomTopVal)
  return windWhere
}

const _getOrderByForWindowFn = bottomTop => {
  const orderBy = _getBottomTopRefOrVal(bottomTop[0], 'ref')[0]
  const sort = bottomTop[0].func === 'topcount' ? 'desc' : 'asc'
  return [orderBy, sort]
}

const _getWindowXpr = (groupBy, bottomTop) => {
  const overXpr = { xpr: [] }
  const xpr = [{ func: 'ROW_NUMBER', args: [] }, 'OVER', overXpr]

  if (groupBy)
    overXpr.xpr.push(
      'PARTITION BY',
      ...groupBy.reduce((acc, el, i) => {
        if (i < groupBy.length - 1) {
          acc.push(el)
          acc.push(',')
        } else {
          acc.push(el)
        }

        return acc
      }, [])
    )

  overXpr.xpr.push('ORDER BY', ..._getOrderByForWindowFn(bottomTop))
  return { xpr, as: 'rowNumber' }
}

const _isNavCountFunc = el => el.func && el.func === 'count' && el.args[0] !== '*'
const _isCountNavigation = columns => columns.some(_isNavCountFunc)
const _isBottomTop = columns => columns.some(el => el.func && (el.func === 'topcount' || el.func === 'bottomcount'))
const _getWindColumns = (columns, groupBy, bottomTop) => [].concat(columns, _getWindowXpr(groupBy, bottomTop))

const _convertCountNavigation = (SELECT, target) => {
  const newWhere = []
  for (let i = 0; i < SELECT.where.length; i++) {
    const element = SELECT.where[i]

    if (!element.func) {
      newWhere.push(element)
      continue
    }

    if (SELECT.from.as && SELECT.from.as === element.args[0].ref[0]) element.args[0].ref.shift()
    const navigations = element.args[0].ref
    const navigationName = navigations[0].id || navigations[0]
    if (target.elements[navigationName]) {
      let currentEntity = target
      let topQuery
      let lastQuery

      for (let j = 0; j < navigations.length; j++) {
        if (navigations[j].where) {
          addRefToWhereIfNecessary(navigations[j].where, currentEntity)
        }

        const nextNavigation = navigations[j]
        const nestedExistsQuery = _buildExistsQuery(
          currentEntity,
          nextNavigation,
          j > 0 ? `ALIAS_${j - 1}` : currentEntity.name,
          `ALIAS_${j}`
        )
        if (!topQuery) {
          topQuery = nestedExistsQuery
        }

        const nestedNavigationName = nextNavigation.id || nextNavigation
        if (j === navigations.length - 1) {
          nestedExistsQuery.columns('count(1) as counted')

          if (lastQuery) {
            lastQuery.where([nestedExistsQuery, SELECT.where[i + 1], SELECT.where[i + 2]])
            newWhere.push('exists', topQuery)
          } else {
            newWhere.push(nestedExistsQuery, SELECT.where[i + 1], SELECT.where[i + 2])
          }
        } else {
          if (lastQuery) {
            lastQuery.where('exists', nestedExistsQuery)
          }
        }
        lastQuery = nestedExistsQuery
        currentEntity = currentEntity.elements[nestedNavigationName]._target
      }
      i += 2
    }
  }

  SELECT.where = newWhere
}

const _addTableName = (where, tableName) => {
  return where.map(whereEl => {
    if (whereEl.xpr) {
      return { xpr: _addTableName(whereEl.xpr, tableName) }
    }

    if (whereEl.ref) {
      whereEl.ref.unshift(tableName)
    }

    return whereEl
  })
}

const _buildExistsQuery = (entity, navigation, currentAlias, nextAlias) => {
  const target = entity.elements[navigation.id || navigation].target

  const existsQuery = cds.ql.SELECT.from(target)
  existsQuery.SELECT.from.as = nextAlias

  if (navigation && navigation.where) {
    existsQuery.where(_addTableName(navigation.where, nextAlias))
  }

  const onCond = entity.elements[navigation.id || navigation]._relations.join(nextAlias, currentAlias)
  return existsQuery.where(onCond)
}

const _createWindowCQN = (SELECT, model) => {
  const bottomTop = SELECT.columns.filter(el => _isBottomTop([el]))
  const columns = (SELECT.columns = [])
  const { elements } = model.definitions[SELECT.from.ref[0]]

  for (const el in elements) {
    if (!elements[el].isAssociation) {
      columns.push({ ref: [el] })
    }
  }

  SELECT.where = _getWindowWhere(SELECT.where, bottomTop)
  SELECT.from = {
    SELECT: {
      columns: _getWindColumns(columns, SELECT.groupBy, bottomTop),
      from: SELECT.from
    }
  }

  SELECT.groupBy = undefined
}

const _unshiftRefsWithNavigation = nav => el => {
  if (el.ref) return { ref: [...nav, ...el.ref] }
  if (el.xpr) return { xpr: el.xpr.map(_unshiftRefsWithNavigation(nav)) }
  return el
}

const _getWhereExistsSubSelect = (queryTarget, outerAlias, innerAlias, ref, model, options) => {
  let nav = ref.map(el => (el.id ? el.id : el))
  const last = ref.slice(-1)[0]
  const navName = queryTarget.elements[nav[0]] ? nav[0] : nav[nav.length - 1]
  const navElement = queryTarget.elements[navName]

  const lastElement = nav.reduce((csn, segment) => {
    if (csn.items) return csn // arrayed not supported
    if (csn.elements) {
      const next = csn.elements[segment]
      if (!next) return csn
      if (next.target) return model.definitions[next.target]
      return next
    }
  }, queryTarget)

  if (lastElement.items) {
    // > arrayed
    throw getError(501, `Condition expression with arrayed elements is not supported`)
  }

  if (nav[0] === outerAlias) nav = nav.slice(1)

  const condition = last.where
    ? nav.length > 1
      ? last.where.map(_unshiftRefsWithNavigation(nav.slice(1)))
      : last.where
    : undefined

  if (!innerAlias && !outerAlias) {
    innerAlias = navElement.target
    outerAlias = navElement.parent.name
  }

  const subSelect = SELECT.from({ ref: [navElement.target], as: innerAlias })
  if (condition) {
    if (subSelect.SELECT.from.as) {
      for (let i = 0; i < condition.length; i++) {
        if (!condition[i].ref) continue

        if (
          condition[i].ref.length > 1 &&
          condition[i].ref.every(r => typeof r === 'string') &&
          condition[i].ref[0] === navName
        ) {
          condition[i].ref[0] = subSelect.SELECT.from.as
        } else if (condition[i].ref.length === 1) {
          condition[i].ref.unshift(subSelect.SELECT.from.as)
        }
      }
    }

    // skip for where: [{ val: 1 }]
    // where: [{ func: 'contains', args: [] }] must be evaluated
    if (condition.length > 1 || (condition.length === 1 && !('val' in condition[0]))) subSelect.where(condition)
  }

  if (options.localized != null) subSelect.SELECT.localized = options.localized

  subSelect.where(queryTarget._relations[navName].join(innerAlias, outerAlias))
  if (cds.env.effective.odata.structs || cds.env.features.ucsn_struct_conversion) {
    flattenStructuredSelect(subSelect, model)
  }
  subSelect.columns([{ val: 1 }])

  // nested where exists needs recursive conversion
  options.lambdaIteration++

  return _convertSelect(subSelect, model, options)
}

/*
 * ensures that the where exists are fully expanded and have an infix filter
 * example: where: ['exists', { ref: ['book', 'author'] }]
 *       -> where: ['exists', { id: 'book', where: ['exists', { id: 'author', where: [{ val: 1 }] }] }]
 */
const _ensureExpandedNestedWhereExists = ({ ref }, aliases) => {
  const acc = {}
  let cur = acc
  let alias

  for (const r of ref) {
    if (Array.isArray(cur)) {
      if (cur.length > 1) {
        // > element already has condition(s)
        cur.push('and', 'exists', { ref: [{}] })
        cur = cur[cur.length - 1].ref[0]
      } else {
        cur.unshift('exists')
        cur[1] = { ref: [{}] }
        cur = cur[1].ref[0]
      }
    }

    if (typeof r === 'string' && aliases.includes(r)) {
      alias = r
    } else {
      // use Object.assign to preserve pointers
      if (typeof r === 'string') Object.assign(cur, { id: r, where: [{ val: 1 }] })
      else Object.assign(cur, r)
      cur = cur.where
    }
  }

  if (alias) return { ref: [alias, acc] }
  return { ref: [acc] }
}

const _getRefIndex = (where, index) => {
  if (
    where[index - 1].ref &&
    where[index - 1].ref[where[index - 1].ref.length - 1] !== 'InProcessByUser' &&
    where[index + 1].val !== undefined &&
    where[index + 1].val !== null &&
    where[index + 1].val !== false
  ) {
    return index - 1
  }
  if (
    where[index + 1].ref &&
    where[index + 1].ref[where[index + 1].ref.length - 1] !== 'InProcessByUser' &&
    where[index - 1].val !== undefined &&
    where[index - 1].val !== null &&
    where[index - 1].val !== false
  ) {
    return index + 1
  }
}

const _convertWhereExistsColumn = (column, model, options, queryTarget) => {
  const lambdaIteration = options.lambdaIteration
  if (typeof column === 'object') {
    if (column.SELECT) {
      convertWhereExists(column.SELECT, model, options)
      options.lambdaIteration = lambdaIteration
    } else if (column.where) {
      convertWhereExists(column, model, options, queryTarget)
      options.lambdaIteration = lambdaIteration
    }
  }
}

const convertWhereExists = (query, model, options, currentTarget) => {
  const { where, columns, expand } = query
  let innerAlias, outerAlias, queryTarget
  const { ref, as } =
    (query.ref && query) ||
    (query.from &&
      ((query.from.ref && query.from) || (query.from.args && query.from.args[0].ref && query.from.args[0]))) ||
    {}

  if (!ref) return

  if (!options.lambdaIteration) options.lambdaIteration = 1
  const lambdaIteration = options.lambdaIteration

  if (currentTarget) {
    queryTarget = getEntityFromPath({ ref }, currentTarget)
  } else {
    queryTarget = getEntityFromPath({ ref }, model)
    outerAlias = as || PARENT_ALIAS + lambdaIteration
    innerAlias = FOREIGN_ALIAS + lambdaIteration
  }

  if (where) {
    for (let i = 0; i < where.length; i++) {
      const element = where[i]

      // ensure where exists are fully expanded
      if (element === 'exists' && where[i + 1].ref) {
        const ref = query.from || query
        const aliases = ref.as ? [ref.as] : ref.join ? ref.args.map(arg => arg.as) : []
        where[i + 1] = _ensureExpandedNestedWhereExists(where[i + 1], aliases)
      }

      if (element.xpr) {
        convertWhereExists({ ...query, where: element.xpr }, model, options, currentTarget) // > recursing into nested {xpr}
      } else if (element === 'exists' && where[i + 1].ref) {
        if (query.from) {
          query.from.as = outerAlias
        }
        where[i + 1] = _getWhereExistsSubSelect(queryTarget, outerAlias, innerAlias, where[i + 1].ref, model, options)
        i += 1
      } else if (element.SELECT) {
        convertWhereExists(element.SELECT, model, options)
      }

      options.lambdaIteration = lambdaIteration
    }
  }

  if (columns) {
    columns.forEach(column => _convertWhereExistsColumn(column, model, options, queryTarget))
  }

  if (expand && expand !== '*') {
    expand.forEach(column => _convertWhereExistsColumn(column, model, options, queryTarget))
  }
}

const _convertNotEqual = (container, partName = 'where') => {
  const NOT_EQUAL = { '!=': 1, '<>': 1 }
  const where = container[partName]

  if (where) {
    for (let index = 0; index < where.length; index++) {
      const el = where[index]
      if (el in NOT_EQUAL) {
        const refIndex = _getRefIndex(where, index)
        if (refIndex !== undefined) {
          where[index - 1] = {
            xpr: [where[index - 1], el, where[index + 1], 'or', where[refIndex], '=', { val: null }]
          }
          where.splice(index, 2)
          --index
        }
      }

      if (el && el.SELECT) {
        _convertNotEqual(el.SELECT, partName)
      }

      if (el && el.xpr) {
        _convertNotEqual(el, 'xpr')
      }
    }
  }

  if (container.columns) {
    container.columns.forEach(col => {
      if (typeof col === 'object') {
        if (col.SELECT) {
          _convertNotEqual(col.SELECT, partName)
          return
        }

        if (col.where) {
          _convertNotEqual(col, partName)
        }
      }
    })
  }
}

const _ifOrderByOrWhereSkip = (queryTarget, ref, model) => {
  if (!queryTarget || !queryTarget.elements[ref[0]]) return
  return ref.some(el => {
    if (typeof el !== 'string') return
    const orderbyTarget = queryTarget.elements[el]._isStructured
      ? queryTarget.elements[el]
      : model.definitions[queryTarget.elements[el].target]
    if (orderbyTarget) queryTarget = orderbyTarget
    return (
      (orderbyTarget && orderbyTarget._hasPersistenceSkip) ||
      (queryTarget.elements[el] && queryTarget.elements[el].virtual)
    )
  })
}

const _skip = (queryTarget, ref, alias, model) => {
  // we remove the alias, if it exists
  const _ref = ref[0] === alias ? ref.slice(1) : ref
  if (_ref.length === 1) return queryTarget && queryTarget.elements[_ref[0]] && queryTarget.elements[_ref[0]].virtual

  return _ifOrderByOrWhereSkip(queryTarget, _ref, model)
}

const _convertOrderByIfSkip = (orderByCQN, index) => {
  orderByCQN.splice(index, 1)
}

const _convertWhereIfSkip = (whereCQN, index) => {
  whereCQN.splice(index, 1, '1 = 1')
  whereCQN[index + 1] in OPERATIONS_MAP ? whereCQN.splice(index + 1, 2) : whereCQN.splice(index - 2, 2)
}

const _convertOrderByOrWhereCQN = (orderByOrWhereCQN, target, model, alias, processFn) => {
  const queryTarget = model.definitions[ensureNoDraftsSuffix(target)]

  orderByOrWhereCQN.forEach((el, index) => {
    if (el.xpr) {
      _convertOrderByOrWhereCQN(el.xpr, target, model, alias, processFn)
      return
    }

    if (el.ref && _skip(queryTarget, el.ref, alias, model)) processFn(orderByOrWhereCQN, index)
  })
}

const _convertOrderByOrWhereIfSkip = (cqn, target, model) => {
  const alias = cqn.SELECT.from.as
  if (cqn.SELECT.orderBy && cqn.SELECT.orderBy.length) {
    _convertOrderByOrWhereCQN(cqn.SELECT.orderBy, target, model, alias, _convertOrderByIfSkip)
  }

  if (cqn.SELECT.where) {
    _convertOrderByOrWhereCQN(cqn.SELECT.where, target, model, alias, _convertWhereIfSkip)
  }
}

/* REVISIT: Unused
const _convertExpand = expand => {
  expand.forEach(expandElement => {
    if (expandElement.ref && expandElement.ref[0]) {
      if (expandElement.ref[0].where) {
        expandElement.where = expandElement.ref[0].where
      }

      if (expandElement.ref[0].id) {
        expandElement.ref[0] = expandElement.ref[0].id
      }
    }

    if (expandElement.expand) {
      _convertExpand(expandElement.expand)
    }
  })
}
*/

const _simplifyWhere = col => {
  if (col.ref?.[0].where) {
    col.where = col.ref[0].where
    col.ref[0] = col.ref[0].id
  }
}

const _simplifyWhereInColumns = columns => {
  if (!columns) return
  for (const col of columns) {
    _simplifyWhere(col)
    if (col.expand) _simplifyWhereInColumns(col.expand)
  }
}

const _convertPathExpression = (query, model, options = {}) => {
  const prevAlias = query.SELECT.from.as
  for (const whereEl of query.SELECT.where || []) {
    if (typeof whereEl === 'object' && whereEl.SELECT) _convertPathExpression(whereEl, model)
  }
  const conversion = convertPathExpressionToWhere(query.SELECT.from, model, options)
  if (!conversion) return
  const { target, alias, where, cardinality, columns, args } = conversion

  // REVISIT: It's not possible to just change the reference (i.e. SELECT.from.ref = [target])
  // as many parts of our code base still refer to SELECT.from (e.g. authorization)
  if (args) {
    query.SELECT.from = { ref: [{ id: target, args }] }
  } else {
    query.SELECT.from = { ref: [target] }
  }

  if (alias) {
    query.SELECT.from.as = alias
    if (query.SELECT.where && alias !== prevAlias) {
      query.SELECT.where = addAliasToExpression(query.SELECT.where, alias)
    }
  }

  if (columns) {
    // TODO: use streaming as outer property
    if (options.isStreaming) query.SELECT.columns = columns
    else {
      if (!query.SELECT.columns) {
        // Okra always wants to have the key values, remove once we relax this requirement
        if (model.definitions[target] && model.definitions[target].keys) {
          query.SELECT.columns = Object.keys(model.definitions[target].keys)
            .filter(
              k =>
                !model.definitions[target].keys[k].isAssociation &&
                !columns.find(element => element.ref && element.ref[element.ref.length - 1] === k)
            )
            .map(k => ({ ref: [k] }))
        } else query.SELECT.columns = []
      }
      query.SELECT.columns.push(...columns)
    }
  }

  if (cardinality && cardinality.max === 1) {
    query.SELECT.one = true
  }

  // TODO: REVISIT: We need to add alias to subselect in .where, .columns, .from, ... etc
  if (where) query.where(where)
}

const _convertToOneEqNullInFilter = (query, target) => {
  // we do not handle join or union
  if (!target) return

  for (let i = 0; i < query.where.length; i++) {
    const w = query.where[i]
    if (w.xpr) {
      _convertToOneEqNullInFilter({ where: w.xpr }, target)
    }

    const w2 = query.where[i + 2]
    if (!w2 || !w.ref || w2.val !== null) {
      continue
    }

    const element = target.elements[w.ref[w.ref.length - 1]]
    if (element && element.is2one && !element.on) {
      const foreignKeys = Object.values(element.parent.elements).filter(e => e._foreignKey4 === element.name)
      const replacedKeys = foreignKeys.reduce((arr, e, idx) => {
        arr.push({ ref: [...w.ref.slice(0, w.ref.length - 1), e.name] }, query.where[i + 1], query.where[i + 2])
        if (idx < foreignKeys.length - 1) {
          arr.push('and')
        }
        return arr
      }, [])

      query.where.splice(i, 3, { xpr: [...replacedKeys] })
      i++
    }
  }
}

const _convertSelect = (query, model, _options) => {
  const _4db = _options.service?.isDatabaseService
  const options = Object.assign(
    { _4db, isStreaming: cds.env.features.stream_compat && query._streaming, localized: query.SELECT.localized },
    _options
  )

  // ensure query is ql enabled
  if (!(query instanceof Query)) Object.setPrototypeOf(query, Object.getPrototypeOf(SELECT()))
  if (query.SELECT.from && query.SELECT.from.SELECT) {
    if (query.SELECT._4odata) query.SELECT.from.SELECT._4odata = true
    query.SELECT.from = _convertSelect(query.SELECT.from, model, options)
    if (!query.SELECT.columns || !query.SELECT.columns.length) {
      query.SELECT.columns = query.SELECT.from.SELECT.columns.map(c => (c.as ? { ref: [c.as] } : c))
    }
  }

  // add 'or is null' in case of not equal: '!=' or '<>'
  if (query.SELECT._4odata) {
    _convertNotEqual(query.SELECT, 'where')
    _convertNotEqual(query.SELECT, 'having')
  }

  _convertPathExpression(query, model, options)

  convertWhereExists(query.SELECT, model, options)

  rewriteAsterisks(query, model, options)
  const entity =
    (query.SELECT.from.ref && (query.SELECT.from.ref[0].id || query.SELECT.from.ref[0])) || query.SELECT.from
  const target = entity && model.definitions[entity]

  if (query.SELECT.where) {
    if (_isCountNavigation(query.SELECT.where)) {
      _convertCountNavigation(query.SELECT, target)
    }

    _convertToOneEqNullInFilter(query.SELECT, target)
  }

  // extract where clause if it is in an expand column
  _simplifyWhereInColumns(query.SELECT.columns)

  // REVISIT: The following operations only work for _one_ entity.
  // We must also enable them for joins etc.
  const { entityName, alias } = getEntityNameFromCQN(query)

  // remove virtual and with skip annotated fields in orderby and where
  _convertOrderByOrWhereIfSkip(query, entityName, model)

  if (query.SELECT.search && !options.suppressSearch) {
    // COMPAT:  new protocol adapter captures input as single "val"
    //          old db expects it as cqn xpr
    if (query.SELECT.search.length === 1) {
      query.SELECT.search = query.SELECT.search[0].val
        .match(/("")|("(?:[^"]|\\")*(?:[^\\]|\\\\)")|(\S*)/g)
        .filter(el => el.length)
        .map(el => {
          if (el[0] === '"' && el.at(-1) === '"') {
            try {
              return JSON.parse(el)
            } catch {
              return el
            }
          }
          return el
        })
        .reduce((arr, val, i) => {
          if (i > 0) arr.push('and')
          arr.push({ val })
          return arr
        }, [])

      if (!query.SELECT.search.length) query.SELECT.search = [{ val: '' }]
    }

    search2cqn4sql(query, model, { ...query._searchOptions, ...{ entityName, alias } })
  }

  if (target && query.SELECT.columns) {
    // clean up associations / compositions from columns, if not expanded
    const cleanedUpColumns = []
    for (const col of query.SELECT.columns) {
      if (!col.expand) {
        const ref = col.ref && col.ref[col.ref.length - 1]
        const refElement = target.elements[ref]
        if (refElement && refElement.isAssociation) {
          // ignore
          continue
        }
      }

      cleanedUpColumns.push(col)
    }

    query.SELECT.columns = cleanedUpColumns
  }

  if (query.SELECT.columns && (cds.env.effective.odata.structs || cds.env.features.ucsn_struct_conversion)) {
    flattenStructuredSelect(query, model)
  }

  // topcount with groupby
  if (query.SELECT.columns && _isBottomTop(query.SELECT.columns)) {
    _createWindowCQN(query.SELECT, model)
  }

  // best-effort ensure columns
  if (options._4db && !query.SELECT.columns) {
    let target = query._target
    if (target && target._unresolved && typeof target.name === 'string') {
      target = model.definitions[target.name] || target
    }

    if (target && !Object.prototype.hasOwnProperty.call(target, '_unresolved')) {
      const cols = getColumns(target, { onlyNames: true, filterVirtual: true })
      query.columns(cols)
      if (target._isDraftEnabled && query._target._unresolved) {
        query.SELECT.columns.push(...getDraftColumnsCQNForDraft(target), { ref: ['DraftAdministrativeData_DraftUUID'] })
      }
    }
  }

  return query
}

const _convertUpsert = (query, model) => {
  // resolve path expression
  const resolvedIntoClause = _convertPathExpressionForInsert(query.UPSERT.into, model)

  const target = model.definitions[resolvedIntoClause]
  if (!target) {
    // if there is no target, just return original query, as a copy is not deep anyways
    // and all the sub items of query.UPSERT are referenced only anyways
    return query
  }

  // overwrite only .into, foreign keys are already set
  // 'a' added as placeholder since its overwritten by Object.assign below
  const upsert = UPSERT.into('a')

  // REVISIT flatten structured types, currently its done in SQL builder

  // We add all previous properties ot the newly created query.
  // Reason is to not lose the query API functionality

  for (const key in query.UPSERT) {
    upsert.UPSERT[key] = query.UPSERT[key]
  }
  Object.assign(upsert.UPSERT, { into: { ref: [resolvedIntoClause], as: query.UPSERT.into.as } })

  const resolved = resolveView(upsert, model, cds.db)
  // required for deploying of extensions, not used anywhere else except UpsertBuilder
  resolved._target = resolved.UPSERT?._transitions?.[0].target || query._target
  // resolved._target = query._target
  return resolved
}

const _convertInsert = (query, model) => {
  // resolve path expression
  const resolvedIntoClause = _convertPathExpressionForInsert(query.INSERT.into, model)

  // overwrite only .into, foreign keys are already set
  // 'a' added as placeholder since its overwritten by Object.assign below
  const insert = INSERT.into('a')

  // REVISIT flatten structured types, currently its done in SQL builder

  // We add all previous properties ot the newly created query.
  // Reason is to not lose the query API functionality
  insert.INSERT = {}
  for (const prop in query.INSERT) {
    insert.INSERT[prop] = query.INSERT[prop]
  }
  Object.assign(insert.INSERT, { into: { ref: [resolvedIntoClause], as: query.INSERT.into.as } })

  const target = model.definitions[resolvedIntoClause]
  if (!target) return insert
  return resolveView(insert, model, cds.db)
}

function _modifyNavigationInWhere(whereClause, target) {
  if (!whereClause) return

  whereClause.forEach(e => {
    if (e.ref && e.ref.length > 1 && target.elements[e.ref[0]]) {
      const element = target.elements[e.ref[0]]
      if (!element.isAssociation) return
      const foreignKeys = element._foreignKeys
      const joined = e.ref.join('_')

      for (const { parentElement } of foreignKeys) {
        if (parentElement && parentElement.name === joined) {
          e.ref = [joined]
        }
      }
    }
  })
}

const _plainDelete = (cqn, model) => {
  const name = cqn.DELETE.from.name || (cqn.DELETE.from.ref && cqn.DELETE.from.ref[0]) || cqn.DELETE.from
  const target = model.definitions[name]

  if (cqn.DELETE.where) {
    _convertToOneEqNullInFilter(cqn.DELETE, target)
  }

  if (!target) return cqn

  return resolveView(cqn, model, cds.db)
}

const _convertDelete = (query, model, options) => {
  // .from is plain string or csn entity
  if (
    typeof query.DELETE.from === 'string' ||
    query.DELETE.from.name ||
    (query.DELETE.from.ref && typeof query.DELETE.from.ref[0] === 'string')
  ) {
    return _plainDelete(query, model)
  }

  const { target, alias, where } = convertPathExpressionToWhere(query.DELETE.from, model, options)
  const deleet = DELETE('x')

  for (const key in query.DELETE) {
    deleet.DELETE[key] = query.DELETE[key]
  }

  Object.assign(deleet.DELETE, { from: target, where: undefined })

  if (alias) deleet.DELETE.from = { ref: [target], as: alias }
  if (where) deleet.where(where)

  const targetEntity = model.definitions[target]
  if (query.DELETE.where) {
    deleet.where(addAliasToExpression(query.DELETE.where, alias))
    _convertToOneEqNullInFilter(deleet.DELETE, targetEntity)
  }

  if (!targetEntity) return deleet

  return resolveView(deleet, model, cds.db)
}

function _plainUpdate(cqn, model) {
  const name = cqn.UPDATE.entity.name || (cqn.UPDATE.entity.ref && cqn.UPDATE.entity.ref[0]) || cqn.UPDATE.entity
  const target = model.definitions[name]

  if (cqn.UPDATE.where) {
    _convertToOneEqNullInFilter(cqn.UPDATE, target)
  }

  if (!target) return cqn
  return resolveView(cqn, model, cds.db)
}

const _convertUpdate = (query, model, options) => {
  // REVISIT flatten structured types, currently its done in SQL builder

  // .into is plain string or csn entity
  if (
    typeof query.UPDATE.entity === 'string' ||
    query.UPDATE.entity.name ||
    (query.UPDATE.entity.ref && typeof query.UPDATE.entity.ref[0] === 'string' && query.UPDATE.entity.ref.length === 1)
  ) {
    return _plainUpdate(query, model)
  }

  const { target, alias, where } = convertPathExpressionToWhere(query.UPDATE.entity, model, options)

  // link .with and .data and set query target and remove current where clause
  // REVISIT: update statement does not accept cqn partial as input
  const update = UPDATE('x')
  // Object.assign(update.UPDATE, query.UPDATE, { entity: target, where: undefined })
  for (const key in query.UPDATE) {
    update.UPDATE[key] = query.UPDATE[key]
  }
  Object.assign(update.UPDATE, { entity: target, where: undefined })

  if (alias) update.UPDATE.entity = { ref: [target], as: alias }
  if (where) update.where(where)

  const targetEntity = model.definitions[target]

  if (query.UPDATE.where) {
    update.where(addAliasToExpression(query.UPDATE.where, alias))
    _convertToOneEqNullInFilter(update.UPDATE, targetEntity)
  }

  if (!targetEntity) return update

  return resolveView(update, model, cds.db)
}

/**
 * Converts a CQN with path expression into exists clause.
 * Converts insert/update/delete on view to target table including renaming of properties
 * REVISIT structured
 * REVISIT topcount when the additional layer for Analytics before SQLBuilder is ready
 *
 * @param {object} query - incoming query
 * @param {object} model - csn model
 * @param {import('../../types/api').cqn2cqn4sqlOptions} [options] Additional options.
 */
const cqn2cqn4sql = (query, model, options = { suppressSearch: false }) => {
  if (query.SELECT) {
    return _convertSelect(query, model, options)
  }

  if (query.UPDATE) {
    return _convertUpdate(query, model, options)
  }

  if (query.INSERT) {
    return _convertInsert(query, model)
  }

  if (query.UPSERT) {
    return _convertUpsert(query, model)
  }

  if (query.DELETE) {
    return _convertDelete(query, model, options)
  }

  return query
}

module.exports = {
  cqn2cqn4sql,
  convertWhereExists,
  convertPathExpressionToWhere
}
