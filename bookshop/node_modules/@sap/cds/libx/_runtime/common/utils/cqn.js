const cds = require('../../cds')
const { SELECT } = cds.ql
const { setEntityContained } = require('./csn')

const getEntityNameFromDeleteCQN = cqn => {
  let from
  if (cqn && cqn.DELETE && cqn.DELETE.from) {
    if (typeof cqn.DELETE.from === 'string') {
      from = cqn.DELETE.from
    } else if (cqn.DELETE.from.name) {
      from = cqn.DELETE.from.name
    } else if (cqn.DELETE.from.ref && cqn.DELETE.from.ref.length === 1) {
      from = cqn.DELETE.from.ref[0]
    }
  }
  return from
}

const getEntityNameFromUpdateCQN = cqn => {
  return (
    (cqn.UPDATE.entity.ref && cqn.UPDATE.entity.ref[0] && (cqn.UPDATE.entity.ref[0].id || cqn.UPDATE.entity.ref[0])) ||
    cqn.UPDATE.entity.name ||
    cqn.UPDATE.entity
  )
}

// scope: simple wheres Ã  la "[{ ref: ['foo'] }, '=', { val: 'bar' }, 'and', ... ]"
function where2obj(where, target = null, data = {}) {
  for (let i = 0; i < where.length; i++) {
    const whereEl = where[i]

    if (whereEl.xpr) {
      where2obj(whereEl.xpr, target, data)
    }

    const colName = whereEl.ref && whereEl.ref[whereEl.ref.length - 1]
    // optional validation if target is passed
    if (target) {
      const colEl = target.elements[colName]
      if (!colEl || !colEl.key) continue
    }
    const opWhere = where[i + 1]
    const valWhere = where[i + 2]
    if (opWhere === '=' && valWhere && 'val' in valWhere) data[colName] = valWhere.val
  }
  return data
}

function targetFromPath(from, model) {
  if (from.SELECT) {
    return targetFromPath(from.SELECT.from, model)
  }
  const fromRef = from ? from.ref || [from] : []
  let last = fromRef.length ? model.definitions : {}
  const path = []
  let target
  let isContained
  for (let r of fromRef) {
    isContained = undefined
    path.push(r.operation || r)
    r = (r.id && r.id.replace(/_drafts$/, '')) || r
    if (r.operation) {
      if (last && last.actions) last = last.actions[r.operation]
      else last = last[r.operation]
    } else if (last.elements) {
      last = last.elements[r]
      if (last.isAssociation) {
        isContained = last._isContained && last.target !== last.parent.name
        last = model.definitions[last.target]
      }
    } else {
      last = last[r]
    }
    if (last.kind === 'entity') {
      target = last
      setEntityContained(target, model, isContained)
    } else if (last.kind === 'service') {
      target = last
    }
  }
  return { last, path, target, isTargetComposition: isContained }
}

function isPathToDraft(path, model) {
  const { definitions } = model
  let draft = false
  let current
  for (const r of path) {
    if (r.id) {
      const isaIndex = r.where.findIndex(ele => ele.ref && ele.ref[0] === 'IsActiveEntity')
      if (isaIndex !== -1) draft = !r.where[isaIndex + 2].val
      current = current ? definitions[current.elements[r.id].target] : definitions[r.id]
    } else {
      if (r === 'SiblingEntity') draft = !!draft
      else {
        const next = current.elements[r]
        if (next.isAssociation) {
          if (next._isAssociationStrict) draft = false
          current = definitions[next.target]
        } else {
          current = next
        }
      }
    }
  }
  return draft
}

const resolveFromSelect = query => {
  const __protoSelect = Object.getPrototypeOf(SELECT())
  if (!(query instanceof __protoSelect.constructor)) Object.setPrototypeOf(query, __protoSelect)
  const { from } = query.SELECT
  return from.SELECT ? resolveFromSelect(from) : from
}

module.exports = {
  getEntityNameFromDeleteCQN,
  getEntityNameFromUpdateCQN,
  where2obj,
  targetFromPath,
  isPathToDraft,
  resolveFromSelect
}
