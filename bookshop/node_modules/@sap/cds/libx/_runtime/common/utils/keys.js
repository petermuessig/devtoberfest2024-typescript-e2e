const { where2obj } = require('./cqn')
const { deepCopy } = require('./copy')
const { getOnCond } = require('./generateOnCond')

function _getOnCondElements(onCond, onCondElements = []) {
  const andIndex = onCond.indexOf('and')

  const ref0 = onCond[0].xpr ? onCond[0].xpr[0].ref : onCond[0].ref
  const ref1 = onCond[0].xpr ? onCond[0].xpr[2].ref : onCond[2].ref
  const val0 = onCond[0].xpr ? onCond[0].xpr[0].val : onCond[0].val
  const val1 = onCond[0].xpr ? onCond[0].xpr[2].val : onCond[2].val

  let entityRef, targetRef, entityVal
  if (ref0?.[0] === 'target') {
    targetRef = ref0
    entityRef = ref1
    entityVal = val1
  } else if (ref1?.[0] === 'target') {
    targetRef = ref1
    entityRef = ref0
    entityVal = val0
  }

  const entityKey = entityRef && entityRef.slice(1).join('.')
  const targetKey = targetRef && targetRef.slice(1).join('.')
  onCondElements.push({ entityKey, targetKey, entityVal })

  if (andIndex !== -1) {
    _getOnCondElements(onCond.slice(andIndex + 1), onCondElements)
  }
  return onCondElements
}

function _mergeWhere(base, additional) {
  if (additional?.length) {
    // copy where else query will be modified
    const whereCopy = deepCopy(additional)
    if (base.length > 0) base.push('and')
    base.push(...whereCopy)
  }
  return base
}

function _modifyWhereWithNavigations(where, newWhere, entityKey, targetKey) {
  _mergeWhere(newWhere, where)
  _renameOnUp(newWhere, entityKey, targetKey)
}

function _buildWhereForNavigations(ref, newWhere, model, target) {
  const currentRef = ref[0]
  const nextRef = ref[1]

  if (nextRef) {
    const csnEntity = target || model.definitions[currentRef.id || currentRef]
    const navigationElement = csnEntity && csnEntity.elements[nextRef.id || nextRef]

    if (!navigationElement || !navigationElement.on) return

    const onCond = getOnCond(navigationElement, [navigationElement.name], { select: 'source', join: 'target' })
    const nextKeys = _getOnCondElements(onCond[0].xpr)

    // only add where once in _modifyWhereWithNavigations
    let whereAdded = false
    for (const key of nextKeys) {
      const targetKeyElement = navigationElement._target.elements[key.entityKey]

      if (targetKeyElement && (targetKeyElement.isAssociation || targetKeyElement._foreignKey4)) {
        _modifyWhereWithNavigations(!whereAdded && currentRef.where, newWhere, key.entityKey, key.targetKey)
        whereAdded = true
      }
    }
    _buildWhereForNavigations(ref.slice(1), newWhere, model, navigationElement._target)
  }
}

function _renameOnUp(newWhere, entityKey, targetKey) {
  let renamed = false
  newWhere.forEach(element => {
    if (element.ref && element.ref[0] === targetKey) {
      element.ref = [entityKey]
      renamed = true
    }
  })
  return renamed
}

function calculateWhereForNavigationsFromRefPath(ref, newWhere, target) {
  const currentRef = ref[0]
  const nextRef = ref[1]

  if (nextRef) {
    const csnEntity = target
    const navigationElement = csnEntity && csnEntity.elements[nextRef.id || nextRef]

    if (!navigationElement || !navigationElement.on) return

    const onCond = target._relations[nextRef.id || nextRef].join('target', 'source')
    const nextKeys = _getOnCondElements(onCond[0].xpr)

    const seg_keys = where2obj(currentRef.where ?? [])
    for (const key of nextKeys) {
      if (navigationElement.is2one && csnEntity.elements[key.entityKey] && !navigationElement._isSelfManaged) {
        // foreign key in root
        continue
      }

      const targetKeyElement = navigationElement._target.elements[key.targetKey]

      if (targetKeyElement && key.targetKey && key.entityKey) {
        if (newWhere.length) {
          if (_renameOnUp(newWhere, key.targetKey, key.entityKey)) {
            continue
          }
          newWhere.push('and')
        }
        newWhere.push({ ref: [key.targetKey] }, '=', { val: seg_keys[key.entityKey] })
      } else if (targetKeyElement && key.targetKey && key.entityVal !== undefined) {
        if (newWhere.length) newWhere.push('and')
        newWhere.push({ ref: [key.targetKey] }, '=', { val: key.entityVal })
      }
    }
    calculateWhereForNavigationsFromRefPath(ref.slice(1), newWhere, navigationElement._target)
  }
}

function getKeysForNavigationFromRefPath(ref, target) {
  const where = []
  calculateWhereForNavigationsFromRefPath(ref, where, target)
  if (where.length) {
    return where2obj(where)
  }
  return {}
}

function _getWhereFromInsert(query, model) {
  const where = []
  if (query.INSERT.into.ref && query.INSERT.into.ref.length > 1) {
    _buildWhereForNavigations(query.INSERT.into.ref, where, model)
  }
  return where
}

function _getWhereFromUpdate(query, model) {
  if (query.UPDATE.entity.ref && query.UPDATE.entity.ref.length > 1) {
    const where = []
    _buildWhereForNavigations(query.UPDATE.entity.ref, where, model)

    return where
  }

  const where = query.UPDATE.where || []
  if (query.UPDATE.entity.ref?.length === 1 && query.UPDATE.entity.ref[0].where)
    return _mergeWhere(where.length ? [...query.UPDATE.entity.ref[0].where] : query.UPDATE.entity.ref[0].where, where)
  return where
}

// params: data, req, service/tx
function enrichDataWithKeysFromWhere(data, { query, target }, { model }) {
  if (query.INSERT) {
    const where = _getWhereFromInsert(query, model)
    if (!where || !where.length) return
    if (!Array.isArray(data)) data = [data]
    for (const d of data) Object.assign(d, where2obj(where, target))
  } else if (query.UPDATE) {
    const where = _getWhereFromUpdate(query, model)
    if (!where || !where.length) return
    // REVISIT: We should not expect data to be present always!
    if (!data) data = query.UPDATE.data = {}
    Object.assign(data, where2obj(where, target))
  }
}

module.exports = {
  where2obj,
  enrichDataWithKeysFromWhere,
  getKeysForNavigationFromRefPath
}
