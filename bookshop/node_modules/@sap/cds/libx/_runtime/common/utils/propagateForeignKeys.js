const cds = require('../../cds')

const { prefixForStruct } = require('../../common/utils/csn')

const _autoGenerate = e => e && e.isUUID && e.key

const _set = (row, value, element, enumerable) => {
  if (!element.parent.elements[element.name]) return // only when in model
  if (!enumerable && element.foreignKeySource) {
    // only for foreign keys
    Object.defineProperty(row, element.name, {
      get() {
        return value
      },
      set(v) {
        // Make sure that it becomes enumerable again if set manually afterwards
        Object.defineProperty(row, element.name, { value: v, configurable: true, enumerable: true })
      },
      enumerable: false,
      configurable: true
    })
  } else {
    row[element.name] = value
  }
}

const _generateParentField = ({ parentElement }, row, enumerable) => {
  if (_autoGenerate(parentElement) && !row[parentElement.name]) {
    _set(row, cds.utils.uuid(), parentElement, enumerable)
  }
}

const _generateChildField = ({ deep, childElement }, childRow, enumerable) => {
  if (deep) {
    _generateChildField(deep.propagation, childRow[deep.targetName], enumerable)
  } else if (_autoGenerate(childElement) && childRow && !childRow[childElement.name]) {
    _set(childRow, cds.utils.uuid(), childElement, enumerable)
  }
}

const _getNestedVal = (row, prefix) => {
  let val = row
  const splitted = prefix.split('_')
  splitted.pop() // remove last `_`
  let k = ''

  while (splitted.length > 0) {
    k += splitted.shift()
    if (k in val) {
      val = val[k]
      k = ''
    } else {
      k += '_'
    }
  }

  return val
}

const _propagateToChild = ({ parentElement, childElement, parentFieldValue }, row, childRow, enumerable) => {
  if (!childElement || !childElement.parent.elements[childElement.name]) return
  if (parentElement) {
    const prefix = prefixForStruct(parentElement)
    if (prefix) {
      const nested = _getNestedVal(row, prefix)
      _set(childRow, nested[parentElement.name], childElement, enumerable)
    } else {
      _set(childRow, row[parentElement.name], childElement, enumerable)
    }
  } else if (parentFieldValue !== undefined) {
    _set(childRow, parentFieldValue, childElement, enumerable)
  }
}

const _propagateToParent = ({ parentElement, childElement, deep }, childRow, row, enumerable) => {
  if (deep) {
    _propagateToParent(deep.propagation, childRow[deep.targetName], childRow, enumerable)
  }
  if (parentElement && childElement && childRow && childElement.name in childRow) {
    _set(row, childRow[childElement.name], parentElement, enumerable)
  }
}

module.exports = (
  tKey,
  row,
  foreignKeyPropagations,
  isCompositionEffective,
  { deleteAssocs = false, enumerable = true } = {}
) => {
  if (!row || !(tKey in row)) return
  if (row[tKey] === null) {
    for (const foreignKeyPropagation of foreignKeyPropagations) {
      if (!foreignKeyPropagation.fillChild) {
        _set(row, null, foreignKeyPropagation.parentElement, enumerable)
      }
    }
    if (deleteAssocs && !isCompositionEffective) delete row[tKey]
    return
  }

  const childRows = Array.isArray(row[tKey]) ? row[tKey] : [row[tKey]]

  for (const childRow of childRows) {
    if (!childRow) return

    for (const foreignKeyPropagation of foreignKeyPropagations) {
      if (foreignKeyPropagation.fillChild) {
        // propagate or generate in parent
        const pk = foreignKeyPropagation.parentElement && foreignKeyPropagation.parentElement.name
        if (pk && !(pk in row)) _propagateToParent(foreignKeyPropagation, childRow, row, enumerable)
        if (!(pk in row)) _generateParentField(foreignKeyPropagation, row, enumerable)

        if (isCompositionEffective) _propagateToChild(foreignKeyPropagation, row, childRow, enumerable)
      } else {
        if (isCompositionEffective) _generateChildField(foreignKeyPropagation, childRow, enumerable)
        _propagateToParent(foreignKeyPropagation, childRow, row, enumerable)
      }
    }
  }
  if (deleteAssocs && !isCompositionEffective) delete row[tKey]
}
