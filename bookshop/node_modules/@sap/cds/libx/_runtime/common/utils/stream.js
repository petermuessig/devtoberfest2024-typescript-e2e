const cds = require('../../cds')
const LOG = cds.log('odata')
const { SELECT } = cds.ql
const { deepCopy } = require('./copy')
const { getTransition } = require('./resolveView')

const _getStreamProperties = (req, query) => {
  // new odata parser sets streaming property in SELECT.from
  const ref = (query.SELECT.columns && query.SELECT.columns[0].ref) || query.SELECT.from.ref
  const propertyName = ref[ref.length - 1]
  let mediaTypeProperty
  for (let key in req.target.elements) {
    const val = req.target.elements[key]
    if (val['@Core.MediaType'] && val.name === propertyName) {
      mediaTypeProperty = val
      break
    }
  }

  // REVISIT: workaround for read after write
  // if (!mediaTypeProperty) return {}

  let contentType, contentDispositionFilename
  const columns = []
  if (typeof mediaTypeProperty['@Core.MediaType'] === 'object') {
    let contentTypeProperty = mediaTypeProperty['@Core.MediaType']['='].replaceAll(/\./g, '_')
    if (!req.target.elements[contentTypeProperty]) {
      LOG._warn &&
        LOG.warn(
          `@Core.MediaType in entity "${req.target.name}" points to property "${contentTypeProperty}" which was renamed or is not part of the projection. You must update the annotation value.`
        )
      const mapping = getTransition(req.target, cds.db).mapping
      const key = [...mapping.entries()].find(({ 1: val }) => val.ref[0] === contentTypeProperty)
      contentTypeProperty = key && key.length && key[0]
    }
    if (!req.target.elements[contentTypeProperty]) {
      LOG._warn && LOG.warn(`MediaType ${contentTypeProperty} not found in entity "${req.target.name}".`)
    } else {
      columns.push({ ref: [contentTypeProperty], as: 'contentType' })
    }
  } else {
    contentType = mediaTypeProperty['@Core.MediaType']
  }
  if (mediaTypeProperty['@Core.ContentDisposition.Filename']) {
    if (typeof mediaTypeProperty['@Core.ContentDisposition.Filename'] === 'object') {
      let contentDispositionProperty = mediaTypeProperty['@Core.ContentDisposition.Filename']['='].replaceAll(
        /\./g,
        '_'
      )
      if (!req.target.elements[contentDispositionProperty]) {
        LOG._warn &&
          LOG.warn(
            `@Core.ContentDisposition.Filename in entity "${req.target.name}" points to property "${contentDispositionProperty}" which was renamed or is not part of the projection. You must update the annotation value.`
          )
        const mapping = getTransition(req.target, cds.db).mapping
        const key = [...mapping.entries()].find(({ 1: val }) => val.ref[0] === contentDispositionProperty)
        contentDispositionProperty = key && key.length && key[0]
      }
      if (!req.target.elements[contentDispositionProperty]) {
        LOG._warn &&
          LOG.warn(`ContentDisposition ${contentDispositionProperty} not found in entity "${req.target.name}".`)
      } else {
        columns.push({ ref: [contentDispositionProperty], as: 'contentDispositionFilename' })
      }
    } else {
      contentDispositionFilename = mediaTypeProperty['@Core.ContentDisposition.Filename']
    }
  }
  const contentDispositionType = mediaTypeProperty['@Core.ContentDisposition.Type']

  if (columns.length && cds.db && !req.target._hasPersistenceSkip) {
    // used cloned path
    let select = SELECT.one.from({ ref: deepCopy(query.SELECT.from.ref), as: query.SELECT.from.as }).columns(columns)
    if (query.SELECT.where?.length) select.SELECT.where = query.SELECT.where

    return cds
      .tx(req)
      .run(select)
      .then(res => ({
        contentType: (res && res.contentType) || contentType,
        contentDispositionFilename: (res && res.contentDispositionFilename) || contentDispositionFilename,
        contentDispositionType
      }))
  }

  return Promise.resolve({ contentType, contentDispositionFilename, contentDispositionType })
}

const enhanceStreamResult = async (req, query, result, model) => {
  if (result.$mediaContentType || result.$mediaContentDispositionFilename || result.$mediaContentDispositionType) return

  const { contentType, contentDispositionFilename, contentDispositionType } = await _getStreamProperties(
    req,
    query,
    model
  )
  if (contentType) result.$mediaContentType = contentType
  if (contentDispositionFilename) {
    result.$mediaContentDispositionFilename = contentDispositionFilename
    if (contentDispositionType) result.$mediaContentDispositionType = contentDispositionType
  }
}

module.exports = { enhanceStreamResult }
