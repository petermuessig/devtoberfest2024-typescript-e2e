const _createLikeComparison = (searchXpr, columns, excludeSearch) => {
  const likeExpression = { xpr: [] }

  columns.forEach((column, index, columns) => {
    // if negated search, we need to add is null check
    let currentExpression = likeExpression
    if (excludeSearch) {
      currentExpression = { xpr: [column, 'IS NULL', 'OR'] }
    }

    const searchStringEscaped = searchXpr.val.toLowerCase().replace(/(\^|_|%)/g, '^$1')

    currentExpression.xpr.push(
      { func: 'lower', args: [column] },
      excludeSearch ? 'NOT LIKE' : 'LIKE',
      { val: `%${searchStringEscaped}%` },
      'ESCAPE',
      "'^'"
    )

    if (excludeSearch) {
      likeExpression.xpr.push(currentExpression)
    }

    if (index !== columns.length - 1) {
      likeExpression.xpr.push(excludeSearch ? 'AND' : 'OR')
    }
  })

  return likeExpression
}

// Computes a LIKE expression for a search query.
const searchToLike = (cqnSearchPhrase, columns, expression = []) => {
  cqnSearchPhrase.forEach((element, index) => {
    if (element === 'not') return

    if (element === 'or' || element === 'and') {
      expression.push(element)
      return
    }

    if (element.xpr) {
      expression.push({ xpr: searchToLike(element.xpr, columns) })
      return
    }

    const excludeSearch = cqnSearchPhrase[index - 1] === 'not'
    const likeComparison = _createLikeComparison(element, columns, excludeSearch)
    expression.push(likeComparison)
  })

  return expression
}

module.exports = searchToLike
