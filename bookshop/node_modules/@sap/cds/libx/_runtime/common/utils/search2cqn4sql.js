const { computeColumnsToBeSearched } = require('./columns')
const searchToLike = require('./searchToLike')
const { getEntityNameFromCQN } = require('./entityFromCqn')

const _targetFrom = (cqn, options) => {
  if (options && options.entityName) return options
  return getEntityNameFromCQN(cqn)
}

// convert $search system query option to WHERE/HAVING clause using
// the operator LIKE or CONTAINS
const search2cqn4sql = (query, model, options = {}) => {
  const cqnSearchPhrase = query.SELECT.search
  if (!cqnSearchPhrase) return

  const { search2cqn4sql } = options
  const { entityName, alias } = _targetFrom(query.SELECT.from, options)
  const entity = model.definitions[entityName]
  const aggregated = query._aggregated || /* new parser */ query.SELECT.groupBy

  // Call custom (optimized search to cqn for sql implementation) that tries
  // to optimize the search behavior for a specific database service.
  if (typeof search2cqn4sql === 'function' && entity?.associations?.localized && !aggregated) {
    const search2cqnOptions = { columns: computeColumnsToBeSearched(query, entity), locale: options.locale }
    return search2cqn4sql(query, entity, search2cqnOptions)
  }

  const columnsToBeSearched = computeColumnsToBeSearched(query, entity, alias)
  const expression = columnsToBeSearched?.length
    ? searchToLike(cqnSearchPhrase, columnsToBeSearched)
    : [{ val: '0' }, '=', { val: '1' }]

  // REVISIT: find out here if where or having must be used
  aggregated ? query.having(expression) : query.where(expression)
}

module.exports = search2cqn4sql
