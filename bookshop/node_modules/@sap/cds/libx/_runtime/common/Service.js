const cds = require('../cds')

const { resolveView, findQueryTarget } = require('./utils/resolveView')
const postProcess = require('./utils/postProcess')

/**
 * Generic Application Service Provider
 */
class ApplicationService extends cds.Service {
  init() {
    const clazz = this.constructor,
      { generics } = clazz
    for (let each of generics) clazz[each].call(this)
    return super.init()
  }

  static get generics() {
    let generics = Reflect.getOwnPropertyDescriptor(this, '_generics')
    if (generics) return generics.value
    else {
      const set = new Set(this.__proto__.generics)
      for (let p of Reflect.ownKeys(this)) if (p.startsWith('handle_')) set.add(p)
      Object.defineProperty(this, '_generics', { value: (generics = [...set]) })
    }
    return generics
  }

  static handle_authorization() {
    require('./generic/auth').call(this)
  }

  static handle_etags() {
    require('./generic/etag').call(this)
  }

  static handle_validations() {
    require('./generic/input').call(this)
  }

  static handle_stream_property() {
    require('./generic/stream').call(this)
  }

  static handle_puts() {
    require('./generic/put').call(this)
  }

  static handle_temporal_data() {
    require('./generic/temporal').call(this)
  }

  static handle_localized_data() {
    // TODO: can we move handling of localized data here?
  }

  static handle_managed_data() {
    // TODO: can we move handling of managed data here?
  }

  static handle_paging() {
    require('./generic/paging').call(this) // > paging must be executed before sorting
    require('./generic/sorting').call(this)
  }

  static handle_code_ext() {
    if (cds.env.requires.extensibility?.code) require('./code-ext/handlers').call(this)
  }

  static handle_fiori() {
    require('../fiori/lean-draft').impl.call(this)
  }

  static handle_crud() {
    require('./generic/crud').impl.call(this)
  }

  // Overload .handle in order to resolve projections up to a definition that is known by the remote service instance.
  // Result is post processed according to the inverse projection in order to reflect the correct result of the original query.
  async handle(req) {
    let result
    let target = req.target

    if (!this._requires_resolving(req)) {
      result = await super.handle(req)
    } else {
      const query = resolveView(req.query, this.model, this)
      target = findQueryTarget(query) || req.target
      // REVISIT: get rid of _4odata
      if (req.query.SELECT?._4odata) Object.defineProperty(query.SELECT, '_4odata', { value: true })
      // we need to provide target explicitly because it's cached within ensure_target
      const _req = new cds.Request({ query, target, _resolved: true })
      result = await super.dispatch(_req)
      result = postProcess(query, result, this)
    }

    return result
  }

  /**
   * @param serviceImpl
   * @deprecated since version 1.11.0 - use Service.prepend instead
   */
  with(serviceImpl) {
    return this.prepend(serviceImpl)
  }

  /**
   * Registers custom handlers.
   * @param {string | object | Function} serviceImpl - init function to register custom handlers.
   */
  impl(serviceImpl) {
    if (typeof serviceImpl === 'string') serviceImpl = require(serviceImpl)
    return this.prepend(serviceImpl)
  }
}

// NOTE: getRestrictions is VERY INOFFICIAL!!!
const { getRestrictions } = require('./generic/auth/restrictions')
ApplicationService.prototype.getRestrictions = function (..._) {
  return getRestrictions.call(this, ..._)
}

ApplicationService.prototype.isAppService = true
module.exports = ApplicationService
