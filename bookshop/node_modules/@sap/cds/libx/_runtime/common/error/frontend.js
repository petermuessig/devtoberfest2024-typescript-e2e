// REVISIT: Requires thorough cleanup and refactoring, or elimination
/*
 * OData spec:
 *   This object MUST contain name/value pairs with the names code and message,
 *   and it MAY contain name/value pairs with the names target, details and innererror.
 *   [...]
 *   Error responses MAY contain annotations in any of its JSON objects.
 */
const localeFrom = require('../../../../lib/req/locale')
const { getErrorMessage } = require('./utils')
let _i18n
const i18n = (...args) => {
  if (!_i18n) _i18n = require('../i18n')
  return _i18n(...args)
}

const {
  ALLOWED_PROPERTIES_MAP,
  ADDITIONAL_MSG_PROPERTIES_MAP,
  DEFAULT_SEVERITY,
  MIN_SEVERITY,
  MAX_SEVERITY
} = require('./constants')
const ADDITIONAL_MSG_PROPERTIES = Object.keys(ADDITIONAL_MSG_PROPERTIES_MAP)

const _getFiltered = err => {
  const error = {}
  for (let k in err) {
    // IMPORTANT: do not use Object.keys(err) here as that ignores enumerable properties from __proto__!
    if (k in ALLOWED_PROPERTIES_MAP || k.startsWith('@')) {
      error[k] = err[k]
    } else if (k === 'numericSeverity') {
      error['@Common.numericSeverity'] = err[k]
    }
  }
  if ('message' in err) error.message = err.message
  return error
}

const _rewriteError = error => {
  let { code, message } = error
  code = String(code || 'null')

  // REVISIT: db stuff probably shouldn't be here
  if (code === 'SQLITE_ERROR') {
    error.code = 'null'
    return
  }

  if (
    (code.startsWith('SQLITE_CONSTRAINT') && (message.match(/COMMIT/) || message.match(/FOREIGN KEY/))) ||
    (code === '155' && message.match(/fk constraint violation/))
  ) {
    // > foreign key constaint violation no sqlite/ hana
    error.code = '400'
    error.message = 'FK_CONSTRAINT_VIOLATION'
    return
  }

  if (code.startsWith('ASSERT_')) {
    error.code = '400'
    return
  }
}

const _normalize = (err, locale, formatterFn = _getFiltered) => {
  // REVISIT: code and message rewriting
  _rewriteError(err)

  // message (i18n)
  err.message = getErrorMessage(err, locale)

  // ensure code is set and a string
  err.code = String(err.code || 'null')

  let statusCode = err.status || err.statusCode || (_isAllowedError(err.code) && err.code)

  // details
  if (err.details) {
    const childErrorCodes = new Set()
    err.details = err.details.map(ele => {
      const { error: childError, statusCode: childStatusCode } = _normalize(ele, locale, formatterFn)
      childErrorCodes.add(childStatusCode)
      return childError
    })
    statusCode = statusCode || _statusCodeFromDetails(childErrorCodes)
  }

  // make sure it's a number if set, otherwise will be assigned as 500 in normalizeError
  statusCode = statusCode ? Number(statusCode) : undefined

  // only allowed properties
  const error = formatterFn(err)

  return { error, statusCode }
}

const _isAllowedError = errorCode => errorCode >= 300 && errorCode < 505

// - for one unique value, we use it
// - if at least one 5xx exists, we use 500
// - else if at least one 4xx exists, we use 400
const _statusCodeFromDetails = uniqueStatusCodes => {
  if (uniqueStatusCodes.size === 1) return uniqueStatusCodes.values().next().value
  if ([...uniqueStatusCodes].some(s => s >= 500)) return 500
  if ([...uniqueStatusCodes].some(s => s >= 400)) return 400
}

const _getSanitizedError = (statusCode, locale) => ({
  error: { code: String(statusCode), message: i18n(statusCode, locale) },
  statusCode
})

const normalizeError = (err, req, formatterFn) => {
  const locale = req.locale || (req.locale = localeFrom(req))
  let { error, statusCode } = _normalize(err, locale, formatterFn)

  if (process.env.NODE_ENV === 'production') {
    // > return sanitized error to client

    if (!statusCode) return _getSanitizedError(500, locale)

    if (statusCode >= 500 && err._thrownByFramework) {
      return _getSanitizedError(statusCode, locale)
    }
  }

  if (!statusCode) statusCode = 500

  // no top level null codes
  if (error.code === 'null') error.code = String(statusCode)

  return { error, statusCode }
}

const _ensureSeverity = arg => {
  if (typeof arg !== 'number') return DEFAULT_SEVERITY

  if (arg >= MIN_SEVERITY && arg <= MAX_SEVERITY) return arg

  return DEFAULT_SEVERITY
}

const _normalizeMessage = (message, locale) => {
  const { error: normalized } = _normalize(message, locale)

  // numericSeverity without @Common
  normalized.numericSeverity = _ensureSeverity(message.numericSeverity)
  delete normalized['@Common.numericSeverity']

  ADDITIONAL_MSG_PROPERTIES.forEach(k => {
    if (message[k] && typeof message[k] === 'string') {
      normalized[k] = message[k]
    }
  })

  return normalized
}

const getSapMessages = (messages, req) => {
  const locale = req.locale || (req.locale = localeFrom(req))
  const s = JSON.stringify(messages.map(message => _normalizeMessage(message, locale)))
  // convert non ascii to unicode
  return s.replace(/[\u007F-\uFFFF]/g, chr => {
    return '\\u' + ('0000' + chr.charCodeAt(0).toString(16)).substr(-4)
  })
}

const isClientError = e => {
  // e.code may be undefined, string, number, ... -> NaN -> not a client error
  const numericCode = e.statusCode || e.status || Number(e.code)
  return numericCode >= 400 && numericCode < 500
}

const unwrapMultipleErrors = error => {
  // According to the Fiori Elements Failed Message specification, the format must be:
  // Root level: First error, Details: Other errors
  const [firstDetail, ...restDetails] = error.details
  Object.assign(error, firstDetail)
  if (restDetails.length) error.details = restDetails
  else delete error.details
}

module.exports = {
  normalizeError,
  getSapMessages,
  isClientError,
  unwrapMultipleErrors
}
