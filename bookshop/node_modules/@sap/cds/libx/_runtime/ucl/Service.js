const cds = require('../cds')
const LOG = cds.log('ucl')
const fs = require('fs').promises

const https = require('https')

class UCLService extends cds.Service {
  async init() {
    await super.init()

    for (const _required of ['namespace', 'systemType', 'systemDescription']) {
      if (!this.options[_required])
        throw new Error(
          `The UCL service requires mandatory parameter \`${_required}\`, please provide it as described in the documentation.`
        )
    }

    if (!cds.requires.multitenancy && cds.env.profile !== 'mtx-sidecar')
      throw new Error(
        'The UCL service requires multitenancy, please enable it in your cds configuration with `cds.requires.multitenancy` or by using the mtx sidecar.'
      )
    if (!this.options.credentials)
      throw new Error('No credentials found for the UCL service, please bind the service to your app.')

    if (!this.options.x509.cert && !this.options.x509.certPath)
      throw new Error('UCL requires `x509.cert` or `x509.certPath`.')
    if (!this.options.x509.pkey && !this.options.x509.pkeyPath)
      throw new Error('UCL requires `x509.pkey` or `x509.pkeyPath`.')

    const [cert, key] = await Promise.all([
      this.options.x509.cert ?? fs.readFile(cds.utils.path.resolve(cds.root, this.options.x509.certPath)),
      this.options.x509.pkey ?? fs.readFile(cds.utils.path.resolve(cds.root, this.options.x509.pkeyPath))
    ])
    this.agent = new https.Agent({ cert, key })

    const existingTemplate = await this.readTemplate()
    const template = existingTemplate ? await this.updateTemplate(existingTemplate) : await this.createTemplate() // TODO: Make sure return value is correct

    if (!template) throw new Error('The UCL service could not create an application template.')

    cds.once('listening', async () => {
      const provisioning = await cds.connect.to('cds.xt.SaasProvisioningService')
      provisioning.prepend(() => {
        provisioning.on('dependencies', async (_, next) => {
          const dependencies = await next()
          dependencies.push({ xsappname: template.labels.xsappnameCMPClone })
          return dependencies
        })
      })
    })
  }

  async readTemplate() {
    const xsappname = this.options.credentials.xsappname
    const query = `
      query ($key: String!, $value: String!) {
        applicationTemplates(filter: { key: $key, query: $value }) {
          data {
            id
            name
            description
            placeholders {
              name
              description
            }
            applicationInput
            labels
            webhooks {
              type
            }
          }
        }
      }
    `
    const variables = { key: 'xsappname', value: `"${xsappname}"` }
    const res = await this._request(query, variables)
    if (res) return res.applicationTemplates.data[0]
  }

  async createTemplate() {
    const xsappname = this.options.credentials.xsappname
    const query = `mutation {
          result: createApplicationTemplate (
              in: {
              name: "${this.options.systemType}"
              description: "${this.options.systemDescription}"
              applicationInput: {
                  name: "${this.options.systemType}" 
                  description: "${this.options.systemDescription}"
                  providerName: "${this.options.provider}" 
                  localTenantID: "{{tenant-id}}"
                  labels: {
                  displayName: "{{subdomain}}"
                  }
              }
              placeholders: [
                  { name: "subdomain", description: "The subdomain of the consumer tenant" }
                  { name: "tenant-id", description: "The tenant id as it's known in the product's domain", jsonPath: "$.subscribedSubaccountId" }
              ]
              labels: {
                  managed_app_provisioning: true
                  xsappname: "${xsappname}"
              }
              applicationNamespace: "${this.options.namespace}"
              accessLevel: GLOBAL
              }
          ) {
              id
              name
              labels
              applicationInput 
              applicationNamespace
          }
      }`
    try {
      return this._handleResponse(await this._request(query))
    } catch (e) {
      this._handleResponse(e)
    }
  }

  _handleResponse(result) {
    if (result.response && result.response.errors) {
      let errorMessage = result.response.errors[0].message
      throw new Error(errorMessage)
    } else {
      return result.result
    }
  }

  async deleteTemplate() {
    const template = await this.readTemplate()
    if (!template) return
    const query = `mutation {
            result: deleteApplicationTemplate(
              id: "${template.id}"
            ){
                id
                name
                description
            }
        }`
    return this._handleResponse(await this._request(query))
  }

  // Replace with fetch
  async _request(query, variables) {
    const opts = {
      host: this.options.host,
      path: this.options.path,
      agent: this.agent,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    }
    return new Promise((resolve, reject) => {
      const req = https.request(opts, res => {
        const chunks = []

        res.on('data', chunk => {
          chunks.push(chunk)
        })

        res.on('end', () => {
          const response = {
            statusCode: res.statusCode,
            headers: res.headers,
            body: Buffer.concat(chunks).toString()
          }
          const body = JSON.parse(response.body)
          if (body.errors)
            throw new Error('Request to UCL service failed with:\n' + JSON.stringify(body.errors, null, 2))
          resolve(body.data)
        })
      })

      req.on('error', error => {
        reject(error)
      })

      if (query) {
        req.write(JSON.stringify({ query, variables }))
      }
      req.end()
    })
  }

  async updateTemplate(template) {
    const query = `mutation {
    result: updateApplicationTemplate(
      id: "${template.id}"
      in: {
        name: "${this.options.systemType}"
        description: "${this.options.systemDescription}"
        applicationInput: {
          name: "${this.options.systemType}"
          description: "${this.options.systemDescription}"
          providerName: "${this.options.provider}" 
          localTenantID: "{{tenant-id}}"
          labels: { displayName: "{{subdomain}}" }
        }
        applicationNamespace: "${this.options.namespace}"
        placeholders: [
            { name: "subdomain", description: "The subdomain of the consumer tenant" }
            { name: "tenant-id", description: "The tenant id as it's known in the product's domain", jsonPath: "$.subscribedSubaccountId" }
        ]
        accessLevel: GLOBAL
      }
    ) {
      id
      name
      labels
      description
      applicationInput
    }
  }`
    try {
      const response = this._handleResponse(await this._request(query))
      LOG.info('Application template updated successfully.')
      return response
    } catch (e) {
      this._handleResponse(e)
    }
  }
}

module.exports = UCLService
