const cds = require('../cds')
const LOG = cds.log('hana|db|sql')

const { HANA_TYPE_CONVERSION_MAP } = require('./conversion')
const CustomBuilder = require('./customBuilder')
const { sqlFactory } = require('../db/sql-builder/')
const { getPostProcessMapper, postProcess } = require('../db/data-conversion/post-processing')
const { createJoinCQNFromExpanded, hasExpand, rawToExpanded, expandV2 } = require('../db/expand')
const {
  hasStreamInsert,
  hasStreamUpdate,
  writeStreamWithHanaClient,
  readStreamWithHanaClient,
  writeStreamWithHdb,
  readStreamWithHdb
} = require('./streaming')
const { convertStream } = require('../db/utils/stream')
const { isBase64String } = require('../../common/assert/utils')

function _cqnToSQL(model, query, user, locale, txTimestamp) {
  return sqlFactory(
    query,
    {
      user,
      customBuilder: CustomBuilder,
      now: txTimestamp || { sql: 'NOW ()' },
      locale
    },
    model
  )
}

const SANITIZE_VALUES = process.env.NODE_ENV === 'production' && cds.env.log.sanitize_values !== false

const BINARY_TYPES = {
  12: 'BINARY',
  13: 'VARBINARY',
  27: 'BLOB',
  33: 'BSTRING'
}

function _getBinaries(stmt) {
  // hdb vs. @sap/hana-client
  const parameters = stmt.parameterMetadata || stmt.getParameterInfo()
  const typeKey = stmt.parameterMetadata ? 'dataType' : 'nativeType'
  return parameters.reduce((acc, cur, i) => {
    if (BINARY_TYPES[cur[typeKey]]) acc.push(i)
    return acc
  }, [])
}

function _getProcedureNameAndSchema(sql) {
  // name delimited with "" allows any character
  const match = sql
    .trim()
    .match(
      /^call \s*(("(?<schema_delimited>\w+)"\.)?("(?<delimited>.+)")|(?<schema_undelimited>\w+\.)?(?<undelimited>\w+))\s*\(/i
    )
  return (
    match && {
      name: match.groups.undelimited ?? match.groups.delimited,
      schema: match.groups.schema_delimited || match.groups.schema_undelimited
    }
  )
}

function _hdbGetResultForProcedure(rows, args, outParameters) {
  // on hdb, rows already contains results for scalar params
  const result = rows || {}

  // merge table output params into scalar params
  if (args && args.length && outParameters) {
    const params = outParameters.filter(md => !(md.PARAMETER_NAME in rows))
    for (let i = 0; i < params.length; i++) {
      result[params[i].PARAMETER_NAME] = args[i]
    }
  }

  return result
}

function _hcGetResultForProcedure(stmt, resultSet, outParameters) {
  const result = {}
  // build result from scalar params
  const paramInfo = stmt.getParameterInfo()
  if (paramInfo.some(p => p.direction > 1)) {
    for (let i = 0; i < paramInfo.length; i++) {
      if (paramInfo[i].direction > 1) {
        result[paramInfo[i].name] = stmt.getParameterValue(i)
      }
    }
  }

  // merge table output params into scalar params
  const params = Array.isArray(outParameters) && outParameters.filter(md => !(md.PARAMETER_NAME in result))
  if (params && params.length) {
    for (let i = 0; i < params.length; i++) {
      const parameterName = params[i].PARAMETER_NAME
      result[parameterName] = []
      while (resultSet.next()) {
        result[parameterName].push(resultSet.getValues())
      }
      resultSet.nextResult()
    }
  }

  return result
}

function _getProcedureMetadata(dbc, name, schema) {
  return new Promise((resolve, reject) => {
    // REVISIT: better?
    if (dbc._closed) return reject(new Error('Transaction is already closed'))
    dbc.exec(
      `SELECT PARAMETER_NAME FROM SYS.PROCEDURE_PARAMETERS WHERE SCHEMA_NAME = ${
        schema?.toUpperCase?.() === 'SYS' ? `'SYS'` : 'CURRENT_SCHEMA'
      } AND PROCEDURE_NAME = '${name}' AND PARAMETER_TYPE IN ('OUT', 'INOUT') ORDER BY POSITION`,
      (err, res) => {
        if (err) reject(err)
        else resolve(res)
      }
    )
  })
}

function _executeAsPreparedStatement(dbc, sql, values, reject, resolve) {
  // REVISIT: better?
  if (dbc._closed) return reject(new Error('Transaction is already closed'))

  dbc.prepare(sql, async function (err, stmt) {
    if (err) {
      err.query = sql
      if (values) err.values = SANITIZE_VALUES ? ['***'] : values
      return reject(err)
    }

    // convert binary strings to buffers
    if (cds.env.hana.base64_to_buffer !== false && _hasValues(values)) {
      const binaries = _getBinaries(stmt)
      if (binaries.length) {
        const vals = Array.isArray(values[0]) ? values : [values]
        for (const i of binaries) {
          for (const row of vals) {
            if (row[i] && isBase64String(row[i])) row[i] = Buffer.from(row[i], 'base64')
          }
        }
      }
    }

    // procedure call metadata
    let outParameters
    const { name: procedureName, schema: procedureSchema } = _getProcedureNameAndSchema(sql) || {}
    if (procedureName) {
      try {
        outParameters = await _getProcedureMetadata(dbc, procedureName, procedureSchema)
      } catch (e) {
        LOG._warn && LOG.warn('Unable to fetch procedure metadata due to error:', e)
      }
    }

    // REVISIT: better?
    if (dbc._closed) return reject(new Error('Transaction is already closed'))

    // on @sap/hana-client, we need to use execQuery in case of calling procedures
    stmt[procedureName && dbc.name !== 'hdb' ? 'execQuery' : 'exec'](values, function (err, rows, ...args) {
      if (err) {
        stmt.drop(() => {})
        err.query = sql
        if (values) err.values = SANITIZE_VALUES ? ['***'] : values
        return reject(err)
      }

      let result
      if (procedureName) {
        result =
          dbc.name === 'hdb'
            ? _hdbGetResultForProcedure(rows, args, outParameters)
            : _hcGetResultForProcedure(stmt, rows, outParameters)
      } else {
        result = rows
      }

      stmt.drop(() => {})
      resolve(result)
    })
  })
}

const _hasValues = values => values && (values.length > 0 || Object.values(values).length > 0)

const regex = /with parameters\s*?\(\s*?'LOCALE'\s*?=\s*?'.*?'\s*?\)/gim

function _executeSimpleSQL(dbc, sql, values) {
  const res = sql.match(regex)
  if (res) sql = sql.replace(regex, '') + ' ' + res[0]

  LOG._debug && LOG.debug(sql, SANITIZE_VALUES ? ['***'] : values)
  return new Promise((resolve, reject) => {
    // hana-client only accepts arrays
    if (dbc.name !== 'hdb' && typeof values === 'object') {
      values = Object.values(values)
    }

    // ensure that stored procedure with parameters is always executed as prepared
    if (_hasValues(values) || !!_getProcedureNameAndSchema(sql)) {
      _executeAsPreparedStatement(dbc, sql, values, reject, resolve)
    } else {
      // REVISIT: better?
      if (dbc._closed) return reject(new Error('Transaction is already closed'))

      dbc.exec(sql, function (err, result) {
        if (err) {
          err.query = sql
          return reject(err)
        }
        resolve(result)
      })
    }
  })
}

function _executeSelectSQL(dbc, sql, values, isOne, postMapper) {
  return _executeSimpleSQL(dbc, sql, values).then(result => {
    if (isOne) {
      result = result.length > 0 ? result[0] : undefined
    }

    return postProcess(result, postMapper)
  })
}

function _processExpand(model, dbc, cqn, user, locale, txTimestamp) {
  const queries = []
  const expandQueries = createJoinCQNFromExpanded(cqn, model)

  for (const cqn of expandQueries.queries) {
    cqn._conversionMapper = getPostProcessMapper(HANA_TYPE_CONVERSION_MAP, model, cqn)

    // REVISIT
    // Why is the post processing in expand different?
    const { sql, values } = _cqnToSQL(model, cqn, user, locale, txTimestamp)

    queries.push(_executeSelectSQL(dbc, sql, values, false))
  }

  return rawToExpanded(expandQueries, queries, cqn.SELECT.one, cqn._target)
}

function executeSelectCQN(model, dbc, query, user, locale, txTimestamp) {
  if (hasExpand(query)) {
    // expand: '**' or '*3' is handled by new impl
    if (
      query.SELECT.columns.some(c => c.expand && typeof c.expand[0] === 'string' && /^\*{1}[\d|*]+/.test(c.expand[0]))
    ) {
      return expandV2(model, dbc, query, user, locale, txTimestamp, executeSelectCQN)
    }

    return _processExpand(model, dbc, query, user, locale, txTimestamp)
  }

  const { sql, values = [] } = _cqnToSQL(model, query, user, locale, txTimestamp)
  const postProcessMapper = getPostProcessMapper(HANA_TYPE_CONVERSION_MAP, model, query)
  return _executeSelectSQL(dbc, sql, values, query.SELECT.one, postProcessMapper)
}

function _getValuesProxy(values) {
  return new Proxy(values, {
    getOwnPropertyDescriptor: (obj, prop) => {
      if (prop.length > 1 && prop.startsWith(':')) {
        return Object.getOwnPropertyDescriptor(obj, prop.slice(1))
      }

      return Object.getOwnPropertyDescriptor(obj, prop)
    },
    get: (obj, prop) => {
      if (prop.length > 1 && prop.startsWith(':')) {
        return obj[prop.slice(1)]
      }

      return obj[prop]
    },
    ownKeys: target => Reflect.ownKeys(target).map(key => `:${key}`)
  })
}

function executePlainSQL(dbc, sql, values) {
  // Revisit: Keep for Hana?
  // support named binding parameters
  if (values && typeof values === 'object' && !Array.isArray(values)) {
    values = _getValuesProxy(values)
  }

  return _executeSimpleSQL(dbc, sql, values)
}

function executeInsertCQN(model, dbc, query, user, locale, txTimestamp) {
  const { sql, values = [] } = _cqnToSQL(model, query, user, locale, txTimestamp)

  if (hasStreamInsert(query.INSERT, model)) {
    if (dbc.name === 'hdb') {
      return writeStreamWithHdb(dbc, sql, values)
    }

    return writeStreamWithHanaClient(dbc, sql, values)
  }

  return _executeSimpleSQL(dbc, sql, values).then(affectedRows => {
    const entriesOrRows = query.INSERT.entries || query.INSERT.rows
    const affectedRowsCount = Array.isArray(affectedRows)
      ? affectedRows.reduce((sum, rows) => sum + rows, 0)
      : affectedRows

    if (entriesOrRows && entriesOrRows.length !== affectedRowsCount) {
      LOG._warn &&
        LOG.warn(
          `INSERT input deviates from affected rows (input: ${entriesOrRows.length}, affectedRows: ${affectedRowsCount})`,
          {
            sql,
            args: values && values.length,
            values,
            query
          }
        )

      throw new Error('Possible data loss by INSERT into HANA db. Please, update a corresponding HANA driver.')
    }

    // InsertResult needs an object per row with its values
    // query.INSERT.values -> one row
    if (query.INSERT.values) return [{ affectedRows: 1, values: [values] }]

    // query.INSERT.entries or .rows -> multiple rows
    if (entriesOrRows) return values.map(v => ({ affectedRows: 1, values: v }))

    // INSERT into SELECT
    return [{ affectedRows }]
  })
}

function _writeStream(model, dbc, query, user, locale, txTimestamp, sql, values) {
  if (dbc.name === 'hdb') return writeStreamWithHdb(dbc, sql, values)

  // @sap/hana-client does not support WHERE EXISTS when writing stream
  const subselect = query.UPDATE.where?.find(ele => typeof ele === 'object' && ele.SELECT && ele._etagValidation)
  if (!subselect) return writeStreamWithHanaClient(dbc, sql, values)

  const { sql: s, values: v } = _cqnToSQL(model, subselect, user, locale, txTimestamp)
  return executePlainSQL(dbc, s, v).then(res => {
    if (res.length === 0) return 0
    return writeStreamWithHanaClient(dbc, sql, values)
  })
}

function executeUpdateCQN(model, dbc, query, user, locale, txTimestamp) {
  const { sql, values = [] } = _cqnToSQL(model, query, user, locale, txTimestamp)

  // query can be insert from deep update
  if (query.UPDATE && hasStreamUpdate(query.UPDATE, model))
    return _writeStream(model, dbc, query, user, locale, txTimestamp, sql, values)

  return _executeSimpleSQL(dbc, sql, values)
}

// e. g. DROP, CREATE TABLE, DELETE
function executeGenericCQN(model, dbc, query, user, locale, txTimestamp) {
  const { sql, values = [] } = _cqnToSQL(model, query, user, locale, txTimestamp)

  return executePlainSQL(dbc, sql, values)
}

function _convertNames(rs, columns) {
  if (!columns) return rs

  const result = {}
  for (const key in rs) {
    let key_
    for (let col of columns) {
      const name = col.ref?.[col.ref.length - 1]
      if (name?.toUpperCase() === key) {
        key_ = col.as || name
        break
      }
    }
    if (key_) {
      result[key_] = rs[key]
    } else {
      result[key] = rs[key]
    }
  }

  return result
}

async function executeSelectStreamCQN({ model, query, dbc, user, locale, txTimestamp }) {
  const { sql, values = [] } = _cqnToSQL(model, query, user, locale, txTimestamp)
  let result

  if (dbc.name === 'hdb') {
    result = await readStreamWithHdb(dbc, sql, values)
  } else {
    result = await readStreamWithHanaClient(dbc, sql, values)
  }

  if (result.length === 0) return

  if (cds.env.features.stream_compat) {
    const res = _convertNames(result[0], query.SELECT?.columns)
    let [key, val] = Object.entries(res)[0]
    if (val === null) return null

    res.value = val
    delete res[key]

    return res
  } else {
    return dbc.name === 'hdb' ? result[0] : _convertNames(result[0], query.SELECT?.columns)
  }
}

module.exports = {
  delete: executeGenericCQN, // > no extra executeDeleteCQN needed
  insert: executeInsertCQN,
  update: executeUpdateCQN,
  select: executeSelectCQN,
  stream: executeSelectStreamCQN,
  convert: convertStream,
  cqn: executeGenericCQN,
  sql: executePlainSQL
}
