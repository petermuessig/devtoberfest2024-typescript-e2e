const cds = require('../cds')
const LOG = cds.log('pool|db')

const { pool } = cds.utils
const hana = require('./driver')
const getError = require('../common/error')

const _getMassagedCreds = function (creds) {
  if (!('ca' in creds) && creds.certificate) creds.ca = creds.certificate
  if ('encrypt' in creds && !('useTLS' in creds)) creds.useTLS = creds.encrypt
  if ('hostname_in_certificate' in creds && !('sslHostNameInCertificate' in creds))
    creds.sslHostNameInCertificate = creds.hostname_in_certificate
  if ('validate_certificate' in creds && !('sslValidateCertificate' in creds))
    creds.sslValidateCertificate = creds.validate_certificate
  return creds
}

// `disableCache: true` means to force fetch credentials from service manager
async function credentials4(tenant, db) {
  const { disableCache = false, options } = db
  const credentials = options?.credentials ?? cds.env.requires.db?.credentials
  if (!credentials) throw new Error('No database credentials provided')

  if (cds.requires.multitenancy) {
    const res = await require('@sap/cds-mtxs/lib').xt.serviceManager.get(tenant, { disableCache })
    return _getMassagedCreds(res.credentials)
  }

  if (typeof credentials !== 'object' || !credentials.host) throw new Error('Malformed database credentials provided')
  return _getMassagedCreds(credentials)
}

function factory4(creds, tenant) {
  return {
    create: () => {
      return hana.__connect(creds, tenant).catch(e => {
        if (!cds.requires.multitenancy || !e?.message.match(/authentication failed/i)) throw e

        LOG._warn &&
          LOG.warn(
            `Possibly stale credentials for tenant ${tenant}, re-trying with fresh credentials from BTP Service Manager`
          )
        return credentials4(tenant, { disableCache: true }).then(_creds => {
          // update creds in closure
          creds = _creds
          return hana.__connect(creds, tenant)
        })
      })
    },
    destroy: client => hana.__disconnect(client),
    validate: client => hana.__isConnected(client)
  }
}

/*
 * default generic-pool config
 */
const defaultConfig = { min: 0, max: 100, testOnBorrow: true, fifo: false }

const _getPoolConfig = function () {
  const { pool: poolConfig } = cds.env.requires.db
  const mergedConfig = Object.assign({}, defaultConfig, poolConfig)

  // without an acquire timeout, the acquire call _never_ rejects -> blocks the request forever
  mergedConfig.acquireTimeoutMillis ??= process.env.NODE_ENV === 'production' ? 1000 : 10 * 1000

  // defaults
  if (!poolConfig) {
    mergedConfig.softIdleTimeoutMillis = 30 * 1000
    mergedConfig.idleTimeoutMillis = 30 * 1000
  }

  // if evictionRunIntervalMillis is not set specifically, set to 2x of idleTimeoutMillis or softIdleTimeoutMillis
  if (!('evictionRunIntervalMillis' in mergedConfig)) {
    mergedConfig.evictionRunIntervalMillis =
      2 * (mergedConfig.idleTimeoutMillis || mergedConfig.softIdleTimeoutMillis || 30 * 1000)
  }

  // if numTestsPerEvictionRun is not set specifically, set to ~30% of min-max delta
  if (!('numTestsPerEvictionRun' in mergedConfig) && mergedConfig.max - mergedConfig.min > 0) {
    mergedConfig.numTestsPerEvictionRun = Math.ceil((mergedConfig.max - mergedConfig.min) / 3)
  }

  return mergedConfig
}

const pools = new Map()

async function pool4(tenant, db) {
  if (!pools.get(tenant)) {
    const poolPromise = new Promise((resolve, reject) => {
      credentials4(tenant, db)
        .then(creds => {
          const config = _getPoolConfig()
          LOG._info && LOG.info('effective pool configuration:', config)
          const p = pool.createPool(factory4(creds, tenant), config)
          const INVALID_CREDENTIALS_WARNING = `Could not establish connection for tenant "${tenant}". Existing pool will be drained.`
          const INVALID_CREDENTIALS_ERROR = `Create is blocked for tenant "${tenant}" due to invalid credentials.`
          const _create = () =>
            new Promise((_, reject) =>
              setTimeout(() => reject(new Error(INVALID_CREDENTIALS_ERROR)), config.acquireTimeoutMillis)
            )

          // The error listener for `factoryCreateError` is registered to detect failed connection attempts.
          // If it fails due to invalid credentials, we delete the current pool from the pools map and overwrite the pool factory create function.
          // The background is that the generic pool will keep trying to establish a connection by invoking the factory create function until the `acquireTimeoutMillis` is reached.
          // This leads to numerous connection attempts for a single request, even when the credentials are invalid.
          // Due to the deletion in the map, subsequent requests will retrieve the credentials again.
          p.on('factoryCreateError', function (err) {
            if (err._connectError) {
              LOG._warn && LOG.warn(INVALID_CREDENTIALS_WARNING)
              pools.delete(tenant)
              if (p._factory?.create) p._factory.create = _create
              // shutdown
              p.drain().then(p.clear.bind(p)) //> no need to await
            }
          })

          resolve(p)
        })
        .catch(e => {
          // delete pools entry if fetching credentials failed
          pools.delete(tenant)
          reject(e)
        })
    })

    pools.set(tenant, poolPromise)
  }

  if ('then' in pools.get(tenant)) {
    pools.set(tenant, await pools.get(tenant))
  }

  return pools.get(tenant)
}

async function resilientAcquire(pool, attempts = 1) {
  // max 3 attempts
  attempts = Math.min(attempts, 3)
  let client,
    err,
    attempt = 0

  while (!client && attempt < attempts) {
    try {
      client = await pool.acquire()
    } catch (e) {
      if (e.name !== 'TimeoutError') throw e
      err = e
      attempt++
    }
  }

  if (client) return client

  const { borrowed, pending, size, available, max } = pool
  const message =
    'Acquiring client from pool timed out. Please review your system setup, transaction handling, and pool configuration. ' +
    `Pool State: borrowed: ${borrowed}, pending: ${pending}, size: ${size}, available: ${available}, max: ${max}`
  err = getError(Object.assign(err, { statusCode: 503, message }))
  err._attempts = attempt
  LOG._debug && LOG.debug(err)
  throw err
}

module.exports = {
  acquire: async (tenant, db) => {
    const pool = await pool4(tenant, db)
    const _attempts = cds.env.requires.db.connection_attempts
    const attempts = _attempts && !isNaN(_attempts) && parseInt(_attempts)
    const client = await resilientAcquire(pool, attempts)
    client._pool = pool
    return client
  },

  release: client => client._pool.release(client),

  drain: async tenant => {
    const pool = pools.get(tenant)
    if (!pool) return
    pools.delete(tenant)
    await pool.drain()
    await pool.clear()
  }
}
