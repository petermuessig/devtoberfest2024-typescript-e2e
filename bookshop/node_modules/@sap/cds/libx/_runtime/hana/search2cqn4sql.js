const cds = require('../cds')
const { computeColumnsToBeSearched } = require('../common/utils/columns')
const searchToLike = require('../common/utils/searchToLike')
const { isContainsPredicateSupported, search2Contains } = require('./search2Contains')
const { addAliasToExpression } = require('../db/utils/generateAliases')
const targetAlias = 'Target'
const textsAlias = 'Texts'

/**
 * Computes a CQN expression for a search query.
 *
 * For performance reasons, search queries over localized elements use the `CONTAINS` predicate in the `WHERE` clause
 * of a `SELECT` statement instead of the `LIKE` predicate when possible. The `LIKE` predicate might cause a high CPU
 * load on SAP HANA servers because the SAP HANA optimizer cannot push down `LIKE` expressions to the column storage
 * layer. As a result, search queries over large data sets are slow.
 *
 * The `CONTAINS` predicates with exact search option (default behavior) is rendered as `LIKE` by the HANA optimizer.
 * But in contrast to the explicitly written `LIKE ?`, the parameter is already resolved to its concrete value, making
 * it better optimizable by the HANA optimizer.
 *
 * @param {object} query The CQN object
 * @param {import('@sap/cds-compiler/lib/api/main').CSN} entity The target entity for the search query
 * @param {import('../types/api').search2cqnOptions} [options]
 * @returns {object} The modified CQN object
 */
const search2cqn4sql = (query, entity, options) => {
  const cqnSearchPhrase = query.SELECT.search
  if (!cqnSearchPhrase) return query
  const localizedAssociation = entity.associations?.localized

  let { columns: columns2Search = computeColumnsToBeSearched(query, entity), locale } = options
  const viewAlias = query.SELECT.from.as ? query.SELECT.from.as : 'LocalizedView'

  if (!query.SELECT.from.as) {
    _addAliasToQuery(query, viewAlias)
  }

  const subQuery = cds.ql.SELECT.from(entity.name).columns(1)
  subQuery.SELECT.from.as = targetAlias
  const onCondition = _generateKeysWhereCondition(entity, targetAlias, textsAlias)
  onCondition.push('and', { ref: [textsAlias, 'locale'] }, '=', { val: locale || "SESSION_CONTEXT('LOCALE')" })

  // left outer join the target table with the _texts table (the _texts table contains the translated texts)
  subQuery.leftJoin(localizedAssociation.target, textsAlias).on(onCondition)

  // add condition for equal keys of target table and localized view
  subQuery.where(_generateKeysWhereCondition(entity, targetAlias, viewAlias))
  const containsColumns = _generateContainsColumns(columns2Search, entity)

  let expression

  if (isContainsPredicateSupported(query, entity, columns2Search)) {
    // generate CQN expression with `CONTAINS` predicate for the columns from the target and text table
    expression = search2Contains(cqnSearchPhrase, containsColumns)
    Object.defineProperty(expression, 'searchUsingContains', { value: true, enumerable: true })
  } else {
    expression = searchToLike(cqnSearchPhrase, containsColumns)
  }

  subQuery.where(expression)

  // suppress the localize handler from redirecting the subQuery's target to the localized view
  subQuery.SELECT.localized = false

  query.where('exists', subQuery)

  return query
}

const _generateKeysWhereCondition = (entity, alias1, alias2) => {
  const keys = Object.keys(entity.keys).filter(key => !entity.keys[key].isAssociation && !entity.keys[key].virtual)
  const where = []

  keys.forEach(key => {
    if (where.length > 0) where.push('and')
    where.push({ ref: [alias1, key] }, '=', { ref: [alias2, key] })
  })

  return where
}

const _generateContainsColumns = (columns, entity) => {
  const columnsTarget = addAliasToExpression(columns, targetAlias)
  const columns2SearchText = columns.filter(col => col.ref && entity.elements[col.ref[col.ref.length - 1]].localized)
  const columnsText = addAliasToExpression(columns2SearchText, textsAlias)
  return [...columnsTarget, ...columnsText]
}

const _addAliasToQuery = (query, alias) => {
  const SELECT = query.SELECT
  SELECT.from.as = alias
  SELECT.columns = addAliasToExpression(SELECT.columns, alias)
  SELECT.groupBy = addAliasToExpression(SELECT.groupBy, alias)
  SELECT.orderBy = addAliasToExpression(SELECT.orderBy, alias)
  SELECT.where = addAliasToExpression(SELECT.where, alias)
}

module.exports = search2cqn4sql
