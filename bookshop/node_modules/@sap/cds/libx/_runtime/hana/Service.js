const cds = require('../cds')
const LOG = cds.log('hana|db|sql')
const coloredTxCommands = require('../db/utils/coloredTxCommands')

const DatabaseService = require('../db/Service')
const pool = require('./pool')

/*
 * hana-specific handlers
 */
const localized = require('./localized')
const search = require('./search')

/*
 * hana-specific execution
 */
const execute = require('./execute')

/*
 * helpers
 */
const _setSessionContext = (dbc, property, value) => {
  if (dbc._connection) {
    // Works, but bad practice to access an internal scope
    dbc._connection.getClientInfo().setProperty(property, value)
    return
  }

  dbc.setClientInfo(property, value)
}

/*
 * the service
 */
class HanaDatabase extends DatabaseService {
  constructor(...args) {
    super(...args)

    // REVISIT: official db api
    this._execute = execute

    // REVISIT: db api
    this._insert = this._queries.insert(execute.insert)
    this._read = this._queries.read(execute.select, execute.stream, execute.convert)
    this._update = this._queries.update(execute.update, execute.select)
    this._delete = this._queries.delete(execute.delete, execute.update)
    this._run = this._queries.run(this._insert, this._read, this._update, this._delete, execute.cqn, execute.sql)
  }

  init() {
    this._registerBeforeHandlers()
    this._registerOnHandlers()
    this._registerAfterHandlers()

    /*
     * tx
     */
    this.on('BEGIN', function () {
      LOG._debug && LOG.debug(coloredTxCommands['BEGIN'])

      this.dbc.setAutoCommit(false)

      return 'dummy'
    })

    this.on(['COMMIT', 'ROLLBACK'], function (req) {
      LOG._debug && LOG.debug(coloredTxCommands[req.event])

      // REVISIT: better?
      this.dbc._closed = true

      return new Promise((resolve, reject) => {
        this.dbc[req.event.toLowerCase()](err => {
          try {
            this.dbc.setAutoCommit(true)
          } catch (e) {
            // REVISIT: what to do?
            return reject(e)
          }

          if (err) return reject(err)
          resolve('dummy')
        })
      })
    })

    /*
     * generic
     */
    // all others, i.e. CREATE, DROP table, ...
    this.on('*', function (req) {
      return this._run(this.model, this.dbc, req.query || req.event, req, req.data)
    })
  }

  _registerBeforeHandlers() {
    this.before(['CREATE', 'UPDATE', 'UPSERT'], '*', this._input) // > has to run before rewrite
    this.before('READ', '*', search) // > has to run before rewrite
    this.before(['CREATE', 'READ', 'UPDATE', 'DELETE', 'UPSERT'], '*', this._rewrite)

    this.before('READ', '*', localized) // > has to run after rewrite
    this.before('READ', '*', this._virtual)
  }

  _registerOnHandlers() {
    this.on('CREATE', '*', this._CREATE)
    this.on('READ', '*', this._READ)
    this.on('UPDATE', '*', this._UPDATE)
    this.on('DELETE', '*', this._DELETE)
  }

  _registerAfterHandlers() {
    // REVISIT: after phase runs in parallel -> side effects possible!
    const { effective, features } = cds.env

    if (effective.odata.structs && !features.ucsn_struct_conversion) {
      // REVISIT: only register for entities that contain structured or navigation to it
      this.after(['READ'], '*', this._structured)
    }
  }

  /*
   * connection
   */
  async acquire(arg) {
    const tenant = arg && (typeof arg === 'string' ? arg : arg.tenant)
    const dbc = await pool.acquire(tenant, this)

    if (arg && typeof arg !== 'string') {
      _setSessionContext(dbc, 'APPLICATIONUSER', arg.user.id || 'ANONYMOUS')
      _setSessionContext(dbc, 'LOCALE', arg.locale || 'en')

      // REVISIT: stable access
      const validFrom = (arg.context && arg.context._ && arg.context._['VALID-FROM']) || (arg._ && arg._['VALID-FROM'])
      const validto = (arg.context && arg.context._ && arg.context._['VALID-TO']) || (arg._ && arg._['VALID-TO'])

      if (validFrom)
        _setSessionContext(
          dbc,
          'VALID-FROM',
          validFrom instanceof Date ? validFrom.toISOString().replace('T', ' ') : validFrom.replace('T', ' ')
        )

      if (validto)
        _setSessionContext(
          dbc,
          'VALID-TO',
          validto instanceof Date ? validto.toISOString().replace('T', ' ') : validto.replace('T', ' ')
        )
    }

    dbc._tenant = tenant

    // REVISIT: better?
    dbc._closed = false

    return dbc
  }

  release(dbc) {
    if (dbc) return pool.release(dbc)

    // should not happen, but just in case
    LOG._warn && LOG.warn(new Error('Release called without client. Please report this warning.'))
  }

  // REVISIT: should happen automatically after a configurable time
  async disconnect(tenant) {
    await pool.drain(tenant)
  }
}

module.exports = HanaDatabase
