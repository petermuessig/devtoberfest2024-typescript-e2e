'use strict'

const commons = require('../../odata-commons')
const ExpandItem = commons.uri.ExpandItem
const SelectItem = commons.uri.SelectItem
const QueryOption = commons.uri.UriInfo.QueryOptions
const TransformationKind = commons.uri.apply.Transformation.TransformationKind
const HttpMethod = commons.http.HttpMethod.Methods
const NotImplementedError = commons.errors.NotImplementedError

/**
 * ExpandHelper has utility methods for extracting and combining expand information.
 */
class ExpandHelper {
  /**
   * Merge expand information from a path into existing expand items.
   * @param {?(UriResource[])} pathSegments the path
   * @param {ExpandItem[]} items the expand information
   * @private
   */
  static _mergeExpandPathIntoExpandItems (pathSegments, items) {
    if (pathSegments[0].getNavigationProperty()) {
      let item = items.find(
        expItem => expItem.getPathSegments()[0].getNavigationProperty() === pathSegments[0].getNavigationProperty()
      )
      if (!item) item = new ExpandItem().setPathSegments([pathSegments[0]])
      if (pathSegments[1]) {
        if (pathSegments[1].getNavigationProperty()) {
          let innerItems = item.getOption(QueryOption.EXPAND) || []
          ExpandHelper._mergeExpandPathIntoExpandItems(pathSegments.slice(1), innerItems)
          if (innerItems.length) item.setOption(QueryOption.EXPAND, innerItems)
        }
        item.setOption(
          QueryOption.SELECT,
          (item.getOption(QueryOption.SELECT) || []).concat(new SelectItem().setPathSegments([pathSegments[1]]))
        )
      }
      if (!items.includes(item)) items.push(item)
    }
  }

  /**
   * Extract expand information from the $apply system query option.
   * @param {?(Transformation[])} transformations transformations from $apply system query option
   * @returns {ExpandItem[]} the extracted expand information
   * @private
   */
  static _getExpandFromApply (transformations) {
    let items = []
    if (!transformations) return items
    for (const transformation of transformations) {
      if (transformation.getKind() === TransformationKind.GROUP_BY) {
        for (const groupByItem of transformation.getGroupByItems()) {
          if (groupByItem.isRollupAll() || groupByItem.getRollup().length) {
            throw new NotImplementedError('Construction of expand items for rollup is not supported.')
          }
          const pathSegments = groupByItem.getPathSegments()
          if (!pathSegments.length) continue
          ExpandHelper._mergeExpandPathIntoExpandItems(pathSegments, items)
        }
      } else if (transformation.getKind() === TransformationKind.AGGREGATE) {
        items = []
      } else if (transformation.getKind() === TransformationKind.CONCAT) {
        for (const sequence of transformation.getSequences()) {
          const innerItems = ExpandHelper._getExpandFromApply(sequence)
          for (const innerItem of innerItems) {
            const pathSegments = innerItem.getPathSegments()
            if (innerItem.getOption(QueryOption.SELECT)) {
              for (const select of innerItem.getOption(QueryOption.SELECT)) {
                ExpandHelper._mergeExpandPathIntoExpandItems(pathSegments.concat(select.getPathSegments()), items)
              }
            } else {
              ExpandHelper._mergeExpandPathIntoExpandItems(pathSegments, items)
            }
          }
        }
      }
    }
    return items
  }

  /**
   * Extract expand information from the request.
   * @param {OdataRequest} request the request
   * @returns {ExpandItem[]} the extracted expand information
   */
  static getFinalExpand (request) {
    const uriInfo = request.getUriInfo()
    let expandItems = ExpandHelper._getExpandFromApply(uriInfo.getQueryOption(QueryOption.APPLY))
    if (!expandItems.length && request.getMethod() === HttpMethod.POST) expandItems = request.getDeepInsertExpand()
    if (!expandItems.length) expandItems = uriInfo.getQueryOption(QueryOption.EXPAND) || []
    return expandItems
  }
}

module.exports = ExpandHelper
