'use strict'

const DeserializationError = require('../errors/DeserializationError')

/** List of headers not allowed in batched requests */
const forbiddenHeaders = ['authorization', 'proxy-authorization', 'expect', 'from', 'max-forwards', 'range', 'TE']

/** Class containing method to validate batched requests */
class BatchValidator {
  /**
   * Validates batched requests for correct request IDs, headers, dependencies, ...
   * @param {OdataRequestInBatch[]} requests batched requests
   */
  static validate (requests) {
    /**
     * @type {Map.<string, OdataRequestInBatch>}
     * @private
     */
    let usedIds = new Map()

    /**
     * @type {Set<number>}
     * @private
     */
    let usedAtomicGroups = new Map()

    /**
     * @type {string}
     * @private
     */
    let lastUsedAtomicityGroupId = null

    let index = 0

    for (const request of requests) {
      const requestID = request.getOdataRequestId()
      const atomicityGroupId = request.getAtomicityGroupId()
      const dependsOn = request.getDependsOn()

      // CHECK - Forbidden headers
      for (const header of forbiddenHeaders) {
        if (request.getHeader(header)) {
          throw new DeserializationError(
            'Request in batch at position ' + index + " contains invalid header '" + header + "'"
          )
        }
      }

      // CHECK - Request ID must be filled
      if (!requestID) {
        throw new DeserializationError('Request in batch at position ' + index + ' must have a request ID')
      }

      // CHECK - Request IDs must be unique
      BatchValidator.assertUnique(usedIds, requestID, 'Request ID', index)
      usedIds.set(requestID, request)

      // CHECK - Request IDs must not collide with atomicity group IDs
      BatchValidator.assertUnique(usedAtomicGroups, requestID, 'Request ID', index)

      // CHECK - Atomicity groups must be continuous and unique
      if (atomicityGroupId !== lastUsedAtomicityGroupId) {
        if (atomicityGroupId) {
          BatchValidator.assertUnique(usedAtomicGroups, atomicityGroupId, 'Atomicity group', index)
          usedAtomicGroups.set(atomicityGroupId)
        }
        // CHECK - Atomicity group IDs must not collide with request IDs
        BatchValidator.assertUnique(usedIds, atomicityGroupId, 'Atomicity group', index)
      }

      for (const id of dependsOn) {
        // CHECK - no self referencing
        if (id === requestID) {
          throw new DeserializationError('Request in batch at position ' + index + " depends on own ID '" + id + "'")
        }

        // CHECK - IDs in dependsOn list must already have been collected as atomicity group or as request
        if (!usedIds.has(id) && !usedAtomicGroups.has(id)) {
          throw new DeserializationError(
            'Request in batch at position ' +
              index +
              ' depends on unknown ' +
              "request/atomicity group with ID '" +
              id +
              "'"
          )
        }

        if (usedIds.has(id)) {
          // CHECK - if request ID in dependOn references a request
          // then the request's atomicity group must also referenced
          const requiredAtomicityGroup = usedIds.get(id).getAtomicityGroupId()
          if (
            requiredAtomicityGroup &&
            requiredAtomicityGroup !== atomicityGroupId &&
            !dependsOn.includes(requiredAtomicityGroup)
          ) {
            throw new DeserializationError(
              'Request in batch at position ' +
                index +
                " depends on request with ID '" +
                id +
                "'" +
                ' whose atomicity group ' +
                requiredAtomicityGroup +
                ' must also be referenced'
            )
          }
        }
      }

      lastUsedAtomicityGroupId = atomicityGroupId
      index++
    }
  }

  /**
   * Assess that a key is not inside a map.
   * @param {Map.<string, Object>} map Map to be searched
   * @param {string} key Key which is search
   * @param {string} itemName item name
   * @param {number} index position
   */
  static assertUnique (map, key, itemName, index) {
    if (map.has(key)) {
      throw new DeserializationError(
        itemName + " '" + key + "' of request in batch at position " + index + ' already in use'
      )
    }
  }
}

module.exports = BatchValidator
