'use strict'

const commons = require('../../odata-commons')
const validateThat = commons.validator.ParameterValidator.validateThat
const HttpMethods = commons.http.HttpMethod.Methods
const ContentTypes = commons.format.ContentTypeInfo.ContentTypes

const OdataRequestInBatch = require('../core/OdataRequestInBatch')
const PlainHttpRequest = require('../core/PlainHttpRequest')
const DeserializationError = require('../errors/DeserializationError')

class BatchJsonDeserializer {
  constructor () {
    this._savedRequestIds = new Map()
    this._savedAtomicityGroupIds = new Set()
  }

  /**
   * Deserializes an OData batch in JSON.
   * @param {Array.<Object>} payload the batch payload requests
   * @returns {OdataRequestInBatch[]} the deserialized request
   */
  deserialize (payload) {
    validateThat('payload', payload)
      .notNullNorUndefined()
      .typeOf('object')
    validateThat('requests', payload.requests)
      .notNullNorUndefined()
      .array()
      .containsElementsOfType('object')

    const additionalProperty = Object.keys(payload).find(key => key !== 'requests')
    if (additionalProperty) throw new DeserializationError("Property '" + additionalProperty + "' is not allowed.")

    return payload.requests.map(requestObject => this._deserializeOdataRequestInBatch(requestObject))
  }

  /**
   * Deserializes a single OData request from a batch request in JSON.
   * @param {Object} requestObject a single request from the batch payload requests list
   * @returns {OdataRequestInBatch} the deserialized request
   * @private
   */
  _deserializeOdataRequestInBatch (requestObject) {
    validateThat('request', requestObject).notNullNorUndefined()
    validateThat('id', requestObject.id)
      .truthy()
      .typeOf('string')

    const method = requestObject.method
    validateThat('method', requestObject.method)
      .truthy()
      .typeOf('string')
    if (
      ![HttpMethods.DELETE, HttpMethods.GET, HttpMethods.PATCH, HttpMethods.POST, HttpMethods.PUT].includes(
        method.toUpperCase()
      )
    ) {
      throw new DeserializationError(
        "Method '" + method + "' is not allowed. Only DELETE, GET, PATCH, POST or PUT are."
      )
    }

    const url = requestObject.url
    validateThat('url', url)
      .notNullNorUndefined()
      .typeOf('string')

    const additionalProperty = Object.keys(requestObject).find(
      key => !['id', 'method', 'url', 'atomicityGroup', 'dependsOn', 'headers', 'body'].includes(key)
    )
    if (additionalProperty) throw new DeserializationError("Property '" + additionalProperty + "' is not allowed.")

    const id = requestObject.id
    if (this._savedRequestIds.has(id) || this._savedAtomicityGroupIds.has(id)) {
      throw new DeserializationError("Request ID '" + id + "' is not unique.")
    }
    this._savedRequestIds.set(id)

    const plainHttpRequest = new PlainHttpRequest()
      .setOdataRequestId(id)
      .setMethod(method)
      .setUri(url)

    const headers = requestObject.headers
    if (headers) plainHttpRequest.setHeaders(headers)

    const body = requestObject.body
    if (body !== null && body !== undefined) {
      const isJson = !headers || !headers['content-type'] || headers['content-type'].startsWith(ContentTypes.JSON)
      if (typeof body === 'object') {
        if (isJson) {
          plainHttpRequest.setBody(Buffer.from(JSON.stringify(body)))
        } else {
          throw new DeserializationError(
            'Content-Type must be application/json or one of its subtypes if the body is an object'
          )
        }
      } else if (typeof body === 'string') {
        if (headers && headers['content-type']) {
          if (isJson) throw new DeserializationError('JSON content must be an object')

          const isText = headers['content-type'].startsWith('text/')
          plainHttpRequest.setBody(Buffer.from(body, isText ? 'utf8' : 'base64'))
        } else {
          throw new DeserializationError('A Content-Type header has to be specified for a non JSON body')
        }
      } else {
        throw new DeserializationError('Body must either be a JSON object or a string.')
      }
      if (method.toUpperCase() === HttpMethods.GET || method.toUpperCase() === HttpMethods.DELETE) {
        throw new DeserializationError('A body must not be specified if the method is GET or DELETE.')
      }
    }

    let result = new OdataRequestInBatch(plainHttpRequest, id)

    const groupId = requestObject.atomicityGroup
    if (groupId !== undefined) {
      validateThat('atomicityGroup', groupId)
        .truthy()
        .typeOf('string')
      if (this._savedRequestIds.has(groupId)) {
        throw new DeserializationError("Atomicity group ID '" + groupId + "' is not unique.")
      }
      this._savedRequestIds.set(id, groupId)
      this._savedAtomicityGroupIds.add(groupId)
      result.setAtomicityGroupId(groupId)
    }

    const dependencies = requestObject.dependsOn
    if (dependencies) {
      validateThat('dependsOn', dependencies).array()
      for (const dependentRequestId of dependencies) {
        validateThat('dependent request ID', dependentRequestId)
          .truthy()
          .typeOf('string')
        if (!this._savedRequestIds.has(dependentRequestId) && !this._savedAtomicityGroupIds.has(dependentRequestId)) {
          throw new DeserializationError(
            "Request ID '" + dependentRequestId + "' used in dependsOn has not been defined before."
          )
        }
        // "If a request depends on another request that is part of a different atomicity group,
        // the atomicity group MUST be listed in dependsOn."
        const dependentGroup = this._savedRequestIds.get(dependentRequestId)
        if (dependentGroup && dependentGroup !== groupId && !dependencies.includes(dependentGroup)) {
          throw new DeserializationError(
            "The group '" +
              dependentGroup +
              "' of the referenced request '" +
              dependentRequestId +
              "' must be listed in dependsOn of request '" +
              id +
              "'."
          )
        }
        result.addDependsOn(dependentRequestId)
      }
    }
    // The URL may contain a reference to the result of another request.
    // "The id of this request MUST be specified in the dependsOn".
    const referencedId = result.getReferencedId()
    if (referencedId && !(dependencies && dependencies.includes(referencedId))) {
      throw new DeserializationError("Request '" + id + "' must depend on request '" + referencedId + "'.")
    }

    return result
  }
}

module.exports = BatchJsonDeserializer
