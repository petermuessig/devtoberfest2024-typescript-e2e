'use strict'

const commons = require('../../odata-commons')
const HttpStatusCodes = commons.http.HttpStatusCode.StatusCodes
const HttpMethods = commons.http.HttpMethod.Methods
const RepresentationKinds = commons.format.RepresentationKind.Kinds
const ResourceKind = commons.uri.UriResource.ResourceKind
const ErrorNames = commons.errors.AbstractError.ErrorNames

/**
 * Determine the HTTP status code.
 * @hideconstructor
 */
class HttpStatusCode {
  /**
   * Resolves the status code in the success case.
   * @param {OdataRequest} request the current OData request
   * @param {OdataResponse} response the current OData response
   * @returns {?HttpStatusCode.StatusCodes} The resolved statuscode or null if no statuscode could be resolved
   * @package
   */
  static resolveSuccessStatusCode (request, response) {
    const statuscode = response.getStatusCode()
    if (statuscode !== HttpStatusCodes.OK) return statuscode

    const representationKind = response.getContract().getRepresentationKind()
    if (
      representationKind === RepresentationKinds.SERVICE ||
      representationKind === RepresentationKinds.METADATA ||
      representationKind === RepresentationKinds.BATCH
    ) {
      return HttpStatusCodes.OK
    }
    if (representationKind === RepresentationKinds.NO_CONTENT) return HttpStatusCodes.NO_CONTENT

    const body = response.getBody()
    const bodyValue = body ? body.value : null

    const methodString = request.getMethod()
    if (methodString === HttpMethods.GET || methodString === HttpMethods.PATCH || methodString === HttpMethods.PUT) {
      return bodyValue === null ? HttpStatusCodes.NO_CONTENT : HttpStatusCodes.OK
    } else if (methodString === HttpMethods.POST) {
      const lastSegmentKind = request
        .getUriInfo()
        .getLastSegment()
        .getKind()
      if (lastSegmentKind === ResourceKind.ACTION_IMPORT || lastSegmentKind === ResourceKind.BOUND_ACTION) {
        return bodyValue === null ? HttpStatusCodes.NO_CONTENT : HttpStatusCodes.OK
      }
      return HttpStatusCodes.CREATED
    } else if (methodString === HttpMethods.DELETE) {
      return HttpStatusCodes.NO_CONTENT
    }

    return null
  }

  /**
   * Resolves the status code in the error case.
   * @param {OdataRequest} request the current OData request
   * @param {OdataResponse} response the current OData response
   * @param {Error} error The error in this error case
   * @returns {HttpStatusCode.StatusCodes|number} The resolved statuscode
   * @package
   */
  static resolveErrorStatusCode (request, response, error) {
    switch (error.name) {
      case ErrorNames.URI_SEMANTIC:
      case ErrorNames.NOT_FOUND:
        return HttpStatusCodes.NOT_FOUND

      case ErrorNames.URI_QUERY_OPTION_SEMANTIC:
      case ErrorNames.URI_SYNTAX:
      case ErrorNames.DESERIALIZATION:
      case ErrorNames.BAD_REQUEST:
        return HttpStatusCodes.BAD_REQUEST

      case ErrorNames.NOT_IMPLEMENTED:
        return HttpStatusCodes.NOT_IMPLEMENTED

      case ErrorNames.METHOD_NOT_ALLOWED:
        return HttpStatusCodes.METHOD_NOT_ALLOWED

      case ErrorNames.NOT_ACCEPTABLE:
        return HttpStatusCodes.NOT_ACCEPTABLE

      case ErrorNames.NOT_AUTHORIZED:
        return HttpStatusCodes.UNAUTHORIZED

      case ErrorNames.INTERNAL_SERVER_ERROR:
        return HttpStatusCodes.INTERNAL_SERVER_ERROR

      case ErrorNames.PRECONDITION_FAILED_ERROR:
        return HttpStatusCodes.PRECONDITION_FAILED

      case ErrorNames.PRECONDITION_REQUIRED_ERROR:
        return HttpStatusCodes.PRECONDITION_REQUIRED

      case ErrorNames.CONFLICT:
        return HttpStatusCodes.CONFLICT

      default:
        return error.statusCode || HttpStatusCodes.INTERNAL_SERVER_ERROR
    }
  }

  /**
   * Resolves the status code in the debug-output case.
   * @returns {HttpStatusCode.StatusCodes} The resolved statuscode
   * @package
   */
  static resolveDebugStatusCode () {
    return HttpStatusCodes.OK
  }
}

module.exports = HttpStatusCode
