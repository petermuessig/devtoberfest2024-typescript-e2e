const cds = require('../../../cds')
// requesting logger without module on purpose!
const LOG = cds.log()

const {
  BatchExitHandler: { ATOMICITY_GROUP_START, ATOMICITY_GROUP_END },
  Components: {
    DATA_CREATE_HANDLER,
    DATA_DELETE_HANDLER,
    DATA_READ_HANDLER,
    DATA_UPDATE_HANDLER,
    ACTION_EXECUTE_HANDLER,
    LOCALE_NEGOTIATOR,
    METADATA_HANDLER
  }
} = require('./okra/odata-server')

const _config = require('./utils/oDataConfiguration')
const _error = require('./handlers/error')
const _debug = require('./handlers/debug')
const _request = require('./handlers/request')
const _language = require('./handlers/language')
const _metadata = require('./handlers/metadata')
const _create = require('./handlers/create')
const _update = require('./handlers/update')
const _delete = require('./handlers/delete')
const _read = require('./handlers/read')
const _action = require('./handlers/action')
const { normalizeError, isClientError } = require('../../../common/error/frontend')
const { getErrorMessage } = require('../../../common/error/utils')

function _log(level, arg) {
  const { params } = arg

  // cds.log() called with multiple args or first arg not an object or string? -> pass through
  if (params.length !== 1 || (typeof params[0] !== 'object' && typeof params[0] !== 'string')) {
    LOG[level](arg)
    return
  }

  // single arg of type object (from string, if necessary)
  const obj = typeof params[0] === 'object' ? params[0] : { message: params[0] }

  // augment
  if (!obj.id) obj.id = arg.id
  if (!obj.level) obj.level = arg.level
  if (!obj.timestamp) obj.timestamp = arg.timestamp

  // replace messages in toLog with developer texts (i.e., undefined locale) (cf. req.reject() etc.)
  const _message = obj.message
  const _code = obj.code
  const _details = obj.details

  // REVISIT: the (ugly!) stuff re code is somewhat of a duplicate to what we do in normalizeError -> refactor with new adapters!
  obj.message = getErrorMessage(obj)
  if (_code) obj.code = obj.code.match?.(/^ASSERT_/) ? 400 : obj.code
  if (_details) {
    const details = []
    const codes = new Set()
    for (const d of obj.details) {
      const entry = Object.assign({}, d, { message: getErrorMessage(d) })
      if (!_code) {
        const k = d.statusCode ? 'statusCode' : d.status ? 'status' : d.code ? 'code' : undefined
        const v = d[k]?.match?.(/^ASSERT_/) ? 400 : d[k]
        codes.add(v)
        entry[k] = v
      }
      details.push(entry)
    }
    obj.details = details
    if (!_code && codes.size === 1) {
      const n = Number(codes.values().next().value)
      if (!isNaN(n)) obj.code = n
    }
  }

  // reduce 4xx to warning
  if (level === 'error') if (isClientError(obj)) level = 'warn'

  // log it
  LOG[`_${level}`] && LOG[level](obj)

  // restore
  obj.message = _message
  if (_code) obj.code = _code
  if (_details) obj.details = _details
}

const _logger = {
  debug: arg => LOG._debug && _log('debug', arg),
  path: () => {},
  info: arg => LOG._info && _log('info', arg),
  warning: arg => LOG._warn && _log('warn', arg),
  error: arg => _log('error', arg),
  fatal: arg => _log('error', arg)
}

/**
 * Facade for creating an instance of a EDM based OData service.
 *
 * @alias module:odata.OData
 */
class OData {
  /**
   * Constructs an OData service for the given EDM model.
   *
   * @param {object} edm - the EDM model.
   * @param {object} csn
   * @param {object} [options] - optional object with options.
   * @param {object} [options.logger] - optional logger object to be used in the odata library.
   * @param {string} [options.logLevel] - optional log level to be used according to winston/npm specification.
   * @param {boolean} [options.crashOnError] - Application should crash on error. Defaults to true.
   *
   * @throws Error in case no or an invalid csn model is provided.
   */
  constructor(edm, csn, options = {}) {
    this._validateEdm(edm)
    this._options = options
    this._createOdataService(edm, csn)
  }

  _validateEdm(edm) {
    if (typeof edm !== 'object' || !edm.$Version) {
      const { getModelNotDefinedError } = require('../../util/errors')
      throw getModelNotDefinedError('EDM model')
    }
  }

  _createOdataService(edm, csn) {
    const ServiceFactory = require('./okra/odata-server').ServiceFactory

    // skip okra's validation in production or implicitly for w4 and x4
    const { effective } = cds.env
    const isTrusted =
      process.env.NODE_ENV === 'production' ||
      !Object.prototype.hasOwnProperty.call(cds.env.odata, 'skipValidation') ||
      cds.env.odata.skipValidation ||
      effective.odata.containment ||
      effective.odata.structs ||
      effective.odata.refs ||
      effective.odata.proxies ||
      effective.odata.xrefs

    this._odataService = ServiceFactory.createService(edm, _config(edm, csn, this._options)).trust(isTrusted)

    // will be added to express app like app.use('/base/path/', service) and odata-v4 wants app.use('/', service) if basePath is set
    this._odataService.setBasePath('/')
  }

  /**
   * The added cds service will be used at the handlers.
   * Some channel events have a 1:N relation to service handler events.
   *
   * @param {Service} cdsService
   */
  addCDSServiceToChannel(cdsService) {
    // use cds.log and preserve everything
    this._odataService.log(_logger, arg => arg)

    this._cdsService = cdsService

    this._odataService.on('error', _error(this._options.crashOnError, cdsService))
    if (this._options.debug) this._odataService.on('debug', _debug)
    this._odataService.on('request', _request(cdsService))

    this._odataService.on(ATOMICITY_GROUP_START, (odataContext, done) => {
      const data = odataContext.applicationData

      // start tx
      const txs = (data.txs = data.txs || {})
      const { req, res } = data
      const tx = (txs[odataContext.id] = cdsService.tx({ req, res }))
      cds.context = tx.context
      // for collecting results and errors
      data.results = data.results || {}
      data.results[odataContext.id] = []
      data.errors = data.errors || {}
      data.errors[odataContext.id] = []
      done()
    })

    this._odataService.on(ATOMICITY_GROUP_END, async (odataErr, odataContext, done) => {
      const tx = odataContext.applicationData.txs[odataContext.id]
      let errors = odataErr || odataContext.failedRequests.length > 0

      if (errors) {
        // rollback without errors to not trigger srv.on('error') with array
        await tx.rollback()

        done()
        return
      }

      try {
        await tx.commit(odataContext.applicationData.results[odataContext.id])
        done()
      } catch (e) {
        // tx gets rolled back automatically
        // set error on each request of changeset, if commit failed
        const changesetResults = odataContext.applicationData.results[odataContext.id]
        const failedRequests = changesetResults.reduce((obj, resultEntry) => {
          const requestId = resultEntry.req._.odataReq.getOdataRequestId()
          const { error, statusCode } = normalizeError(e, resultEntry.req)
          obj[requestId] = Object.assign(error, { statusCode })
          return obj
        }, {})

        done(e, { failedRequests })
      }
    })

    this._odataService.use(LOCALE_NEGOTIATOR, _language)
    this._odataService.use(METADATA_HANDLER, _metadata(cdsService))

    this._odataService.use(DATA_CREATE_HANDLER, _create(cdsService))
    this._odataService.use(DATA_READ_HANDLER, _read(cdsService))
    this._odataService.use(DATA_UPDATE_HANDLER, _update(cdsService))
    this._odataService.use(DATA_DELETE_HANDLER, _delete(cdsService))

    this._odataService.use(ACTION_EXECUTE_HANDLER, _action(cdsService))
    return this
  }

  /**
   * Process request.
   *
   * @param {http.IncomingMessage} req
   * @param {http.ServerResponse} res
   * @private
   */
  // REVISIT: Remove this when we replaced Okra
  process(req, res) {
    // NOTE: do none of this header manipulation in okra successor!
    // if ExponentialDecimals=true is set in accept header, ensure IEEE754Compatible=true (use case unclear, but don't introduce regression)
    // if IEEE754Compatible=true is set in accept header, but ExponentialDecimals is not specified, set it based on cds.env.odata.defaultExponentialDecimals
    const acceptHeader = req.headers.accept
    if (acceptHeader?.startsWith('application/json')) {
      if (acceptHeader.includes('ExponentialDecimals=true') && !acceptHeader.includes('IEEE754Compatible')) {
        req.headers.accept += ';IEEE754Compatible=true'
      } else if (
        'defaultExponentialDecimals' in cds.env.odata &&
        acceptHeader.includes('IEEE754Compatible=true') &&
        !acceptHeader.includes('ExponentialDecimals')
      ) {
        req.headers.accept += `;ExponentialDecimals=${cds.env.odata.defaultExponentialDecimals}`
      }
    }
    // add IEEE754Compatible=true if !strict_numbers
    const contentType = req.headers['content-type']
    if (
      !cds.env.features.strict_numbers &&
      contentType?.includes('application/json') &&
      !contentType.includes('IEEE754Compatible')
    ) {
      req.headers['content-type'] = contentType.replace('application/json', 'application/json;IEEE754Compatible=true')
    }

    // this._startPerfMeasurementOData(req)
    this._odataService.process(req, res).catch(err => {
      LOG.warn(err)
      // REVISIT: use i18n
      // do not reply with error, if response already processed (streaming)
      // destroy response socket instead
      if (res.headersSent) {
        // REVISIT: temp solution until streaming is switched to express middlewares
        res.socket?.destroy()
      } else {
        const { error, statusCode } = normalizeError(err, req)
        res.status(statusCode).send({ error })
      }
    })
  }
}

module.exports = OData
