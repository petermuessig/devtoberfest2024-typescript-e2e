const cds = require('../../../cds')

const {
  uri: {
    UriResource: {
      ResourceKind: { BOUND_ACTION, BOUND_FUNCTION, ACTION_IMPORT, FUNCTION_IMPORT }
    }
  }
} = require('./okra/odata-server')

const { findCsnTargetFor } = require('../../../common/utils/csn')
const metaInfo = require('./utils/metaInfo')
const odataToCQN = require('./odata-to-cqn')
const { getData, getParams } = require('./utils/data')
const { isCustomOperation } = require('./utils/request')
const { isStreaming } = require('./utils/stream')
const { handleStreamProperties } = require('../../../common/utils/streamProp')

function _isCorrectCallToViewWithParams(csdlStructuredType) {
  return (
    csdlStructuredType.navigationProperties &&
    csdlStructuredType.navigationProperties[0] &&
    csdlStructuredType.navigationProperties[0].name === 'Parameters' &&
    csdlStructuredType.navigationProperties[0].partner === 'Set'
  )
}

function _getTarget(service, segments) {
  let last = segments.pop()

  if (!last || last.getKind() === ACTION_IMPORT || last.getKind() === FUNCTION_IMPORT) {
    return
  }

  if (last.getKind() === BOUND_FUNCTION || last.getKind() === BOUND_ACTION) {
    last = segments.pop()
  }

  if (last.getEdmType() && last.getEdmType().csdlStructuredType) {
    const { namespace } = last.getEdmType().getFullQualifiedName()
    // REVISIT: better way to identify situation "view with parameters"
    const name = _isCorrectCallToViewWithParams(last.getEdmType().csdlStructuredType)
      ? last.getEdmType().csdlStructuredType.navigationProperties[0].type.name
      : last.getEdmType().csdlStructuredType.name

    // autoexposed entities now used . in csn and _ in edm
    const target = findCsnTargetFor(name, service.model, namespace)

    if (target && target.kind === 'entity') {
      return target
    }
  }

  return _getTarget(service, segments)
}

function _add4Odata(query) {
  if (Array.isArray(query))
    for (let i = 0; i < query.length; i++) Object.defineProperty(query[i].SELECT, '_4odata', { value: true })
  else Object.defineProperty(query.SELECT, '_4odata', { value: true })
}

function _addAllColumns(query) {
  if (Array.isArray(query)) {
    query.forEach(q => {
      if (!q.SELECT.from.SELECT) _addAllColumns(q)
    })
  } else {
    if (!query.SELECT.columns) query.SELECT.columns = ['*']
  }
}

function _handleStreamProperties(target, query, model) {
  if (Array.isArray(query)) {
    query.forEach(q => {
      _handleStreamProperties(target, q, model)
    })
  } else {
    handleStreamProperties(target, query.SELECT.columns, model)
  }
}

/**
 * Class representing an OData request.
 * @extends cds.Request
 *
 * @param {string} type - The OData request type (a.k.a. "Component")
 * @param {import('../../../common/Service')} service - The underlying CAP service
 * @param {import('./okra/odata-server/core/OdataRequest')} odataReq - OKRA's req
 * @param {import('./okra/odata-server/core/OdataResponse')} odataRes - OKRA's res
 */
class ODataRequest extends cds.Request {
  constructor(type, service, odataReq, odataRes, upsert) {
    const req = odataReq.getBatchApplicationData()
      ? odataReq.getBatchApplicationData().req
      : odataReq.getIncomingRequest()
    const res = req.res
    const segments = odataReq.getUriInfo().getPathSegments()

    if (cds.env.features.odata_new_parser) {
      // REVISIT need to resolve target after replacing okra <= maybe just take one from afterburner?
      const target = _getTarget(service, [...segments])
      // REVISIT payload after replacing okra
      const data = getData(type, odataReq, service, target)
      const query = odataToCQN(type, service, target, data, odataReq, upsert)
      const headers = Object.assign({}, req.headers, odataReq.getHeaders())
      // REVISIT needed in case of $batch, replace after removing okra
      const method = odataReq.getIncomingRequest().method
      const { user, tenant } = cds.context
      const info = metaInfo(query, type, service, data, req, upsert)
      const { event, unbound } = info
      if (event === 'READ') {
        _add4Odata(query)
        _addAllColumns(query)
        if (!isStreaming(segments)) _handleStreamProperties(target, query, service.model)
      }
      const _queryOptions = odataReq.getQueryOptions()
      // prettier-ignore
      super({ event, target, data, query: unbound ? {} : query, user, tenant, method, headers, req, res, _queryOptions })
      this._metaInfo = info.metadata
    } else {
      /*
       * target
       */
      const target = _getTarget(service, [...segments])

      /*
       * data
       */
      const data = getData(type, odataReq, service, target)

      /*
       * query
       */
      const operation = isCustomOperation(segments) ? odataReq.getUriInfo().getLastSegment().getKind() : type
      const query = odataToCQN(operation, service, target, data, odataReq, upsert)

      /*
       * event
       */
      let event = type

      // actions & functions
      const uriInfoLastSegment = odataReq.getUriInfo().getLastSegment()

      switch (uriInfoLastSegment && uriInfoLastSegment.getKind()) {
        case 'BOUND.ACTION':
          event = uriInfoLastSegment.getAction().getName()
          break

        case 'ACTION.IMPORT':
          event = uriInfoLastSegment.getActionImport().getName()
          break

        case 'BOUND.FUNCTION':
          event = uriInfoLastSegment.getFunction().getName()
          break

        case 'FUNCTION.IMPORT':
          event = uriInfoLastSegment.getFunctionImport().getName()
          break

        // no default
      }

      // draft
      if (target && target._isDraftEnabled) {
        if (type === 'CREATE') event = 'NEW'
        else if (event === 'draftEdit') event = 'EDIT'
        else if (type === 'UPDATE') event = 'PATCH'
        else if (type === 'DELETE' && data.IsActiveEntity !== true) event = 'CANCEL'
      }

      // mark query as for an OData READ
      if (event === 'READ') Object.defineProperty(query.SELECT, '_4odata', { value: true })

      /*
       * method, headers
       */
      const method = odataReq.getMethod()

      // REVISIT: Why do we mix headers of $batch and batched request headers??
      const headers = Object.assign({}, req.headers, odataReq.getHeaders())

      /*
       * super
       */
      const { user, tenant } = cds.context
      // REVISIT: public API for query options (express style req.query already in use)?
      const _queryOptions = odataReq.getQueryOptions()
      super({ event, target, data, query, user, method, headers, req, res, _queryOptions, tenant })
    }

    /*
     * req.params
     */
    Object.defineProperty(this, 'params', {
      configurable: true,
      get: function () {
        this._params = this._params || getParams(odataReq)
        return this._params
      }
    })

    /*
     * REVISIT: compat req._.*
     */
    // odataReq and odataRes
    this._.odataReq = odataReq
    this._.odataRes = odataRes

    Object.defineProperty(this, 'protocol', { value: 'odata' })
  }
}

module.exports = ODataRequest
