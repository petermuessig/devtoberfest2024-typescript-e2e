'use strict'

const EdmTypeKind = require('../edm/EdmType').TypeKind
const EdmPrimitiveTypeKind = require('../edm/EdmPrimitiveTypeKind')
const ValueConverter = require('./ValueConverter')
const ValueValidator = require('../validator/ValueValidator')
const UriHelper = require('../uri/UriHelper')
const JsonContentTypeInfo = require('../format/JsonContentTypeInfo')
const IllegalArgumentError = require('../errors/IllegalArgumentError')

/**
 * The primitive-value encoder encodes primitive values, using OData V4 primitive types.
 * The following mapping of V2 and V4 primitive types is assumed:
 *         V4        |        V2
 * ------------------|------------------
 *  Date             | DateTime
 *  DateTimeOffset   | DateTimeOffset
 *  Duration         | String
 *  TimeOfDay        | Time
 */
class PrimitiveValueEncoder {
  /**
   * Constructor
   * @param {string} [version = '4.0'] the OData version
   */
  constructor (version = '4.0') {
    this._version = version
    this._formatParameters =
      version === '2.0'
        ? new JsonContentTypeInfo().addParameter(JsonContentTypeInfo.FormatParameter.IEEE754, 'true')
        : null
    this._validator = new ValueValidator('encode')
    this._converter = new ValueConverter(this._validator, this._formatParameters)
  }

  /**
   * Set optional JSON formatting parameters.
   * @param {?JsonContentTypeInfo} formatParameters JSON serializing options
   * @returns {PrimitiveValueEncoder} this instance
   */
  setJsonFormatParameters (formatParameters) {
    this._formatParameters = formatParameters
    this._converter = new ValueConverter(this._validator, formatParameters)
    return this
  }

  /**
   * Encode a JavaScript value into the OData JSON representation.
   * @param {?(string|number|boolean|Buffer|Object)} value the JavaScript value
   * @param {EdmProperty|EdmReturnType|EdmTerm} propertyOrReturnType the EDM property, return type, or term
   * @returns {?(string|number|boolean|Object)} the JSON value
   */
  encodeJson (value, propertyOrReturnType) {
    if (value === null || value === undefined) {
      if (propertyOrReturnType.isNullable()) return null
      throw new IllegalArgumentError(
        'Value ' +
          (propertyOrReturnType.getName ? "for '" + propertyOrReturnType.getName() + "' " : '') +
          'must not be null'
      )
    }
    return this._version === '2.0'
      ? this._encodeV2Json(propertyOrReturnType, value)
      : this._converter.convert(propertyOrReturnType, value)
  }

  /**
   * Encode a JavaScript value into the OData URI representation.
   * @param {?(string|number|boolean|Buffer|Object)} value the JavaScript value
   * @param {EdmProperty|EdmReturnType|EdmTerm} propertyOrReturnType the EDM property, return type, or term
   * @returns {string} the URI string
   */
  encodeUri (value, propertyOrReturnType) {
    if (value === null || value === undefined) {
      if (propertyOrReturnType.isNullable()) return 'null'
      throw new IllegalArgumentError(
        'Value ' +
          (propertyOrReturnType.getName ? "for '" + propertyOrReturnType.getName() + "' " : '') +
          'must not be null'
      )
    }
    return this._version === '2.0'
      ? this._encodeV2Uri(propertyOrReturnType, value)
      : UriHelper.toUriLiteral(this._encodeV4Text(propertyOrReturnType, value), propertyOrReturnType.getType())
  }

  /**
   * Encode a JavaScript value into the OData plain-text representation.
   * @param {string|number|boolean|Buffer|Object} value the JavaScript value
   * @param {EdmProperty|EdmReturnType|EdmTerm} propertyOrReturnType the EDM property, return type, or term
   * @returns {string} the plain-text string
   */
  encodeText (value, propertyOrReturnType) {
    if (value === null || value === undefined) {
      throw new IllegalArgumentError(
        'Value ' +
          (propertyOrReturnType.getName ? "for '" + propertyOrReturnType.getName() + "' " : '') +
          'must not be null nor undefined'
      )
    }
    return this._version === '2.0'
      ? this._encodeV2Text(propertyOrReturnType, value)
      : this._encodeV4Text(propertyOrReturnType, value)
  }

  /**
   * Encode a JavaScript value into the OData V4 plain-text representation.
   * @param {EdmProperty|EdmReturnType} propertyOrReturnType the EDM property or return type
   * @param {string|number|boolean|Buffer|Object} value the JavaScript value
   * @returns {string} the plain-text string
   * @private
   */
  _encodeV4Text (propertyOrReturnType, value) {
    let type = propertyOrReturnType.getType()
    if (type.getKind() === EdmTypeKind.DEFINITION) type = type.getUnderlyingType()

    if (type.getName().startsWith('Geo')) {
      try {
        this._converter.convert(propertyOrReturnType, value) // to check input
      } catch (error) {
        throw new IllegalArgumentError('Invalid geo data', error)
      }

      let srid = propertyOrReturnType.getSrid()
      if (srid === null && propertyOrReturnType.getType().getKind() === EdmTypeKind.DEFINITION) {
        srid = propertyOrReturnType.getType().getSrid()
      }
      if (srid === 'variable') throw new IllegalArgumentError('Variable coordinate systems are not supported.')
      if (srid === null) srid = type.getName().startsWith('Geography') ? 4326 : 0

      return (
        'SRID=' +
        srid +
        ';' +
        (value.type === 'GeometryCollection' ? 'Collection' : value.type) +
        '(' +
        this._serializeGeoData(value) +
        ')'
      )
    }

    // The result is a string, so the parameter to format according to IEEE754 can be set unconditionally.
    // This is needed, e.g., for large Int64 values.
    return String(
      new ValueConverter(
        this._validator,
        new JsonContentTypeInfo().addParameter(JsonContentTypeInfo.FormatParameter.IEEE754, 'true')
      ).convert(propertyOrReturnType, value)
    )
  }

  /**
   * Serializes data for a geo type in "Well-Known Text" (WKT) format.
   * @param {Array} data the data
   * @returns {string} serialized representation in WKT format
   * @private
   */
  _serializeGeoData (data) {
    switch (data.type) {
      case 'Point':
        return data.coordinates.join(' ')
      case 'LineString':
        return data.coordinates.map(point => point.join(' ')).join(',')
      case 'Polygon':
        return data.coordinates.map(ring => '(' + ring.map(point => point.join(' ')) + ')').join(',')
      case 'MultiPoint':
        return data.coordinates.map(point => '(' + point.join(' ') + ')').join(',')
      case 'MultiLineString':
        return data.coordinates.map(linestring => '(' + linestring.map(point => point.join(' ')) + ')').join(',')
      case 'MultiPolygon':
        return data.coordinates
          .map(polygon => '(' + polygon.map(ring => '(' + ring.map(point => point.join(' ')) + ')').join(',') + ')')
          .join(',')
      case 'GeometryCollection':
        return data.geometries
          .map(geoObject => geoObject.type + '(' + this._serializeGeoData(geoObject) + ')')
          .join(',')
      default:
        throw new IllegalArgumentError('Unknown geo type ' + data.type)
    }
  }

  /**
   * Encode a JavaScript value into the OData V2 JSON representation.
   * @param {EdmProperty|EdmReturnType} propertyOrReturnType the EDM property or return type
   * @param {?(string|number|boolean|Buffer)} value the JavaScript value
   * @returns {?(string|number|boolean)} the JSON value
   * @private
   */
  _encodeV2Json (propertyOrReturnType, value) {
    let result = this._converter.convert(propertyOrReturnType, value) // This also checks the value.
    switch (propertyOrReturnType.getType()) {
      case EdmPrimitiveTypeKind.Date:
        result = this._encodeDateTimeOffset(value + 'T00:00:00Z')
        break
      case EdmPrimitiveTypeKind.DateTimeOffset:
        result = this._encodeDateTimeOffset(value)
        break
      case EdmPrimitiveTypeKind.TimeOfDay:
        result =
          'PT' +
          result.substring(0, 2) +
          'H' +
          result.substring(3, 5) +
          'M' +
          (result.substring(6) ? result.substring(6) + 'S' : '')
        break
      case EdmPrimitiveTypeKind.Single:
      case EdmPrimitiveTypeKind.Double:
        result = result === 'NaN' ? 'Nan' : String(result)
        break
      default:
        break
    }
    return result
  }

  /**
   * Encode a JavaScript value into the OData V2 URI representation.
   * @param {EdmProperty|EdmReturnType} propertyOrReturnType the EDM property or return type
   * @param {?(string|number|boolean|Buffer)} value the JavaScript value
   * @returns {string} the URI string
   * @private
   */
  _encodeV2Uri (propertyOrReturnType, value) {
    let result = this._encodeV2Json(propertyOrReturnType, value) // This also checks the value.
    switch (propertyOrReturnType.getType()) {
      case EdmPrimitiveTypeKind.Binary:
        result = "X'" + value.toString('hex') + "'"
        break
      case EdmPrimitiveTypeKind.Boolean:
      case EdmPrimitiveTypeKind.Byte:
      case EdmPrimitiveTypeKind.Int16:
      case EdmPrimitiveTypeKind.Int32:
      case EdmPrimitiveTypeKind.SByte:
        result = String(result)
        break
      case EdmPrimitiveTypeKind.Int64:
        result += 'L'
        break
      case EdmPrimitiveTypeKind.Decimal:
        result += 'M'
        break
      case EdmPrimitiveTypeKind.Double:
        result = (result === 'INF') | (result === '-INF') || result === 'Nan' ? result : result + 'D'
        break
      case EdmPrimitiveTypeKind.Single:
        result = (result === 'INF') | (result === '-INF') || result === 'Nan' ? result : result + 'F'
        break
      case EdmPrimitiveTypeKind.Guid:
        result = "guid'" + result + "'"
        break
      case EdmPrimitiveTypeKind.String:
        result = "'" + result.replace(/'/g, "''") + "'"
        break
      case EdmPrimitiveTypeKind.Date:
        result = "datetime'" + value + "T00:00:00'"
        break
      case EdmPrimitiveTypeKind.DateTimeOffset:
        result = "datetimeoffset'" + value + "'"
        break
      case EdmPrimitiveTypeKind.TimeOfDay:
        result = "time'" + result + "'"
        break
      case EdmPrimitiveTypeKind.Duration:
        result = "'" + result + "'"
        break
      default:
        break
    }
    return result
  }

  /**
   * Encode a JavaScript value into the OData V2 plain-text representation.
   * @param {EdmProperty|EdmReturnType} propertyOrReturnType the EDM property or return type
   * @param {string|number|boolean|Buffer} value the JavaScript value
   * @returns {string} the plain-text string
   * @private
   */
  _encodeV2Text (propertyOrReturnType, value) {
    let result = String(this._encodeV2Json(propertyOrReturnType, value)) // This also checks the value.
    switch (propertyOrReturnType.getType()) {
      case EdmPrimitiveTypeKind.Binary:
        result = value.toString()
        break
      case EdmPrimitiveTypeKind.Date:
        result = value + 'T00:00:00'
        break
      case EdmPrimitiveTypeKind.DateTimeOffset:
        result = value
        break
      default:
        break
    }
    return result
  }

  /**
   * Encodes a date-time-offset value into V2 JSON.
   * @param {string} value V4 Edm.DateTimeOffset with form "YYYY-MM-DDThh:mm:ss.s(Z|[+-]hh:mm)"
   * @returns {string} V2 Edm.DateTime with form "/Date(millis)/"
   * @private
   */
  _encodeDateTimeOffset (value) {
    let indexTimeZone
    let offset
    if (value.endsWith('Z')) {
      indexTimeZone = value.length - 1
      offset = ''
    } else {
      indexTimeZone = value.length - 6
      offset =
        Number(value.substring(value.length - 5, value.length - 3)) * 60 +
        Number(value.substring(value.length - 2, value.length))
      offset = String(offset)
      while (offset.length < 4) offset = '0' + offset
      offset = value.substring(value.length - 6, value.length - 5) + offset
    }

    let fract = value.indexOf('.') > -1 ? value.substring(value.indexOf('.') + 1, indexTimeZone) : '0'
    while (fract.length > 3 && fract.endsWith('0')) fract = fract.substring(0, fract.length - 1)
    if (fract.length > 3) {
      throw new IllegalArgumentError(
        "The Edm.DateTimeOffset value '" +
          value +
          "' has more than three digits for fractional seconds; this is not supported."
      )
    }
    while (fract.length < 3) fract += '0'

    const year = Number(value.substring(0, 4))
    let millis = Date.UTC(
      year,
      value.substring(5, 7) - 1,
      value.substring(8, 10),
      value.substring(11, 13),
      value.substring(14, 16),
      value.substring(17, 19),
      fract
    )
    // Date.UTC converts two-digit years by adding 1900 to the year, so we have to correct that.
    if (year >= 0 && year < 100) millis -= (1900 * 365 + 1900 / 4 - 1900 / 100 + 4) * 24 * 60 * 60 * 1000

    return '/Date(' + millis + offset + ')/'
  }
}

module.exports = PrimitiveValueEncoder
