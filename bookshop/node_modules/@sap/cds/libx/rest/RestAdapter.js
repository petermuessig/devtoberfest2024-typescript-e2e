const cds = require('../_runtime/cds')

const parse = require('./middleware/parse')
const create = require('./middleware/create')
const read = require('./middleware/read')
const update = require('./middleware/update')
const deleet = require('./middleware/delete')
const operation = require('./middleware/operation')
const error = require('./middleware/error')

const { bufferToBase64 } = require('../_runtime/common/utils/binary')

const HttpAdapter = require('../../lib/srv/protocols/http')
const bodyParser4 = require('../odata/middleware/body-parser')

// REVISIT: ugly hack -> eliminate
const { NoaRequest } = require('../odata/ODataAdapter')
class RestRequest extends NoaRequest {
  get protocol() {
    return 'rest'
  }
}

class RestAdapter extends HttpAdapter {
  request4(args) {
    return new RestRequest(args)
  }

  get router() {
    const srv = this.service
    const router = super.router

    const jsonBodyParser = bodyParser4(this)

    // service root
    router.head('/', (_, res) => res.json({}))
    const entities = Object.keys(srv.entities).map(e => ({ name: e, url: e }))
    router.get('/', (_, res) => res.json({ entities }))

    // validate headers
    router.use((req, res, next) => {
      if (req.method in { POST: 1, PUT: 1, PATCH: 1 } && req.headers['content-type']) {
        const parts = req.headers['content-type'].split(';')
        if (!parts[0].match(/^application\/json$/) || parts[1] === '') {
          throw cds.error('INVALID_CONTENT_TYPE_ONLY_JSON', { statusCode: 415, code: '415' }) // FIXME: better i18n + use res.status
        }
      }
      if (req.method in { PUT: 1, PATCH: 1 }) {
        if (req.headers['content-length'] === '0') {
          res.status(400).json({ error: { message: 'Malformed document', statusCode: 400, code: '400' } })
          return
        }
      }

      return next()
    })
    router.use(jsonBodyParser)
    router.use(parse(this))

    // handle
    const operation_middleware = operation(this)
    const create_middleware = create(this)
    const read_middleware = read(this)
    const update_middleware = update(this)
    const delete_middleware = deleet(this)
    router.use(async function dispatch(req, res, next) {
      try {
        let result, status, location

        if (req._operation) {
          // actions and functions
          ;({ result, status } = await operation_middleware(req, res))
        } else {
          // CRUD
          switch (req.method) {
            case 'POST':
              ;({ result, status, location } = await create_middleware(req, res))
              break
            case 'HEAD':
            case 'GET':
              ;({ result, status } = await read_middleware(req, res))
              break
            case 'PUT':
            case 'PATCH':
              // eslint-disable-next-line no-case-declarations
              const _res = await update_middleware(req, res, next)
              if (_res) ({ result, status } = _res)
              break
            case 'DELETE':
              ;({ result, status } = await delete_middleware(req, res))
              break
          }
        }

        if (status || result !== undefined) {
          req._result = { result, status, location }
          return next()
        }
      } catch (e) {
        next(e)
      }
    })

    // handle result
    router.use((req, res) => {
      const { result, status, location } = req._result // REVISIT: Ugly voodoo _req._result channel -> eliminate

      // if authentication or something else within the processing of a cds.Request terminates the request, no need to continue
      if (res.headersSent) return

      // convert binaries
      let definition = req._operation || req._query.__target
      if (typeof definition === 'string')
        definition =
          srv.model.definitions[definition] ||
          srv.model.definitions[definition.split(':$:')[0]].actions[definition.split(':$:')[1]]
      if (result && srv && definition) bufferToBase64(result, srv, definition)

      if (status && res.statusCode === 200) res.status(status) //> only set status if not yet modified
      if (location && !res.getHeader('location')) res.set('location', location)

      // prettier-ignore
      if (req.method === 'HEAD') res.type('json').set({ 'content-length': JSON.stringify(result).length }).end()
      else res.send(typeof result === 'number' ? result.toString() : result)
    })

    // error handling
    router.use(error(this))

    return router
  }
}

module.exports = RestAdapter
