const cds = require('../../_runtime/cds')
const { INSERT } = cds.ql

const _error4 = rejected =>
  rejected.length > 1
    ? Object.assign(new Error('MULTIPLE_ERRORS'), { details: rejected.map(r => r.reason) })
    : rejected[0].reason

module.exports = adapter => {
  const { service } = adapter

  return async function create(req, res) {
    const { _query: query, _data, _params: params } = req

    let result, location

    // add the data
    query.entries(_data)
    if (query.INSERT.entries.length > 1) {
      // > batch insert
      const cdsReqs = query.INSERT.entries.map(entry => {
        return adapter.request4({ query: INSERT.into(query.INSERT.into).entries(entry), params, req, res })
      })
      const ress = await Promise.allSettled(cdsReqs.map(req => service.dispatch(req)))
      const rejected = ress.filter(r => r.status === 'rejected')
      if (rejected.length) throw _error4(rejected)
      result = ress.map(r => r.value)
    } else {
      // > single insert
      const cdsReq = adapter.request4({ query, params, req, res })
      result = await service.dispatch(cdsReq)
      // REVISIT: location is a restful feature -> share with odata
      // REVISIT: Is it guaranteed that the GET works? Why do we need relative urls?
      location = `../${cdsReq.entity.replace(service.definition.name + '.', '')}`
      for (const k in cdsReq.target.keys) location += `/${result[k]}`
    }

    return { result, status: 201, location }
  }
}
