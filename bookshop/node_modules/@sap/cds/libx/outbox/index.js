const cds = require('../_runtime/cds')
const LOG = cds.log('persistent-outbox')

const { inspect } = require('util')

const OutboxRunner = require('./OutboxRunner')
const outboxRunner = new OutboxRunner()

const waitingTime = require('../_runtime/common/utils/waitingTime')
const { isStandardError } = require('../_runtime/common/error/standardError')

const cdsUser = 'cds.internal.user'
const $messageProcessorRegistered = Symbol('message processor registered')
const $outboxed = Symbol('outboxed')
const $unboxed = Symbol('unboxed')
const $stored_reqs = Symbol('stored_reqs')

const _get100NanosecondTimestampISOString = () => {
  const [now, nanoseconds] = [new Date(), process.hrtime()[1]]
  return now.toISOString().replace('Z', `${nanoseconds}`.padStart(9, '0').substring(3, 7) + 'Z')
}

const _getMessagesEntity = () => {
  const messagesDbName = 'cds.outbox.Messages'
  const messagesEntity = cds.model.definitions[messagesDbName]
  if (!messagesEntity)
    throw new Error(`The entity '${messagesDbName}' is missing but needed for the persistent outbox.`)
  return messagesEntity
}

// REVISIT: Is this always a reliable way to identify the provider tenant?
//          Are there scenarios where the credentials have a different format?
const _isProviderTenant = tenant =>
  cds.requires.auth && cds.requires.auth.credentials && cds.requires.auth.credentials.identityzoneid === tenant || cds.requires.multitenancy.t0 === tenant

const hasPersistentOutbox = tenant => {
  if (!cds.requires.outbox || cds.requires.outbox.kind !== 'persistent-outbox') return false
  if (cds.requires.multitenancy && tenant && _isProviderTenant(tenant)) return false // no persistence for provider account
  return true
}

const _safeJSONParse = string => {
  try {
    return string && JSON.parse(string)
  } catch {
    // Don't throw
  }
}

// Note: This function can also run for each tenant on startup
const processMessages = async (service, tenant, _opts = {}) => {
  const opts = Object.assign({ attempt: 0 }, _opts)
  const name = service.name
  const messagesEntity = _getMessagesEntity()

  outboxRunner.run({ name, tenant }, () => {
    let letAppCrash = false
    const config = tenant ? { tenant, user: cds.User.privileged } : { user: cds.User.privileged }
    config.after = 1 // make sure spawn puts its cb on the `timer` queue (via setTimeout), which is also used by `outboxRunner`
    const spawn = cds.spawn(async () => {
      let messages
      try {
        const messagesQuery = SELECT.from(messagesEntity)
          .where({ target: name })
          .orderBy(['timestamp', 'ID'])
          .limit(opts.chunkSize)
          .forUpdate()
        if (opts.maxAttempts) messagesQuery.where({ attempts: { '<': opts.maxAttempts } })
        messages = await messagesQuery
      } catch (e) {
        // could potentially be a timeout
        const _waitingTime = waitingTime(opts.attempt)
        LOG.error(`${name}: Message retrieval failed`, e, `Retrying in ${Math.round(_waitingTime / 1000)} s`)
        outboxRunner.schedule(
          {
            name,
            tenant,
            waitingTime: _waitingTime
          },
          () => processMessages(service, tenant, { ...opts, attempt: opts.attempt + 1 })
        )
        return
      }
      let currMaxAttempts = 0
      const messagesGen = function* () {
        for (const _message of messages) {
          const _msg = _safeJSONParse(_message.msg)
          const userId = _msg[cdsUser]
          const msg = _msg._fromSend ? new cds.Request(_msg) : new cds.Event(_msg)
          delete msg._fromSend
          Object.defineProperty(msg, '_fromOutbox', { value: true, enumerable: false })
          delete msg[cdsUser]
          currMaxAttempts = Math.max(_message.attempts || 0, currMaxAttempts)
          const user = new cds.User.Privileged(userId)
          if (!msg) continue
          const res = {
            ID: _message.ID,
            msg,
            user
          }
          yield res
        }
      }

      const toBeDeleted = []
      const toBeUpdated = []
      try {
        const _handleWithErr = async ({ msg, user, ID }) => {
          try {
            await cds._context.run({ user, tenant }, async () => {
              if (opts.handle) await opts.handle.call(service, msg)
              else await service.handle(msg)
            })
            toBeDeleted.push(ID)
          } catch (e) {
            if (isStandardError(e)) {
              LOG.error(`${service.name}: Programming error detected:`, e)
              toBeDeleted.push(ID)
              throw new Error(`${service.name}: Programming error detected.`)
            }
            if (e.unrecoverable) {
              LOG.error(`${service.name}: Unrecoverable error:`, e)
              if (opts.maxAttempts) {
                const _msg = { ID, attempts: opts.maxAttempts }
                if (opts.storeLastError !== false) _msg.lastError = e
                toBeUpdated.push(_msg)
              } else toBeDeleted.push(ID)
            } else {
              LOG.error(`${service.name}: Emit failed:`, e)
              const _msg = { ID }
              if (opts.storeLastError !== false) _msg.lastError = e
              toBeUpdated.push(_msg)
              return false
            }
          }
        }
        const messages = messagesGen()
        // REVISIT: Maybe we can also support handleMany and provide the iterator (for batch processing)
        if (opts.parallel) {
          const first = messages.next()?.value // First try to see if message can be emitted
          if (!(first && (await _handleWithErr(first)) === false)) { // No need to process the rest if the first emit failed
            const res = await Promise.allSettled([...messages].map(_handleWithErr))
            const errors = res.filter(r => r.status === 'rejected').map(r => r.reason)
            if (errors.length) {
              throw new Error(`${service.name}: Programming errors detected.`)
            }
          }
        } else {
          for (const msg of messages) {
            if ((await _handleWithErr(msg)) === false) break
          }
        }
      } catch {
        letAppCrash = true
      }

      const queries = []
      const _waitingTime = waitingTime(currMaxAttempts)
      if (toBeDeleted.length) queries.push(DELETE.from(messagesEntity).where('ID in', toBeDeleted))
      if (toBeUpdated.length) {
        for (const toBeUpdatedMsg of toBeUpdated) {
          if (toBeDeleted.includes(toBeUpdatedMsg.ID)) continue
          const data = {
            attempts: { '+=': 1 }
          }
          Object.assign(data, toBeUpdatedMsg)
          if (data.lastError && typeof data.lastError !== 'string') data.lastError = inspect(data.lastError)
          queries.push(UPDATE(messagesEntity).where({ ID: toBeUpdatedMsg.ID }).set(data))
        }
      }

      await Promise.all(queries)

      if (letAppCrash) return

      if (toBeUpdated.length) {
        LOG.error(`${name}: Some messages could not be emitted, retrying in ${Math.round(_waitingTime / 1000)} s`)
        return outboxRunner.schedule(
          {
            name,
            tenant,
            waitingTime: _waitingTime
          },
          () => processMessages(service, tenant, opts)
        )
      }
      outboxRunner.success({ name, tenant })
      if (toBeDeleted.length === opts.chunkSize) {
        processMessages(service, tenant, opts) // We only processed max. opts.chunkSize, so there might be more
      } else {
        LOG._trace && LOG.trace(`${name}: All messages processed`)
      }
    }, config)
    spawn.on('done', () => {
      if (letAppCrash) cds.exit(1)
      outboxRunner.end({ name, tenant }, () => processMessages(service, tenant, opts))
    })
  })
}

const registerMessageProcessor = (name, context) => {
  const registry = context[$messageProcessorRegistered] || (context[$messageProcessorRegistered] = new Set())
  if (!registry.has(name)) {
    registry.add(name)
    return true
  }
  return false
}

const _createMessage = (name, msg, context) => {
  const _msg = { [cdsUser]: context.user.id }
  if (msg._fromSend || msg.reply) _msg._fromSend = true // send or emit?
  if (msg.inbound) _msg.inbound = msg.inbound
  if (msg.event) _msg.event = msg.event
  if (msg.data) _msg.data = msg.data
  if (msg.headers) _msg.headers = msg.headers
  if (msg.query) _msg.query = msg.query
  const outboxMsg = {
    ID: cds.utils.uuid(),
    target: name,
    timestamp: _get100NanosecondTimestampISOString(), // needs to be different for each emit
    msg: JSON.stringify(_msg)
  }
  return outboxMsg
}

const writeInOutbox = async (name, msg, context) => {
  const outboxMsg = _createMessage(name, msg, context)
  const messagesEntity = _getMessagesEntity()
  return cds.tx(context).run(INSERT.into(messagesEntity).entries(outboxMsg))
}

function unboxed(srv) {
  return srv[$unboxed] || srv
}

function outboxed(srv, customOpts) {
  // outbox max. once
  if (!new.target) {
    const former = srv[$outboxed]
    if (former) return former
  }

  const originalSrv = srv[$unboxed] || srv
  const outboxedSrv = Object.create(originalSrv)
  outboxedSrv[$unboxed] = originalSrv

  if (!new.target) Object.defineProperty(srv, $outboxed, { value: outboxedSrv })

  let requiresOpts = cds.requires.outbox
  let serviceOpts = srv.options?.outbox

  if (typeof requiresOpts === 'string') requiresOpts = { kind: requiresOpts }
  if (typeof serviceOpts === 'string') serviceOpts = { kind: serviceOpts }

  const outboxOpts = Object.assign(
    {},
    (typeof requiresOpts === 'object' && requiresOpts) || {},
    (typeof serviceOpts === 'object' && serviceOpts) || {},
    customOpts || {}
  )


  outboxedSrv.handle = async function (req) {
    const context = req.context || cds.context
    if (outboxOpts.kind === 'persistent-outbox' && hasPersistentOutbox(context.tenant)) {
      // returns true if not yet registered
      if (registerMessageProcessor(srv.name, context)) {
        // NOTE: What if there are different outbox options for the same service?!
        //       There could be messages for srv1 with { maxAttempts: 1 }
        //       and messages for srv1 with { maxAttempts: 9 }.
        //       How would they be processed? I'd rather not have dedicated
        //       service names or store serialized options for each message.
        context.on('succeeded', () => processMessages(originalSrv, context.tenant, outboxOpts))
      }
      await writeInOutbox(srv.name, req, context)
      return
    }

    if (!context[$stored_reqs]) {
      context[$stored_reqs] = []
      context.on('succeeded', async () => {
        // REVISIT: Also allow maxAttempts for in-memory outbox?
        for (const _req of context[$stored_reqs]) {
          try {
            if (_req.reply) await originalSrv.send(_req)
            else await originalSrv.emit(_req)
          } catch (e) {
            LOG.error('Emit failed', { event: _req.event, cause: e })
            if (isStandardError(e)) cds.exit(1)
          }
        }
        delete context[$stored_reqs]
      })
    }
    context[$stored_reqs].push(req)
  }

  return outboxedSrv
}

module.exports = { outboxed, unboxed }
