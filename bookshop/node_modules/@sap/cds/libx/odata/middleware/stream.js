const cds = require('../../../')
const LOG = cds.log('odata')

const { Readable } = require('node:stream')

const { handleSapMessages, validateIfNoneMatch, isStream, isRedirect } = require('../utils')

const { getKeysAndParamsFromPath } = require('../../common/utils')

const getError = require('../../_runtime/common/error')
const { getTransition } = require('../../_runtime/common/utils/resolveView')

const _resolveContentProperty = (target, annotName, resolvedProp) => {
  if (target.elements[resolvedProp]) {
    return resolvedProp
  }
  LOG._warn &&
    LOG.warn(
      `"${annotName}" in entity "${target.name}" points to property "${resolvedProp}" which was renamed or is not part of the projection. You must update the annotation value.`
    )
  const mapping = getTransition(target, cds.db).mapping
  const key = [...mapping.entries()].find(({ 1: val }) => val.ref[0] === resolvedProp)
  return key?.length && key[0]
}

const _addMetadataProperty = (query, property, annotName, odataName) => {
  if (typeof property[annotName] === 'object') {
    const contentProperty = _resolveContentProperty(
      query.target,
      annotName,
      property[annotName]['='].replaceAll(/\./g, '_')
    )
    query.target.elements[contentProperty]
      ? query.SELECT.columns.push({ ref: [contentProperty], as: odataName })
      : LOG._warn &&
        LOG.warn(`"${annotName.split('.')[1]}" ${contentProperty} not found in entity "${query.target.name}".`)
  } else {
    query.SELECT.columns.push({ val: property[annotName], as: odataName })
  }
}

const _addStreamMetadata = query => {
  // new odata parser sets streaming property in SELECT.from
  const ref = query.SELECT.columns?.[0].ref || query.SELECT.from.ref
  const propertyName = ref.at(-1)
  let mediaTypeProperty
  for (let key in query.target.elements) {
    const val = query.target.elements[key]
    if (val['@Core.MediaType'] && val.name === propertyName) {
      mediaTypeProperty = val
      break
    }
  }

  _addMetadataProperty(query, mediaTypeProperty, '@Core.MediaType', '$mediaContentType')

  if (mediaTypeProperty['@Core.ContentDisposition.Filename']) {
    _addMetadataProperty(
      query,
      mediaTypeProperty,
      '@Core.ContentDisposition.Filename',
      '$mediaContentDispositionFilename'
    )
  }

  if (mediaTypeProperty['@Core.ContentDisposition.Type']) {
    query.SELECT.columns.push({
      val: mediaTypeProperty['@Core.ContentDisposition.Type'],
      as: '$mediaContentDispositionType'
    })
  }
}

const _validateStream = (req, result) => {
  // REVISIT: compat, should actually be treated as object
  if (!Array.isArray(result)) result = [result]

  // Reading one entity or a property of it should yield only a result length of one.
  if (result.length === 0 || result[0] === undefined) throw getError(404)

  if (result.length > 1) throw getError(400)

  if (result[0] === null) return

  result = result[0]

  const headers = req.headers
  const contentType = result.$mediaContentType

  if (!headers?.accept || !contentType) return

  if (
    !headers.accept.includes('*/*') &&
    !headers.accept.includes(contentType) &&
    !headers.accept.includes(contentType.split('/')[0] + '/*')
  ) {
    const msg = `Content type "${contentType}" is not listed in accept header "${headers.accept}"`
    throw Object.assign(new Error(msg), { statusCode: 406 })
  }
}

const _ensureStream = stream => {
  if (stream === null) return null
  // temp workaround for url streaming
  const stream_ = new Readable()
  stream_.push(stream)
  stream_.push(null)
  return stream_
}

const _normalizeStream = (result, propertyName, lastPathElement, target) => {
  if (!result) return null

  let readable = result
  if (typeof result === 'object') {
    if (propertyName && result[propertyName] !== undefined) {
      readable = result[propertyName]
    }
    // implicit streaming
    else if (lastPathElement === '$value') {
      const property = Object.values(target.elements).find(
        el => el.type === 'cds.LargeBinary' && result[el.name] !== undefined
      )
      readable = property && result[property.name]
    }
    // result.value can be obtained from custom handlers
    else if (result.value !== undefined) {
      readable = result.value
    }
  }

  if (!(readable instanceof Readable)) {
    readable = _ensureStream(readable)
  }

  if (readable) {
    readable.on('error', () => {
      readable.removeAllListeners('error')
      // readable.destroy() does not end stream in node 10 and 12
      readable.push(null)
    })
  }

  return readable
}

const _setStreamingHeaders = (result, res) => {
  // backwards compatibility for Content-Type in stream
  if (result['$mediaContentType']) res.setHeader('Content-Type', result.$mediaContentType)
  else if (result['*@odata.mediaContentType']) res.setHeader('Content-Type', result['*@odata.mediaContentType'])
  else res.setHeader('Content-Type', 'application/octet-stream')

  if ('$mediaContentDispositionFilename' in result) {
    const cdt = result.$mediaContentDispositionType || 'attachment'
    res.setHeader(
      'content-disposition',
      `${cdt}; filename="${encodeURIComponent(result.$mediaContentDispositionFilename)}"`
    )
  }
}

module.exports = adapter => {
  const { service } = adapter

  return function stream(req, res, next) {
    const { _query: query } = req

    // $apply with concat -> multiple queries with special handling -> read only, no stream?
    if (Array.isArray(query)) return next()

    if (isRedirect(query)) {
      const cdsReq = adapter.request4({ query, req, res })
      service.dispatch(cdsReq).then(result => {
        if (result[query._propertyAccess]) res.set('Location', result[query._propertyAccess])
        return res.sendStatus(307)
      })
    }

    const [previous, lastPathElement] = req.path.split('/').slice(-2)
    const _isStreamByDollarValue =
      query.SELECT?.one && lastPathElement === '$value' && !(previous in query.target.elements)
    if (_isStreamByDollarValue) {
      for (const k in query.target.elements) {
        if (query.target.elements[k]['@Core.MediaType']) {
          query.SELECT.columns = [{ ref: [k] }]
          query._propertyAccess = k
          break
        }
      }
    }

    const pdfMimeType = !!req.headers.accept?.match(/application\/pdf/)
    const isMimeTypeStreamedByDefault = !!(!query.SELECT.one && pdfMimeType)
    const _isStream = isStream(query) || _isStreamByDollarValue || isMimeTypeStreamedByDefault

    if (!_isStream) return next()

    if (!query.target['@cds.persistence.skip'] && !isMimeTypeStreamedByDefault) {
      _addStreamMetadata(query)
    }

    // for read and delete, we provide keys in req.data
    // payload & params
    const { keys, params } = getKeysAndParamsFromPath(query.SELECT.from, service)

    // we need the cds request, so we can access the modified query, which is cloned due to lean-draft, so we need to use dispatch here and pass a cds req
    const cdsReq = adapter.request4({ query, data: keys, params, req, res })

    // REVISIT: what is this for? some tests fail without it... we should find a better solution!
    Object.defineProperty(query.SELECT, '_4odata', { value: true })

    // NOTES:
    // - only via srv.run in combination with srv.dispatch inside,
    //   we automatically either use a single auto-managed tx for the req (i.e., insert and read after write in same tx)
    //   or the auto-managed tx opened for the respective atomicity group, if exists
    // - in the then block of .run(), the transaction is committed (i.e., before sending the response) if a single auto-managed tx is used
    return service
      .run(() => {
        return service.dispatch(cdsReq).then(async result => {
          _validateStream(req, result)

          if (validateIfNoneMatch(cdsReq.target, req.headers?.['if-none-match'], result)) return res.sendStatus(304)

          const stream = _normalizeStream(result, query._propertyAccess, lastPathElement, query.target)
          if (stream === null) return res.sendStatus(204)

          if (pdfMimeType && !result.$mediaContentType) result.$mediaContentType = 'application/pdf'

          _setStreamingHeaders(result, res)

          return new Promise((resolve, reject) => {
            if (res.destroyed) return reject(new Error('Response was closed while streaming'))
            stream.pipe(res)
            stream.on('end', () => resolve(result))
            stream.once('error', reject)
            let finished = false
            res.on('finish', () => (finished = true))
            res.on('close', () => !finished && reject(new Error('Response was closed while streaming')))
          })
        })
      })
      .then(() => {
        handleSapMessages(cdsReq, req, res)

        res.end()
      })
      .catch(err => {
        handleSapMessages(cdsReq, req, res)

        next(err)
      })
  }
}
