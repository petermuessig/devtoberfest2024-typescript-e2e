const cds = require('../../../')
const { INSERT } = cds.ql

const { calculateLocationHeader, handleSapMessages, getPreferReturnHeader } = require('../utils')
const getODataMetadata = require('../utils/metadata')
const postProcess = require('../utils/postProcess')
const readAfterWrite4 = require('../utils/readAfterWrite')
const getODataResult = require('../utils/result')

const { getKeysAndParamsFromPath } = require('../../common/utils')

module.exports = (adapter, isUpsert) => {
  // REVISIT: adapter should be this
  const { service } = adapter
  const _readAfterWrite = readAfterWrite4(adapter, 'create')

  return function create(req, res, next) {
    const {
      SELECT: { one, from },
      target
    } = req._query

    // req.__proto__.method is set in case of upsert
    // const isUpsert = req.__proto__.method in { PUT: 1, PATCH: 1 }

    if (one && !isUpsert) {
      const msg = 'Method POST is not allowed for singletons and individual entities'
      throw Object.assign(new Error(msg), { statusCode: 405 })
    }

    // payload & params
    const data = req.body
    const { keys, params } = getKeysAndParamsFromPath(from, service)
    // add keys from url into payload (overwriting if already present)
    Object.assign(data, keys)

    const _isDraft = target.drafts && data.IsActiveEntity !== true

    // query
    const query = INSERT.into(from).entries(data)

    // cdsReq.headers should contain merged headers of envelope and subreq
    const headers = { ...cds.context.http.req.headers, ...req.headers }

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    const cdsReq = adapter.request4({ query, params, headers, req, res })

    // rewrite event for draft-enabled entities
    if (_isDraft) cdsReq.event = 'NEW'

    // NOTES:
    // - only via srv.run in combination with srv.dispatch inside,
    //   we automatically either use a single auto-managed tx for the req (i.e., insert and read after write in same tx)
    //   or the auto-managed tx opened for the respective atomicity group, if exists
    // - in the then block of .run(), the transaction is committed (i.e., before sending the response) if a single auto-managed tx is used
    return service
      .run(() => {
        return service.dispatch(cdsReq).then(result => {
          // REVISIT: shouldn't read after write be the default behavior (that could be suppressed)?
          // generic handlers indicate that read after write is required
          if (cdsReq._.readAfterWrite) return _readAfterWrite(cdsReq)
          return result
        })
      })
      .then(result => {
        handleSapMessages(cdsReq, req, res)

        // case: read after write returns no results, e.g., due to auth (academic but possible)
        if (result == null) return res.sendStatus(204)

        if (!target._isSingleton) {
          // determine calculation based on result with req.data as fallback
          res.set('location', calculateLocationHeader(cdsReq.target, service, result || cdsReq.data))
        }

        const isMinimal = getPreferReturnHeader(req) === 'minimal'
        postProcess(cdsReq.target, service, result, isMinimal)
        if (result?.$etag) res.set('ETag', result.$etag) //> must be done after post processing
        if (isMinimal) return res.sendStatus(204)

        const metadata = getODataMetadata(query, { result })
        result = getODataResult(result, metadata)
        res.status(201).send(result)
      })
      .catch(err => {
        handleSapMessages(cdsReq, req, res)

        // REVISIT: invoke service.on('error') for failed batch subrequests
        if (cdsReq.http.req.path.startsWith('/$batch') && service._handlers._error.length) {
          for (const each of service._handlers._error) each.handler.call(service, err, cdsReq)
        }

        next(err)
      })
  }
}
