const { cds2edm } = require('./index')

const { where2obj } = require('../../_runtime/common/utils/cqn')

const _isNavToDraftAdmin = path => path.length > 1 && path[path.length - 1] === 'DraftAdministrativeData'

const _lastValidRef = ref => {
  for (let i = ref.length - 1; i >= 0; i--) {
    if (ref[i] in { DraftAdministrativeData: 1, SiblingEntity: 1 }) continue
    return ref[i]
  }
}

const _odataContext = (query, options) => {
  let path = '$metadata'
  if (query._target.kind === 'service') return path

  const {
    _target: { _isSingleton: isSingleton },
    _propertyAccess: propertyAccess
  } = query

  const { result, isCollection } = options

  path += '#'

  // REVISIT: subselect is treated as empty array
  const ref =
    query.SELECT?.from?.ref ?? query.UPDATE?.entity?.ref ?? query.INSERT?.into?.ref ?? query.DELETE?.from?.ref ?? []

  const isNavToDraftAdmin = _isNavToDraftAdmin(ref)

  let edmName
  if (options.edmName) edmName = options.edmName
  else if (isNavToDraftAdmin) edmName = ref[0].id ?? ref[0]
  else if (cds2edm[query._target.type]) edmName = cds2edm[query._target.type]
  else edmName = query._target.name

  if (isCollection && query._target.kind === 'type') edmName = `Collection(${edmName})`

  const serviceName = query._target._service?.name
  if (serviceName) edmName = edmName.replace(serviceName + '.', '').replace(/\./g, '_')

  if (ref.length > 1) {
    // prepend for relative path
    path = '../'.repeat(ref.length - 1) + path
  }

  path += edmName

  const lastRef = ref.at(-1)

  if (propertyAccess) {
    path = '../' + path

    const lastValidRef = _lastValidRef(ref)
    if (lastValidRef.where) {
      let keys
      const isSibling = lastRef === 'SiblingEntity'
      if (lastValidRef.where.length > 3) {
        // multiple keys should contain key name
        const _keys = where2obj(lastValidRef.where)
        keys = Object.keys(_keys).map(k => {
          if (k === 'IsActiveEntity' && isSibling) return k + '=' + !_keys[k]
          return k + '=' + _keys[k]
        })
      } else {
        // single keys can just contain value
        keys = [lastValidRef.where.at(-1).val]
      }

      path += '(' + keys.join(',') + ')'
    } else if (!isSingleton) {
      // use keys from result if not in query
      const _keys = Object.keys(query._target.keys)
      let keyString
      if (_keys.length === 1) {
        keyString = result[_keys[0]]
      } else {
        keyString = _keys.map(k => k.name + '=' + result[k.name]).join(',')
      }
      path += '(' + keyString + ')'
    }

    if (isNavToDraftAdmin) {
      path += '/' + lastRef
    }

    path += '/' + propertyAccess
  } else if (isNavToDraftAdmin) {
    const lastValidRef = _lastValidRef(ref)
    if (lastValidRef.where) {
      let keys
      const isSibling = lastRef === 'SiblingEntity'
      if (lastValidRef.where.length > 3) {
        // multiple keys should contain key name
        const _keys = where2obj(lastValidRef.where)
        keys = Object.keys(_keys).map(k => {
          if (k === 'IsActiveEntity' && isSibling) return k + '=' + !_keys[k]
          return k + '=' + _keys[k]
        })
      } else {
        // single keys can just contain value
        keys = [lastValidRef.where.at(-1).val]
      }

      path += '(' + keys.join(',') + ')'
    }
    path += '/' + lastRef
  }

  if ((!isCollection && !isSingleton && !propertyAccess) || (isNavToDraftAdmin && !propertyAccess)) {
    path += '/$entity'
  }

  return path
}

/**
 * TODO
 *
 * @param {*} query
 * @param {*} [options]
 * @param {*} [options.result]
 * @param {*} [options.isCollection]
 * @param {*} [options.edmName]
 * @returns
 */
module.exports = function getODataMetadata(query, options = {}) {
  if (!query._target) return

  const context = _odataContext(query, options)

  return { context }
}
