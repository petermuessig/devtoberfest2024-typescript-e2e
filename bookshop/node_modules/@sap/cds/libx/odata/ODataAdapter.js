const HttpAdapter = require('../../lib/srv/protocols/http')
const cds = require('../../lib')
const LOG = cds.log('odata')

const operation4 = require('./middleware/operation')
const create4 = require('./middleware/create')
const stream4 = require('./middleware/stream')
const read4 = require('./middleware/read')
const update4 = require('./middleware/update')
const delete4 = require('./middleware/delete')
const error4 = require('./middleware/error')
const bodyParser4 = require('./middleware/body-parser')

// REVISIT: copied from lib/req/request.js
const Http2Crud = { POST: 'CREATE', GET: 'READ', PUT: 'UPDATE', PATCH: 'UPDATE', DELETE: 'DELETE' }

const { isStream } = require('./utils')

class ODataAdapter extends HttpAdapter {
  log(req) {
    // REVISIT: this impl recreates the behavior of the old adapter, but is not very clean

    // req.__proto__.method is set in case of upsert
    if (req.__proto__.method in { PUT: 1, PATCH: 1 }) return // REVISIT: voodoo magic

    if (req._subrequest)
      //> req._subrequest is set for batch subrequests
      LOG._info && LOG.info('>', Http2Crud[req.method], req.path, Object.keys(req.query).length ? { ...req.query } : '')
    else super.log(req)
  }

  // early_access_check4(srv) { // REVISIT: let's remove that!
  //   const super_early_access_check = super.early_access_check4(srv)
  //   // REVISIT: We should remove the protectMetadata option in cds8, and always just do the right thing -> DOUBLE CHECK: Bad fiori behavior on 403ers
  //   return function early_access_check(req, res, next) {
  //     if (cds.env.odata.protectMetadata === false && (req.path === '/' || req.path === '/$metadata')) { // REVISIT: do that statically!
  //       // > nothing to do
  //       return next()
  //     }

  //     // REVISIT: Why exactly was that required?
  //     // > It was wrong, as it requested a login for any service operation, even though only one action was restricted (submitOrder)
  //     // we need to challenge in case of $batch requests if the service has restrictions
  //     // const user = cds.context.user
  //     // if (user._is_anonymous && req.path === '/$batch' && containsAnyRestrictions(srv)) {
  //     //   if (!req._login) throw cds.error({ code: '401', statusCode: 401 })
  //     //   return req._login()
  //     // }

  //     return super_early_access_check(req, res, next)
  //   }
  // }

  get router() {
    const jsonBodyParser = bodyParser4(this)
    return (
      super.router
        .use(function odata_version(req, res, next) {
          res.set('OData-Version', '4.0')
          next()
        })
        // REVISIT: add middleware for negative cases?
        // service root
        .use(/^\/$/, require('./middleware/service-document')(this))
        .use('/\\$metadata', require('./middleware/metadata')(this))
        // parse
        .use(require('./middleware/parse')(this))
        .use(function odata_streams(req, res, next) {
          if (req.method === 'PUT' && isStream(req._query)) {
            req.body = { value: req }
            return next()
          }
          if (req.method === 'POST' && req.headers['content-type']?.match(/multipart\/mixed/)) {
            return next()
          }
          if (req.method in { POST: 1, PUT: 1, PATCH: 1 } && req.headers['content-type']) {
            const parts = req.headers['content-type'].split(';')
            // header ending with semicolon is not allowed
            if (!parts[0].match(/^application\/json$/) || parts[1] === '') {
              throw cds.error('415', { statusCode: 415, code: '415' }) // FIXME: use res.status
            }
          }
          // POST with empty body is allowed by actions
          if (req.method in { PUT: 1, PATCH: 1 }) {
            if (req.headers['content-length'] === '0') {
              res.status(400).json({ error: { message: 'Expected non-empty body', statusCode: 400, code: '400' } })
              return
            }
          }

          return jsonBodyParser(req, res, next)
        })
        // batch
        .post('/\\$batch', require('./middleware/batch')(this))
        // handle
        // REVISIT: with old adapter, we return 405 for HEAD requests -> check OData spec
        .head('*', (_, res) => res.sendStatus(405))
        .post('*', operation4(this), create4(this))
        .get('*', operation4(this), stream4(this), read4(this))
        .put('*', update4(this), create4(this, 'upsert'))
        .patch('*', update4(this), create4(this, 'upsert'))
        .delete('*', delete4(this))
        // error
        .use(error4(this))
    )
  }

  request4(args) {
    return new NoaRequest(args)
  }
}

// REVISIT: ugly hack -> eliminate
class NoaRequest extends cds.Request {
  // REVISIT: all usages of .protocol are very bad style, violating modularization
  get protocol() {
    return 'odata'
  }
  // AFC uses unofficial req._queryOptions -> which is bad! -> should eliminate
  get _queryOptions() {
    cds.utils.deprecated({ kind: '', old: 'req._queryOptions', new: 'req._.req.query' })
    return this.req?.query
  }
}

module.exports = Object.assign(ODataAdapter, { NoaRequest })
